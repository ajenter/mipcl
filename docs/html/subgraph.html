<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: Connected subgraphs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Connected subgraphs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_subgraph"></a>
Connected subgraphs with restrictions on node degrees</h1>
<p>The <em>minimum k-connected subgraph problem</em> with restriction on node degrees is formulated as follows: in a given graph <img class="formulaInl" alt="$G=(V,E)$" src="form_4.png"/> with edge costs <img class="formulaInl" alt="$c_e\; (e\in E)$" src="form_38.png"/>, find a <em>k</em>-connected subgraph (there exist <em>k</em> edge-disjoint paths between any pair of its nodes) of minimum sum cost of its edges, subject to the constraint that the degree of any node <img class="formulaInl" alt="$v\in V$" src="form_5.png"/> must not exceed a given bound <img class="formulaInl" alt="$d_v$" src="form_6.png"/>. Let us note that this problem is a skeleton for some network design problems, where <em>k</em>-connectivity expresses the requirement that the network is <em>survivable</em> what means that it must be possible to establish connection between any two pairs of nodes even if any <em>k</em>-1 edges (links) have been destroyed. Let us also note, that this problem is strongly <b>NP</b>-hard.</p>
<p>If all <img class="formulaInl" alt="$c_e &gt; 0\text{ and } k=1$" src="form_39.png"/>, then any optimal subgraph is a tree. An important special case of this problem, when <img class="formulaInl" alt="$k=1\text{ and all } d_v=2$" src="form_40.png"/>, is the <em>minimum hamilton path problem</em>, which is equivalent to the <em>traveling salesman problem</em> (TSP). Let us remember, that a <em>hamilton path</em> is a simple path that covers all the nodes.</p>
<p>Introducing for each <img class="formulaInl" alt="$e\in E$" src="form_20.png"/> a binary variable <img class="formulaInl" alt="$x_e$" src="form_19.png"/> ( <img class="formulaInl" alt="$x_e=1$" src="form_41.png"/> if edge <em>e</em> belongs to the subgraph, and <img class="formulaInl" alt="$x_e=0$" src="form_11.png"/> otherwise), we write the formulation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{e\in E} c_e x_e &amp;\to \min,\tag{1.a}\\ \sum_{e\in E(v,V)} x_e &amp;\le d_v,\quad v\in V,\tag{1.b}\\ \sum_{e\in E(S,V\setminus S)} x_e &amp;\ge k,\quad S\subset V,\; S\neq\emptyset,\tag{1.c}\\ x_e &amp;\in \{0,1\},\quad e\in E.\tag{1.d} \end{align*}" src="form_42.png"/>
</p>
<p> Here <img class="formulaInl" alt="$E(S,T)$" src="form_43.png"/> denotes the set of edges with one end node in <img class="formulaInl" alt="$S\subseteq V$" src="form_44.png"/> and the other in <img class="formulaInl" alt="$T\subseteq V$" src="form_45.png"/>. The inequalities (1.b) restrict node degrees. The inequalities (1.c), known as <em>cut inequalities</em>, impose the requirement that the subgraph with edges <img class="formulaInl" alt="$\{e\in E:\; x_e = 1\}$" src="form_46.png"/> be <em>k</em>-connected.</p>
<h2><a class="anchor" id="sec_sepCutIneq"></a>
Separation for cut inequalities</h2>
<p>Given a point <img class="formulaInl" alt="$\tilde{x}\in [0,1]^{E}$" src="form_47.png"/> that meats the constraints (1.b), we need to check whether this point satisfies the inequalities (1.c), and, if there exist violated inequalities, find one of them. This separation problem can be formulated as the <em>minimum cut problem</em> in which we need to find a proper subset <img class="formulaInl" alt="$\tilde{S}\; (\emptyset\neq \tilde{S}\subset V)$" src="form_48.png"/> of vertices such that the value of <img class="formulaInl" alt="$\tilde{x}(S)\stackrel{\mathrm{def}}{=}\sum_{e\in E(\tilde{S},V\setminus \tilde{S})} \tilde{x}_e$" src="form_49.png"/> is minimal. If <img class="formulaInl" alt="$\tilde{x}(S) &lt; k$" src="form_50.png"/>, then the inequality <img class="formulaInl" alt="$\sum_{e\in E(\tilde{S},V\setminus \tilde{S})} x_e \ge k$" src="form_51.png"/> is violated at point <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/>; otherwise, <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/> satisfies all the inequalities (1.c).</p>
<p>There are a number of efficient minimum cut algorithms. We could use one of them for solving the problem of separating by the cut inequalities. Instead, to demonstrate the power and flexibility of <b>MIPCL</b>, we will solve this separation problem by solving |<em>V|-1</em> LPs.</p>
<p>It is said that the cut given by a set <img class="formulaInl" alt="$S\subset V$" src="form_53.png"/> separates two nodes <img class="formulaInl" alt="$s,t\in V\text{ if } s\in S\text{ and } t\not\in S$" src="form_54.png"/>; such sets are also called (<em>s,t</em>)-cuts. Let us introduce the following variables:</p><ul>
<li><img class="formulaInl" alt="$p_v=1\text{ if } v\in\tilde{S}\text{, and } p_v=0\text{ if } v\in\ V\setminus\tilde{S}$" src="form_55.png"/>;</li>
<li><img class="formulaInl" alt="$\gamma_e=1\text{ if } e\in E(\tilde{S},V\setminus\tilde{S}),\text{ and } \gamma_e=0\text{ if } e\not\in E(\tilde{S},V\setminus\tilde{S})$" src="form_56.png"/>.</li>
</ul>
<p>In these variables we formulate the following LP: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \sum_{e\in E} \tilde{x}_e \gamma_e &amp;\to \min,\\ p_w -p_v + \gamma_e &amp;\ge 0,\\ p_v -p_w + \gamma_e &amp;\ge 0, \quad e=(v,w)\in E,\\ p_s = 1,\; p_t &amp;= 0,\\ p_v &amp;\ge 0,\quad v\in V,\\ \gamma_e &amp;\ge 0,\quad e\in E. \end{aligned}\tag{2} \]" src="form_57.png"/>
</p>
<p> Since the constraint matrix in LP (2) is totally unimodular (all its minors are 0,1, or -1), this LP has an integer optimal solution <img class="formulaInl" alt="$(p^*,\gamma^*)$" src="form_58.png"/>. If <img class="formulaInl" alt="$\sum_{e\in E}\gamma^*_e \bar{x}_e &lt; k$" src="form_59.png"/>, then we have found a separating inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{e=(v,w)\in E:\; p^*_v \neq p^*_w} x_e \ge k. \]" src="form_60.png"/>
</p>
<p> Thus, solving <img class="formulaInl" alt="$|V|-1\text{ LPs for a fixed } s\in V\text{ and all } t\in V\setminus s$" src="form_61.png"/>, we will find a violated cut inequality or prove that no such one exists.</p>
<h2><a class="anchor" id="subgraphImpl"></a>
MIPCL-implementation</h2>
<p>When developing a branch-and-cut application, we need to implement a class derived from <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> (or <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> when solving an LP). In our application such a class is called <code>CSubGraph</code>. Its definition is the following. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cmip_8h.html">cmip.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="except_8h.html">except.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>CSubGraph: <span class="keyword">public</span> <a class="code" href="classCMIP.html">CMIP</a></div><div class="line">{</div><div class="line">        <span class="keywordtype">bool</span> m_bMemory;</div><div class="line">        <span class="keywordtype">int</span> m_iVertNum, m_iEdgeNum, m_iK;</div><div class="line">        <span class="keywordtype">int</span> *m_ipHead, *m_ipTail, *m_ipCost, *m_ipDeg;</div><div class="line">        <a class="code" href="classCLP.html">CLP</a>* cut;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        CSubGraph(<span class="keyword">const</span> <span class="keywordtype">char</span>* name): <a class="code" href="classCMIP.html">CMIP</a>(name), m_bMemory(false), m_ipTail(0)</div><div class="line">        {}</div><div class="line">        CSubGraph(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> k,</div><div class="line">                          <span class="keywordtype">int</span>* ipTail, <span class="keywordtype">int</span>* ipHead, <span class="keywordtype">int</span>* ipCost, <span class="keywordtype">int</span>* ipDeg): <a class="code" href="classCMIP.html">CMIP</a>(name),</div><div class="line">                          cut(0), m_iVertNum(n), m_iEdgeNum(m), m_iK(k), m_ipTail(ipTail), m_ipHead(ipHead),</div><div class="line">                          m_bMemory(false)</div><div class="line">        {}</div><div class="line"></div><div class="line"><span class="comment">// Clone constructor needed for multi-threading</span></div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">        CSubGraph(<span class="keyword">const</span> CSubGraph &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">        <a class="code" href="classCMIP.html">CMIP</a>* <a class="code" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a>(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> ~CSubGraph(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// implementation</span></div><div class="line">        <span class="keywordtype">void</span> readData(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName);</div><div class="line">        <span class="keywordtype">void</span> buildMatrix();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">void</span> cutInit(<span class="keyword">const</span> <span class="keywordtype">char</span>* name); <span class="comment">// name is needed in order not to mix log streams</span></div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate</a>(<span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* x, <span class="keyword">const</span> tagHANDLE* ipColHd, <span class="keywordtype">bool</span> bGenFlag);</div><div class="line">};</div></div><!-- fragment --><p> The members of <code>CSubGraph</code> are</p><ul>
<li><code>m_bMemory</code>: if <code>true</code>, the memory has been allocated to store a problem instance being solved;</li>
<li><code>m_iVertNum</code>: number of nodes (vertices);</li>
<li><code>m_iEdgeNum</code>: number of edges;</li>
<li><code>m_iK</code>: connectivity level which means that we need to find <code>m_iK}</code>-connected subgraph;</li>
<li><code>m_ipHead</code>, <code>m_ipTail</code>: arrays of size <code>m_iEdgeNum</code>; for <code>e=0,...,m_iEdgeNum-1$</code>, <code>(m_ipTail[e],m_ipHead[e])</code> is edge connecting tail <code>m_ipTail[e]</code> and head <code>m_ipHead[e]</code> nodes;</li>
<li><code>m_ipCost</code>: array of size <code>m_iEdgeNum</code>; <code>m_ipCost[e]</code> is cost of edge <code>e</code>;</li>
<li><code>cut</code>: pointer to <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>-object that solves LPs (2).</li>
</ul>
<p><code>CSubGraph</code> has two constructors. Each of them creates an "empty" <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> object, passing the name of the problem to the constructor of the base class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. In addition, the second constructor assigns to its members the values of input parameters that describe an instance of the minimum <em>k</em>-connected subgraph problem.</p>
<p></p>
<h3><a class="anchor" id="sec_subgraphClone"></a>
Clone constructor</h3>
<p>The implementation of the clone constructor and the function <code>clone()</code> are given below. </p><div class="fragment"></div><!-- fragment --><p> Both, the constructor and the function, are needed only if multi-threaded <b>MIPCL</b> library is used (<code>__THREADS_ &gt; 1</code> in your makefile). This implementation of <code>clone()</code> is standard for all multi-threaded <b>MIPCL</b>-applications.</p>
<h3><a class="anchor" id="sec_subgraphDestr"></a>
Destructor</h3>
<p>The goal of destructor is to free memory allocated earlier. Our implementation of the destructor is straightforward. </p><div class="fragment"></div><!-- fragment --><p> We only have to note that, when multithreading is allowed, the memory for storing input data was allocated only once in the root thread; therefore, we free that memory only when the destructor is called within the root thread (<code>m_pParent != 0</code>).</p>
<p>It is assumed that instances of are stored in text files in the following format:</p><ul>
<li>three integer numbers in line 1 are:<ul>
<li><em>n</em> - number of nodes,</li>
<li><em>m</em> - number of edges,</li>
<li><em>k</em> - connectivity level;</li>
</ul>
</li>
<li>each of the next <em>m</em> nonempty lines describes an edge and contains three integer numbers:<ul>
<li>tail and head nodes, and then cost;</li>
</ul>
</li>
<li>the last <em>n</em> integer numbers are demands at nodes.</li>
</ul>
<p>Our implementation of the function <code>readData()</code> that reads input data from a text file is straightforward, and we left it without any comments. </p><div class="fragment"></div><!-- fragment --><h3><a class="anchor" id="sec_subgraphPartForm"></a>
Partial formulation</h3>
<p>Since the system (1.c) of cut inequalities contains exponentially (in <em>n</em>) many inequalities, we cannot include all of them into the matrix when solving problems, say, with one hundred nodes. Therefore, we have to implement a so-called row generation technique, which allows us to include into the matrix only a "small" part of the inequalities of the original formulation, all the other inequalities may be added to the matrix during the solution process.</p>
<p>Initially, we add to the matrix all the constraints in MIP (1) except those in system (1.c). Any time an optimal solution <em>x</em> to a partial LP of the currently processed (search tree) node has been computed, the solver calls <code>separate()</code> to cut off <em>x</em>. In other words, <code>separate()</code> is supposed to find inequalities that are violated by <em>x</em>, and, if any has been found, <code>separate()</code> adds such inequalities to the matrix. After that, the solver re-optimizes a new partial node LP, and again calls <code>separate()</code> to cut off an optimal solution for that partial LP. This iterative process continues until no violated inequality has been found. At this point the solver proceeds to branching unless the current LP solution is integral.</p>
<p>The following procedure builds the matrix for the initial partial formulation, i.e., for MIP (1) without the system (1.c). </p><div class="fragment"></div><!-- fragment --><p>First <code>buildProb()</code> opens the matrix with <em>3m</em> rows, <em>m</em> columns, and <em>5m</em> non-zero entries. Extra rows and non-zero entries are added in order the solver allocated memory for new rows that can be added by <code>separate()</code>. Since the column structure of the truncated matrix is simpler than its row structure (each column contains exactly two non-zero entries), we build the matrix column-wise.</p>
<p>In the first <code>for</code>-loop we add <code>n</code> constraints that correspond to the equations (1.b). The second <code>for</code>-loop, for each edge <code>e=0,...,m-1</code>, adds the column with two coefficients, both equal to <code>1.0</code>, in rows <code>m_ipTail[e]</code> and <code>m_ipHead[e]</code>. The objective coefficient for this column (variable) is set to <code>-m_ipCost[e]</code>. Alternatively, we could set this objective coefficient to <code>m_ipCost[e]</code>, and then call <code>CLP::setObjSence(false)</code> to inform the solver that the objective must be minimized (by default, the objective is maximized).</p>
<p>On termination, <code>buildMatrix()</code> calls the procedure <code>cutInit()</code> that does all necessary preparations for future invocations of <code>separate()</code>.</p>
<h3><a class="anchor" id="sec_subgraphSep"></a>
Separation</h3>
<p>Since the system (1.c) of cut inequalities contains exponentially many inequalities, we cannot include all of them into the matrix. Therefore, we have to overload the function <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">CLP::separate()</a></code> of the base class <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>. But first, we describe the procedure <code>cutInit()</code> that creates an <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> object for solving LPs (2). </p><div class="fragment"></div><!-- fragment --><p> The procedure <code>cutInit()</code> creates an instance of <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> that solves the minimum cut LP (2). The pointer to this instance is stored in the class member <code>cut</code>. Then a matrix with <code>2m</code> rows, <code>n+m</code> columns, and <code>3m</code> entries is created. Here <code>n=m_iVertNum</code> and <code>m=m_iEdgeNum</code>. Since we are going to fill the matrix by adding rows, we first add (declare) variables. The <b>MIPCL</b>-variable that corresponds to the variable <img class="formulaInl" alt="$p_0$" src="form_62.png"/> is added outside the cycles where the <b>MIPCL</b>-variables corresponding to the variables <img class="formulaInl" alt="$p_1,\dots,p_{n-1}$" src="form_63.png"/> are added. This is done because node <code>0</code> is selected as the source <em>s</em>, and, therefore, the value of <img class="formulaInl" alt="$p_0$" src="form_62.png"/> is fixed to <code>1.0</code>. Next, we add the <b>MIPCL</b>-variables that correspond to the variables <img class="formulaInl" alt="$\gamma_e$" src="form_64.png"/>.</p>
<p>After having been declared the <b>MIPCL</b>-variables, we add rows (constraints), two rows per edge in the graph. Since each constraint that we are going to add contains exactly <code>3</code> nonzero entries (two times <code>1</code> and once <code>-1</code>), we declared two arrays <code>ipCol</code> and <code>dpVal</code>, both of size <code>3</code>. The former array is used to store column indices, while the latter stores nonzero entries.</p>
<p>After filling the matrix, we call <code><a class="el" href="classCLP.html#a7f638d505d663c8782b2935e8410b3be">CLP::preprocOff()</a></code> and <code>cut-&gt;setScaling()</code> to switch off preprocessing and scaling the matrix, and then <code><a class="el" href="classCLP.html#a27e86b274e43b78732ff9f51b9249f33">CLP::closeMatrix()</a></code> is called to close the matrix. As the last action, to prevent mixing messages sent by the main object and the auxiliary object <code>cut</code>, we call <code>CLP::switchPrintingInfoMsg()</code> to forbid <code>cut</code> displaying any run time messages.</p>
<p>Our implementation of <code>separate()</code> is as follows. </p><div class="fragment"></div><!-- fragment --><p> This function implements the separation algorithm described earlier. In <code>separate()</code> we call two functions, <code><a class="el" href="classCLP.html#aeb97ed82d53f698715069ce966a1dd0e">CLP::setObjCoeff()</a></code> and <code><a class="el" href="classCLP.html#a4910c689baa5522fc29d77599affc2cb">CLP::setVarUpBound()</a></code>, to modify objective coefficients and upper bounds on variables. It should be noted, that modifying problem parameters, when the problem is being solved (say, in separation routines), is dangerous. You should not be embarrassed by the fact that we change problem parameters in the separation routine. In fact, in <code>separate()</code> we do not modify the problem being solved, we modify some parameters of the auxiliary cut generating problem just before this auxiliary problem starts running.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In our implementation of <code>separate()</code> we use two auxiliary arrays <code><a class="el" href="classCLP.html#aeb819eb1c693514af99250dc539dddde" title="Auxiliary array of size max{m_iNmax,m_iMmax}.">CLP::m_ipArray</a></code> and <code><a class="el" href="classCLP.html#ac18035b5a7afb286429309ac7bf5e891" title="Auxiliary array of size m_iMmax+m_iNmax">CLP::m_dpArray</a></code>.</dd></dl>
<h3><a class="anchor" id="sec_usingCSubGraph"></a>
Using CSubGraph</h3>
<p>The following code demonstrates using <code>CSubGraph</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;subgraph.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">                CSubGraph prob(<span class="stringliteral">&quot;subgraph&quot;</span>);</div><div class="line">                prob.readData(argv[1]);</div><div class="line">                prob.buildMatrix();</div><div class="line">                prob.optimize();</div><div class="line">                prob.printSolution(<span class="stringliteral">&quot;test.sol&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span>(<a class="code" href="classCException.html">CException</a>* pe) {</div><div class="line">                std::cerr &lt;&lt; pe-&gt;<a class="code" href="classCException.html#af66e5406dda297fa8b253e89b6e00973">what</a>() &lt;&lt; std::endl;</div><div class="line">                <span class="keyword">delete</span> pe;</div><div class="line">                <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>If we removed the code for processing exceptions, the main procedure would contain only a few lines.</p>
<p>At the very beginning, we create an "empty" <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> object, named <code>prob</code>; the internal <b>MIPCL</b> name is "subgraph" (this name is primarily used to distinguish different <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> objects). Then we call <code>prob.readData()</code> to read problem instance from the file which name is given as the first program argument. Next <code>prob.buildMatrix()</code> is called to build an initial matrix. In this case, our initial formulation is not complete because the cut inequalities (1.c) are not included into the matrix. Therefore, we have to switch off preprocessing; otherwise, the solver could deduce logical implications valid for the incomplete formulation but false for the complete one. After that, we call <code>prob.optimize()</code> to solve the problem, and then we call <code>prob.printSolution()</code> to write the result to the file named "test.sol".</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCMIP.html#a0565b27e1966ceb19380a4d3d7bcec5a">CMIP::CMIP(const char*)</a></code>, <code><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">CMIP::optimize()</a></code>, <code><a class="el" href="classCLP.html#a7f638d505d663c8782b2935e8410b3be">CMIP::preprocOff()</a></code>, <code><a class="el" href="classCMIP.html#a91249febf036dd979f7584bc0962137a">CMIP::printSolution()</a></code> </dd></dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:33 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
