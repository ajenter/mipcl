<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: CMIP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">CMIP Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> has been designed for solving Mixed Integer Programs (MIPs)  
 <a href="classCMIP.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cmip_8h_source.html">cmip.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CMIP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classCMIP.png" usemap="#CMIP_map" alt=""/>
  <map id="CMIP_map" name="CMIP_map">
<area href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)" alt="CLP" shape="rect" coords="0,0,43,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af376f7257f718501639a17f9ac0e44fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa">enCtrType</a> { <br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa35908d1b46af1db5beac2afda8ab0443">CTR_LOCAL</a> = 0x00000040, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa267dcabdd7dc4f41568926f889c78834">CTR_INT_VARS</a> = 0x00000080, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa521403a776c48d87365dbde76f965ced">CTR_INT_COEFF</a> = 0x00000100, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faaa85c6252ffd40b0868c7fcee80680bf6">CTR_INT</a> = CTR_INT_VARS|CTR_INT_COEFF, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa7c534f91d259b798737681c8ffcce176">CTR_VAR</a> = 0x00000200, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa0cb55d55ce364d7fdb844f6dae6329d1">CTR_BINPACK</a> = 0x00000400, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa53d2704d65bc36d4e97200da08886908">CTR_KNAPSACK</a> = 0x00000800, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faac8b20b9e1cd38e68ca22106b14b1230e">CTR_MX_KNAPSACK</a> = 0x00001000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa31bf0a7a42fc21b4fe4968c7273dcae7">CTR_PACKING</a> = 0x00002000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faaed432778f21bc50db9a1a4188a2566dd">CTR_INV_KNAPSACK</a> = 0x00004000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faaca34092df8bd6211bccd9bd48c149cc8">CTR_COVERING</a> = CTR_INV_KNAPSACK, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa92003ad7d22f0d30a1c5fc490181c3eb">CTR_CARDINALITY</a> = 0x00008000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa6ba88b6a9073807f328549410f72830c">CTR_GUB</a> = CTR_PACKING|CTR_CARDINALITY, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faad3fe8c4fc08dc8e88dba26b9d3616301">CTR_SOS1</a> = 0x00010000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faac75afc03827aa23fd4de17c4709ebb2d">CTR_SOS2</a> = 0x00020000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faadbc9d352261997c3fd5f593b8d1afeed">CTR_01FLOW</a> = 0x00040000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa9a263ebfc8abf4a62d47039085bd6e20">CTR_WITH_VAR_BOUNDS</a> = 0x00080000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa119b93713f932e4e840f9013ad54a917">CTR_WITH_UNIQUE</a> = 0x00100000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa006d51c9b93668064e5f5bfe8f155612">CTR_PARITY</a> = 0x00200000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa5de7f272abe121f28889c80c47899f49">CTR_MX_01</a> = 0x00400000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa7d426fae269a3e39a06f0850edccaac6">CTR_MX_INT</a> = 0x00800000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa709798502a1e5a80fb7f1125960005d3">CTR_GEN</a> = 0x00800000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faae089e9d7fd1b8477aabfd2fe998d668b">CTR_NOT_INV</a> = 0x01000000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faae82bbd707aa61770ac144fd4a66fd617">CTR_BRANCHING_INV</a> = 0x02000000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faaa19ce6f174c3e604c53691da1cf96306">CTR_WITH_DEP_BINS</a> = 0x04000000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa480931fb76d027def1865726a54c90bf">CTR_IN_POOL</a> = 0x08000000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faae91595a30db12719b37362eae12229fb">CTR_LB_UNBOUNDED</a> = 0x10000000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faaccbede0c0280c6776777b5703e3f63f2">CTR_UB_UNBOUNDED</a> = 0x20000000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa2f5b437914f56a60c96e5a343dc3d68e">CTR_OBJ</a> = 0x40000000, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faad1a0c96a86d30fcfe854d689674c1237">CTR_BINARY</a> = CTR_BINPACK | CTR_KNAPSACK | CTR_INV_KNAPSACK | CTR_PACKING | CTR_COVERING | CTR_CARDINALITY, 
<b>CTR_WITH_INT_VARS</b> = CTR_INT_VARS | CTR_MX_01 | CTR_MX_INT | CTR_MX_KNAPSACK, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa6d9c88d15e4ad3471db9ba20646ff6b1">CTR_MIR</a> = CTR_MX_INT|CTR_MX_01|CTR_MX_KNAPSACK|CTR_WITH_VAR_BOUNDS|CTR_01FLOW|CTR_KNAPSACK|CTR_BINPACK, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa1994a0fd29ad8b3a3e8c49c30062365f">CTR_FULLY_CLASSIFIED</a> = CTR_VAR|CTR_BINPACK|CTR_KNAPSACK |CTR_INV_KNAPSACK|CTR_PACKING|CTR_COVERING|CTR_PARITY|CTR_SOS1|CTR_SOS2, 
<a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa4d2981c59898d32ea96b50bc3023366f">CTR_CLASSIFIED</a> = CTR_MIR|CTR_01FLOW|CTR_INT|CTR_VAR|CTR_INV_KNAPSACK |CTR_PACKING|CTR_COVERING|CTR_CARDINALITY|CTR_PARITY|CTR_BINPACK|CTR_BRANCHING_INV|CTR_WITH_DEP_BINS|CTR_NOT_INV
<br />
 }</td></tr>
<tr class="memdesc:af376f7257f718501639a17f9ac0e44fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIP types of constraints.  <a href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa">More...</a><br /></td></tr>
<tr class="separator:af376f7257f718501639a17f9ac0e44fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cd164e97628571f7d774472a1e2c92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92">enVarType</a> { <br />
&#160;&#160;<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92ab5dfcb211c4819d366c25dd0e4a56a65">VAR_BIN</a> = 0x00002000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a518e7a36ebcf2977d775b4696ffec8f8">VAR_4_INT</a> = 0x00004000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a4621f50af165f42bf8ce3aad39f04aed">VAR_8_INT</a> = 0x00008000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a667ce0c9c3579f13c5b1ca8659c6250c">VAR_IN_VAR_LB</a> = 0x00010000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a631f6ad805812377ed0c49193c493fd6">VAR_0_IN_VAR_CTR</a> = VAR_IN_VAR_LB, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a6ea3f4544166057b2e776633c441e1b4">VAR_IN_VAR_UB</a> = 0x00020000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a4994cf072954654a80da9e6f4ef55ed2">VAR_1_IN_VAR_CTR</a> = VAR_IN_VAR_UB, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92af3004f227d58b7c1ed029881d4b25d97">VAR_IN_VAR_CTR</a> = VAR_IN_VAR_UB | VAR_IN_VAR_LB, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92af7d2048da43730b29b5abf90af662181">VAR_IN_GUB</a> = 0x00040000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a7b87472eea419a78ae0fb1d58b186728">VAR_IN_PACKING</a> = 0x00080000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92ae0703d97b963923b264a2f044a04d24c">VAR_UNIQUE</a> = 0x00100000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92acbf05c12f2c4bb9e531c4f4d0d99a859">VAR_MON_UP</a> = 0x00200000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a37032a742081244d6d881cad9c2ac2f5">VAR_MON_DOWN</a> = 0x00400000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92af35bd0e227833cc438b46b4d7a62888c">VAR_MONOTONE</a> = VAR_MON_UP | VAR_MON_DOWN, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a925000c8908ddf99423d5a344493ca77">VAR_BINPACK</a> = 0x00000000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a072e81fe33895815cea2c62254e34ef5">VAR_IN_POOL</a> = 0x00800000, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a5dbd6dab1a084bd055f9d6ff0495f465">VAR_SOS</a> = 0x08000000, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92aec67bac21d7e1b3cb3640fe9cb260b9b">VAR_CLASSIFIED</a> = VAR_IN_VAR_CTR|VAR_IN_PACKING|VAR_IN_GUB|VAR_MONOTONE|VAR_UNIQUE|VAR_IN_POOL|VAR_BINPACK, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a9738e26aaaa83e9b549867c5a3b29ed0">VAR_PRI_MIN</a> = -50, 
<a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92a16c559a2b894103d6e267e9f25bf7d1c">VAR_PRI_MAX</a> = 50
<br />
 }</td></tr>
<tr class="memdesc:a70cd164e97628571f7d774472a1e2c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIP types of variables.  <a href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92">More...</a><br /></td></tr>
<tr class="separator:a70cd164e97628571f7d774472a1e2c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b975320472b5fb8fbdd4269387012e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012e">enBranchRule</a> { <a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012ea88b647fd0ac9c572310d382c48f12e9d">STRONG_BR</a>, 
<a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012ea8d5340d688c46d8433f563f3e27c6e2f">MAX_SCORE</a>
 }</td></tr>
<tr class="memdesc:ae5b975320472b5fb8fbdd4269387012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branching rules.  <a href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012e">More...</a><br /></td></tr>
<tr class="separator:ae5b975320472b5fb8fbdd4269387012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2394ed0f7beb2a12444f132a7eab2572"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">enRoundType</a> { <br />
&#160;&#160;<a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572a59b58433a95682c6a846b0097f4f2e50">ROUND_NONE</a>, 
<a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572aa822662f72823e61cd6e0801fc5a819b">ROUND_OFF</a>, 
<a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572a975785e0d00b7cf5ea4de85c27bcc8db">ROUND_DOWN</a>, 
<a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572aefb1ffd5caf6a30247b0bd1af4af8ff8">ROUND_UP</a>, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572a52f5b7c1ac584c52f3360b7423fd1286">ROUND_USER</a>
<br />
 }</td></tr>
<tr class="memdesc:a2394ed0f7beb2a12444f132a7eab2572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounding rules.  <a href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">More...</a><br /></td></tr>
<tr class="separator:a2394ed0f7beb2a12444f132a7eab2572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811eee6c5be7e08f960b81b915903f51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> { <br />
&#160;&#160;<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a99737be7316cf6a64792502118a5db49">CUT_TYPE_NUM</a> =13, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51abaded67558f828ac94b136f333c857b6">_CLICK</a> =0, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51adcb2fb5aaf88f239cabff4a16025e222">_KNAPSACK</a> =1, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a35d5989046e08d403e2bdd6ee1ba2c60">_MX_KNAPSACK</a> =2, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51abb52ac6410dfa6d09091679cf36a99e8">_MIR</a> =3, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a4e6e15f790aa2fead31d18d3061d2121">_FLOW_COVER</a> =4, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a96de701f910454927407881df4e4bae6">_SPARSE_MOD2</a> =5, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51ac258411021659473e3f6ee340cef1fb1">_DENSE_MOD2</a> =6, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51af1d8f5b9b895b0400a9502c1fcdb14cc">_SPARSE_GOMORY</a> =7, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51acc1bd08d03c2f45089e7045eca97d2c2">_DENSE_GOMORY</a> =8, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a23d4152710b226279f0178a6ebdbb08b">_PARITY</a> =9, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51ac253ae251b45243b4f836a86189be248">_VAR_BOUND</a> =10, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51ab04954a20b550af33565ed3b7c3f84de">_SIMPLE_DJ</a> =11, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a6e3169701a722108fe0e1603c097b7be">_USER_DEF</a> =12, 
<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51a2f7a5fe95afea24d320bd88f5de6acaa">CUTS_TO_POOL</a> = 0
<br />
 }</td></tr>
<tr class="memdesc:a811eee6c5be7e08f960b81b915903f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cut types.  <a href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">More...</a><br /></td></tr>
<tr class="separator:a811eee6c5be7e08f960b81b915903f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab867a6a47fb83f4d984b7f3442364044"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044">enRowColGenRule2</a> { <br />
&#160;&#160;<a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044a70b92ce675e1f9b4d2e55ba4e5c0416e">GEN1_PROC</a> = 0x8, 
<a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044ab87f3cee60cb9285159a78beaff3b89e">GEN2_PROC</a> = 0x10, 
<a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044a32eb18230d33f54ebd8a3682d8233f0e">STOP_AUTO_CUTS</a> = 0x20, 
<a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044aede6ed455518715ffa44fdb00f5aed53">WITH_AUTO_CUTS</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044a0d4d867e7b3edbecaa7d60f0266d9bdb">NO_SOLVER_DECISIONS</a> = 0x80
<br />
 }</td></tr>
<tr class="memdesc:ab867a6a47fb83f4d984b7f3442364044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of <code>enRowColGenRule</code>.  <a href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044">More...</a><br /></td></tr>
<tr class="separator:ab867a6a47fb83f4d984b7f3442364044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCLP')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:ace10a11a6c69fa8274ad8bc2c0930adb inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">enAlign</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba34241e0294a551922cb9654241c0264e">ALIGN_NONE</a> = 0x00000000, 
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba5b32d4c1a0a5ac7c241c11a6163c91e3">ALIGN_COLUMN_APPR</a> = 0x00000001, 
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba7120d50531f63f160b00ee40e0890dee">ALIGN_COLUMN</a> = 0x00000011, 
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adbabaed747e2cb0b5a487629baf13187eff">ALIGN_ROW_APPR</a> = 0x00000100, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba11b7111fe3445164fabe75cf968797b7">ALIGN_ROW</a> = 0x00001100
<br />
 }</td></tr>
<tr class="memdesc:ace10a11a6c69fa8274ad8bc2c0930adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix alignment.  <a href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">More...</a><br /></td></tr>
<tr class="separator:ace10a11a6c69fa8274ad8bc2c0930adb inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac886bb1c9454ba327bc52b46b72f7ac5 inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5">enCtrType</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a17870c44aecd572149dda0acb4e4a4e1">CTR_ATTACHED</a> = 0x00000001, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a4ee63b4bd702d2ace98cbed25c6cbad3">CTR_LEFT</a> = 0x00000002, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a71ef23a0ef46d3a746342572433e4005">CTR_RIGHT</a> = 0x00000004, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a7cc6aa09c75f6c23bd366a2db73be4d3">CTR_EQ</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a8590663fa4e694651fdb18d53692f8b0">CTR_REF</a> = 0x00000010, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a7baf38b91fd84aef5a2a1427a29d85e1">CTR_NOT_STABLE</a> = 0x00000020, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5aa8a12a75b7a358499e47f39d2f95a09e">CTR_STRONG_CUT</a> = 0x80000000
<br />
 }</td></tr>
<tr class="memdesc:ac886bb1c9454ba327bc52b46b72f7ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP types of constraints.  <a href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5">More...</a><br /></td></tr>
<tr class="separator:ac886bb1c9454ba327bc52b46b72f7ac5 inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89292c62c83b834a8b451bde23c67627 inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627">enVarType</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a5d331e9cfab0f7598da11cd0ea9ebc03">VAR_LEFT</a> = 0x10000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627ad51df68c924dac7c246f9c30cc587b2e">VAR_RIGHT</a> = 0x20000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627ab75d53368c617fc8c888e93c0d03d491">VAR_FX</a> = 0x40000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a9df0f737a50b3d4bd2072c3c15b468fb">VAR_REF</a> = 0x80000000, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a0600f7f3589a4726507c1ea72fd81cdc">VAR_NOT_MOD</a> = 0x04000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a2f778e20d4c99ef9739681b2bc811b0d">VAR_INT</a> = 0x00001000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a4c836f1a6ffec0f890beb0768c6e3cdd">VAR_BIN</a> = 0x00002000
<br />
 }</td></tr>
<tr class="memdesc:a89292c62c83b834a8b451bde23c67627"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP types of variables.  <a href="classCLP.html#a89292c62c83b834a8b451bde23c67627">More...</a><br /></td></tr>
<tr class="separator:a89292c62c83b834a8b451bde23c67627 inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69612f747174f3c3e3a19f17cc290877 inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">enScaling</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a9532f46e77b8de78728d81810061351b">SCL_MINMAX</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a2b3dcc735540c010ca52f111da1c3dc3">SCL_IDEAL</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a631c5045eeaeb601216f6656771dbbce">SCL_NO</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ada2e041936a7a640550da4030530efdc">SCL_GM_ROWS</a>, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a3cfbdf746ead117eef50c65af47ee2b7">SCL_GM_COLUMNS</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac0fb16c8f4cdc516084e20388b16b3a8">SCL_MAX_ROWS</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a787bfbff974c356dd7176911fbb4b75e">SCL_MAX_COLUMNS</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a> =127, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a745b552b1fe7fdce8d141b0e2871dfd7">SCL_MIN_EXP</a> =-19
<br />
 }</td></tr>
<tr class="memdesc:a69612f747174f3c3e3a19f17cc290877"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the list of all possible ways to scale matrix.  <a href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">More...</a><br /></td></tr>
<tr class="separator:a69612f747174f3c3e3a19f17cc290877 inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7aedeedf26a9bcab5d5e32c528131e inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a> { <a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131ea697958327067d98ba307d62f67481c0e">AUTO_DETECT</a>, 
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131ea35f36965643458a225f51afbb5397d7a">PRIME_SIMPLEX</a>, 
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131eaeed16c0d496a65145f7141620c5672d0">DUAL_SIMPLEX</a>
 }</td></tr>
<tr class="memdesc:a2a7aedeedf26a9bcab5d5e32c528131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP methods.  <a href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">More...</a><br /></td></tr>
<tr class="separator:a2a7aedeedf26a9bcab5d5e32c528131e inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7826c555555d1888a96efa8572f584 inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a> { <a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584a3d90bed8af607e02248519ef975a5fd2">SEP_MOST_VIOLATED</a>, 
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584aca8dfbedb02a31e924028a8654748398">SEP_ONLY_EQUATIONS</a>, 
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584a93f0269d58431e5756c7f60d41e04cf9">SEP_STEEPEST_EDGE</a>
 }</td></tr>
<tr class="memdesc:abd7826c555555d1888a96efa8572f584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separation rules.  <a href="classCLP.html#abd7826c555555d1888a96efa8572f584">More...</a><br /></td></tr>
<tr class="separator:abd7826c555555d1888a96efa8572f584 inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c02821b739c221b8e3672a46bc4ea5 inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a> { <a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5ae48c44231bbfa3ac7fe3fe5da097ff07">PRC_MOST_NEGATIVE</a>, 
<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5aa4e9e8e12c37d6c438d381a83548a716">PRC_STEEPEST_EDGE</a>
 }</td></tr>
<tr class="memdesc:ad5c02821b739c221b8e3672a46bc4ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pricing rules.  <a href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">More...</a><br /></td></tr>
<tr class="separator:ad5c02821b739c221b8e3672a46bc4ea5 inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e51337d2a33971e7a2264f67ca2da7c inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7c">enProbState</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca300af909e7e8cc4050337ef393e3b621">PROB_IN_MEMORY</a> = 0x00000001, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca4260338e83d735350ac2666fd3f6961c">PROB_PREPARED</a> = 0x00000002, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7cadb019ad240e07281feac40268900ed8c">PROB_SOLVED</a> = 0x00000004, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca8a28cfac879be4fe1d8b1a8a730c31db">PROB_SOLUTION</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca765cf6c45c6287f4455c63caa5fcf124">PROB_OPTIMAL</a> = 0x00000010, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca753e10e160501d94a4d8323eca7bd122">PROB_INFEASIBLE</a> = 0x00000020, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca344a364e11ae7dac9083dfdf55350730">PROB_UNBOUNDED</a> = 0x00000040, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca66f16d92983df6d6c7ab69d86cad91dc">PROB_TIME_LIMIT</a> = 0x00000080, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca3b27f003075cc320ebfd74e650faf954">PROB_IT_LIMIT</a> = 0x00000100, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7cab13b9d0a37f3789e994cf1f80a37b313">PROB_GAP_LIMIT</a> = 0x00000200, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca0e5044d101dabb9568bb3e9daa858a88">PROB_SOLVER_FLAGS</a> = PROB_SOLVED|PROB_SOLUTION|PROB_OPTIMAL|PROB_INFEASIBLE|PROB_UNBOUNDED|PROB_TIME_LIMIT|PROB_GAP_LIMIT
<br />
 }</td></tr>
<tr class="memdesc:a5e51337d2a33971e7a2264f67ca2da7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem states.  <a href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7c">More...</a><br /></td></tr>
<tr class="separator:a5e51337d2a33971e7a2264f67ca2da7c inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8a9c8d5a775156d30aecba3bf74511 inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511">enRowColGenRule1</a> { <a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511ac4fc40898634e36cad90e2bcd27f99fa">ROW_GEN</a> = 0x1, 
<a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511aacfac1c0a7476a3f064a96e49be704e5">COL_GEN</a> = 0x2, 
<a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511a004c24655361633c62bdf2ac91754b21">SEP_PROC</a> = 0x4
 }</td></tr>
<tr class="separator:add8a9c8d5a775156d30aecba3bf74511 inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbd20f2d40a5aec4e06474a7bef2b2d inherit pub_types_classCLP"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a></td></tr>
<tr class="memdesc:accbd20f2d40a5aec4e06474a7bef2b2d inherit pub_types_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">program type for handles of variables and constraints  <a href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">More...</a><br /></td></tr>
<tr class="separator:accbd20f2d40a5aec4e06474a7bef2b2d inherit pub_types_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b26ee9f905292075e66031728bffca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a1b26ee9f905292075e66031728bffca3">setThreadNum</a> (int threadNum)</td></tr>
<tr class="separator:a1b26ee9f905292075e66031728bffca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b10d75afbbfba3a87c0b4506207fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a61b10d75afbbfba3a87c0b4506207fce">skipSymmetrySearch</a> ()</td></tr>
<tr class="separator:a61b10d75afbbfba3a87c0b4506207fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fe024329716cf3bdfbb5f66cb852b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af3fe024329716cf3bdfbb5f66cb852b9">setNodeSepRule</a> (<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a> sepRule)</td></tr>
<tr class="separator:af3fe024329716cf3bdfbb5f66cb852b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672b53dd171f20e86eec46ee4afff48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af672b53dd171f20e86eec46ee4afff48">setNodePricingRule</a> (<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a> pricingRule)</td></tr>
<tr class="separator:af672b53dd171f20e86eec46ee4afff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5825362f7121939d1dd3060e50198706"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a5825362f7121939d1dd3060e50198706">isPureLP</a> () const final</td></tr>
<tr class="separator:a5825362f7121939d1dd3060e50198706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063157583e0246322c62cb5fbd0d0cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a063157583e0246322c62cb5fbd0d0cee">setPoolCutTol</a> (double tol)</td></tr>
<tr class="separator:a063157583e0246322c62cb5fbd0d0cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf01e2b4af3a8452700f34228bf227b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a7cf01e2b4af3a8452700f34228bf227b">setCtrCutTol</a> (double tol)</td></tr>
<tr class="separator:a7cf01e2b4af3a8452700f34228bf227b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d43cf4b29aad6073839da5acad5d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a74d43cf4b29aad6073839da5acad5d3e">setCtrTol</a> (double ctrTol) final</td></tr>
<tr class="separator:a74d43cf4b29aad6073839da5acad5d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bf1030fd521268ac03695aeb83bfdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad3bf1030fd521268ac03695aeb83bfdd">isCtrGlobal</a> (int i) const</td></tr>
<tr class="separator:ad3bf1030fd521268ac03695aeb83bfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63b4079041f615a75bfcb43ad9e674a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab63b4079041f615a75bfcb43ad9e674a">getIntegerVarNum</a> () const</td></tr>
<tr class="separator:ab63b4079041f615a75bfcb43ad9e674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b4cd994beec8cb31d82a70d2018c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a202b4cd994beec8cb31d82a70d2018c4">getBinaryVarNum</a> () const</td></tr>
<tr class="separator:a202b4cd994beec8cb31d82a70d2018c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67130ed26ea4f8fef22909e1d0d6013e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a67130ed26ea4f8fef22909e1d0d6013e">getRealVarNum</a> () const</td></tr>
<tr class="separator:a67130ed26ea4f8fef22909e1d0d6013e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a67bed916bee0574d519110c1456120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a5a67bed916bee0574d519110c1456120">getProbingDepth</a> () const</td></tr>
<tr class="separator:a5a67bed916bee0574d519110c1456120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad175289865b9117fc7505c6d4e5fa28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad175289865b9117fc7505c6d4e5fa28d">setProbingDepth</a> (int depth)</td></tr>
<tr class="separator:ad175289865b9117fc7505c6d4e5fa28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521debeb6b0b75a3520f289cd049d9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a521debeb6b0b75a3520f289cd049d9e2">setVarPriority</a> (int j, int pr)</td></tr>
<tr class="separator:a521debeb6b0b75a3520f289cd049d9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9297389c022da8127e141b52fe8b4a4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a9297389c022da8127e141b52fe8b4a4c">incVarPriority</a> (int j, int inc)</td></tr>
<tr class="separator:a9297389c022da8127e141b52fe8b4a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49eced2ef53c891ef679c0432d0f79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a1b49eced2ef53c891ef679c0432d0f79">getVarPriority</a> (int j) const</td></tr>
<tr class="separator:a1b49eced2ef53c891ef679c0432d0f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f725a78d773cf02ced8e67a10ec67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ac2f725a78d773cf02ced8e67a10ec67f">setAbsObjTol</a> (double tol)</td></tr>
<tr class="separator:ac2f725a78d773cf02ced8e67a10ec67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e107e66010b65ac0736cb5aa59bcca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aa3e107e66010b65ac0736cb5aa59bcca">getAbsObjTol</a> () const</td></tr>
<tr class="separator:aa3e107e66010b65ac0736cb5aa59bcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d43af3654fd597ed45fbebd6ddf6d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a93d43af3654fd597ed45fbebd6ddf6d8">openMatrix</a> (int m, int n, int nz, bool bRowGen=true, bool bColGen=false, int mMax=0, int nMax=0, int nzMax=0) final</td></tr>
<tr class="separator:a93d43af3654fd597ed45fbebd6ddf6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a190e3a9fea5b1ee960edf73d9fa66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ac5a190e3a9fea5b1ee960edf73d9fa66">closeMatrix</a> () final</td></tr>
<tr class="separator:ac5a190e3a9fea5b1ee960edf73d9fa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7398f71012d27f00d10db22b6b458b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a3c7398f71012d27f00d10db22b6b458b">addCut</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double b1, double b2, int sz, double *dpVal, int *ipCol, bool bVarScaled=true, int factor=<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a>, int n=0)</td></tr>
<tr class="separator:a3c7398f71012d27f00d10db22b6b458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657eca92c7b8409105bf501334121d05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a657eca92c7b8409105bf501334121d05">safeAddCut</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double b1, double b2, int sz, double *&amp;dpVal, int *&amp;ipCol, bool bVarScaled=true, int factor=<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a>, int n=0)</td></tr>
<tr class="separator:a657eca92c7b8409105bf501334121d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565b27e1966ceb19380a4d3d7bcec5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a0565b27e1966ceb19380a4d3d7bcec5a">CMIP</a> (const char *name)</td></tr>
<tr class="separator:a0565b27e1966ceb19380a4d3d7bcec5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30befe3b11b8199abae19c7d9824d85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aa30befe3b11b8199abae19c7d9824d85">CMIP</a> (const <a class="el" href="classCMIP.html">CMIP</a> &amp;other, int thread)</td></tr>
<tr class="memdesc:aa30befe3b11b8199abae19c7d9824d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone constructor.  <a href="#aa30befe3b11b8199abae19c7d9824d85">More...</a><br /></td></tr>
<tr class="separator:aa30befe3b11b8199abae19c7d9824d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee7eae41647ea02e7c633b44b1c6256"><td class="memItemLeft" align="right" valign="top"><a id="acee7eae41647ea02e7c633b44b1c6256"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#acee7eae41647ea02e7c633b44b1c6256">~CMIP</a> ()</td></tr>
<tr class="memdesc:acee7eae41647ea02e7c633b44b1c6256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br /></td></tr>
<tr class="separator:acee7eae41647ea02e7c633b44b1c6256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af7a8fc2a88d4194ef5410c5f980e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a3af7a8fc2a88d4194ef5410c5f980e12">doNotUsePool</a> ()</td></tr>
<tr class="separator:a3af7a8fc2a88d4194ef5410c5f980e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fbbc89c2f826b79800e949979013bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a20fbbc89c2f826b79800e949979013bc">getObjLowerBound</a> () const</td></tr>
<tr class="separator:a20fbbc89c2f826b79800e949979013bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c902f2a8553bd70f0465b9e3141005e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a1c902f2a8553bd70f0465b9e3141005e">safeGetObjLowerBound</a> ()</td></tr>
<tr class="separator:a1c902f2a8553bd70f0465b9e3141005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7242040205f7dfa8bf29b7d7f1acb1f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a7242040205f7dfa8bf29b7d7f1acb1f8">getObjVal</a> () const</td></tr>
<tr class="separator:a7242040205f7dfa8bf29b7d7f1acb1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c57da801f3b302738c905583db3de67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a0c57da801f3b302738c905583db3de67">getSolNum</a> () const</td></tr>
<tr class="separator:a0c57da801f3b302738c905583db3de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5988aab7a8267c5735a51b3bc902cc95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a5988aab7a8267c5735a51b3bc902cc95">safeGetSolNum</a> ()</td></tr>
<tr class="separator:a5988aab7a8267c5735a51b3bc902cc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059ecd9b515d788e4f3c48a791caa6b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a059ecd9b515d788e4f3c48a791caa6b0">getCurrentNode</a> () const</td></tr>
<tr class="separator:a059ecd9b515d788e4f3c48a791caa6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3544f1e816f2ebf936ab4e902d028465"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a3544f1e816f2ebf936ab4e902d028465">getCurrentNodeHeight</a> () const</td></tr>
<tr class="separator:a3544f1e816f2ebf936ab4e902d028465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7edb32b7ba21e11aad07e4757703a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a4e7edb32b7ba21e11aad07e4757703a1">setIntTol</a> (double intTol)</td></tr>
<tr class="separator:a4e7edb32b7ba21e11aad07e4757703a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089696de273ee17ef5a6097d29266d3c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a089696de273ee17ef5a6097d29266d3c">getIntTol</a> () const</td></tr>
<tr class="separator:a089696de273ee17ef5a6097d29266d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a1572e10422013f655348ef8dbeb9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ac6a1572e10422013f655348ef8dbeb9d">setBranchingRule</a> (<a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012e">enBranchRule</a> rule)</td></tr>
<tr class="separator:ac6a1572e10422013f655348ef8dbeb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b241b19aabf10c7ceacb29e14c8dfec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a8b241b19aabf10c7ceacb29e14c8dfec">setAutoCutPattern</a> (int nodeNum, int height)</td></tr>
<tr class="separator:a8b241b19aabf10c7ceacb29e14c8dfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1fbef433174ee6e7591c5be4979359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a4d1fbef433174ee6e7591c5be4979359">setMaxCutSize</a> (int sizeAtRoot, int sizeAtNodes)</td></tr>
<tr class="separator:a4d1fbef433174ee6e7591c5be4979359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c3e1b3638bb6b2f5530695fced2204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a15c3e1b3638bb6b2f5530695fced2204">setCutTypePattern</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType, int nodeNum, int height)</td></tr>
<tr class="separator:a15c3e1b3638bb6b2f5530695fced2204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5ca136bb8c1026feaab06b084a7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af2c5ca136bb8c1026feaab06b084a7f6">setAutoCutRounds</a> (int atRoot, int atNodes)</td></tr>
<tr class="separator:af2c5ca136bb8c1026feaab06b084a7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82bd5785a5ec7076215195671612de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ae82bd5785a5ec7076215195671612de1">setMaxCutSize</a> (int size)</td></tr>
<tr class="separator:ae82bd5785a5ec7076215195671612de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3582cea3c5dcaa29339562496c1b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aaa3582cea3c5dcaa29339562496c1b39">setRelObjDecPerCutRoundAtRoot</a> (double prc)</td></tr>
<tr class="separator:aaa3582cea3c5dcaa29339562496c1b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb24a09d08c67dd3c13e70d9e3014fe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#acbb24a09d08c67dd3c13e70d9e3014fe">getRelObjDecPerCutRoundAtRoot</a> () const</td></tr>
<tr class="separator:acbb24a09d08c67dd3c13e70d9e3014fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0820008f5502c3d44ff063c3cfd02d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a5d0820008f5502c3d44ff063c3cfd02d">setRelObjDecPerCutRoundAtNodes</a> (double prc)</td></tr>
<tr class="separator:a5d0820008f5502c3d44ff063c3cfd02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c8fcbb2b4a9bda5de72679ced4cf4f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a74c8fcbb2b4a9bda5de72679ced4cf4f">getRelObjDecPerCutRoundAtNodes</a> () const</td></tr>
<tr class="separator:a74c8fcbb2b4a9bda5de72679ced4cf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a23431b4ea125ffacd5dec82593a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a79a23431b4ea125ffacd5dec82593a30">setMinCutRounds</a> (int atRoot, int atNodes)</td></tr>
<tr class="separator:a79a23431b4ea125ffacd5dec82593a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a33b857f07b76fde8c2f6c107671a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aee3a33b857f07b76fde8c2f6c107671a">setMaxCutRoundNum</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType, int roundNum)</td></tr>
<tr class="separator:aee3a33b857f07b76fde8c2f6c107671a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81c837355b4aeeed7b71425a86a1f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad81c837355b4aeeed7b71425a86a1f4c">setMaxCutSize</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType, int size)</td></tr>
<tr class="separator:ad81c837355b4aeeed7b71425a86a1f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084044b520ec47ae6631728cf7bdead3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a084044b520ec47ae6631728cf7bdead3">setMaxCutsPerRound</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType, int cutNum)</td></tr>
<tr class="separator:a084044b520ec47ae6631728cf7bdead3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa179f37b0953fd296869589ec9497fcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aa179f37b0953fd296869589ec9497fcb">setToleranceForCut</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType, double tol)</td></tr>
<tr class="separator:aa179f37b0953fd296869589ec9497fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64877ecd5bddd9146d300fc015df4c44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a64877ecd5bddd9146d300fc015df4c44">getToleranceForCut</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType) const</td></tr>
<tr class="separator:a64877ecd5bddd9146d300fc015df4c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f2bd9ff7223e25affc96cb5a71bd55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a55f2bd9ff7223e25affc96cb5a71bd55">sendCutsToPool</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType)</td></tr>
<tr class="separator:a55f2bd9ff7223e25affc96cb5a71bd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1604c7b6dbaf45be61c6b35c40099241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a1604c7b6dbaf45be61c6b35c40099241">areCutsSentToPool</a> (<a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a> cutType) const</td></tr>
<tr class="separator:a1604c7b6dbaf45be61c6b35c40099241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24af606d30c50453c6d57201a4e11259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a24af606d30c50453c6d57201a4e11259">setMod2CutDensity</a> (int sparsePrc, int densePrc)</td></tr>
<tr class="separator:a24af606d30c50453c6d57201a4e11259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff45e2bff01ee9845669f94df2539f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#acff45e2bff01ee9845669f94df2539f3">setGomoryCutDensity</a> (int sparsePrc, int densePrc)</td></tr>
<tr class="separator:acff45e2bff01ee9845669f94df2539f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12182abf970a184aeb1dba3658f619c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a12182abf970a184aeb1dba3658f619c4">prepare</a> () final</td></tr>
<tr class="separator:a12182abf970a184aeb1dba3658f619c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3a97823fbb2c93ac23647f649485b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a2c3a97823fbb2c93ac23647f649485b6">reset</a> () final</td></tr>
<tr class="separator:a2c3a97823fbb2c93ac23647f649485b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16bad8fb24b4beb74a0499c96f6dfd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ac16bad8fb24b4beb74a0499c96f6dfd0">BranchAndCut</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeLimit=0l, double gap=0.0)</td></tr>
<tr class="separator:ac16bad8fb24b4beb74a0499c96f6dfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68f591f9fb72ea0dfe2e7964c8265da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">optimize</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeLimit=0l, double gap=0.0, const char *solFileName=0) final</td></tr>
<tr class="separator:af68f591f9fb72ea0dfe2e7964c8265da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ace1560abb8de5c9b7941720df9b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a536ace1560abb8de5c9b7941720df9b4">getSolution</a> (double *&amp;dpX, int *&amp;ipHd)</td></tr>
<tr class="separator:a536ace1560abb8de5c9b7941720df9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a188db14fbd2a57e18729cd7376a89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a79a188db14fbd2a57e18729cd7376a89">isSolution</a> () const final</td></tr>
<tr class="separator:a79a188db14fbd2a57e18729cd7376a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf58cfeaa80ef422892f96b6cc298fdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aaf58cfeaa80ef422892f96b6cc298fdc">isSolutionOptimal</a> () const</td></tr>
<tr class="separator:aaf58cfeaa80ef422892f96b6cc298fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5502b6ddd5a187bc086504b16dadef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ace5502b6ddd5a187bc086504b16dadef">timeLimitStop</a> () const</td></tr>
<tr class="separator:ace5502b6ddd5a187bc086504b16dadef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8baddc2199be1f6af77ecd291c9f659"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab8baddc2199be1f6af77ecd291c9f659">getObjBound</a> () const</td></tr>
<tr class="separator:ab8baddc2199be1f6af77ecd291c9f659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91249febf036dd979f7584bc0962137a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a91249febf036dd979f7584bc0962137a">printSolution</a> (const char *fileName=0) override</td></tr>
<tr class="separator:a91249febf036dd979f7584bc0962137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1a5a7c0984a3417c60c75a33d721c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a4a1a5a7c0984a3417c60c75a33d721c9">setRoundingType</a> (<a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">enRoundType</a> dir)</td></tr>
<tr class="separator:a4a1a5a7c0984a3417c60c75a33d721c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada95006ce13736b0bf0b78ce263c2d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">enRoundType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ada95006ce13736b0bf0b78ce263c2d22">getRoundingType</a> () const</td></tr>
<tr class="separator:ada95006ce13736b0bf0b78ce263c2d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab756898acb767ab51422d24daf075b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab756898acb767ab51422d24daf075b96">changeObjBound</a> (double objVal)</td></tr>
<tr class="separator:ab756898acb767ab51422d24daf075b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911ab2e8695ccca2a10d6492df428d7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">changeRecord</a> (double objVal, int n, const double *dpX, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipHd)</td></tr>
<tr class="separator:a911ab2e8695ccca2a10d6492df428d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecbfd2806b0ec9708e85e22e2649151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a8ecbfd2806b0ec9708e85e22e2649151">setDualGap</a> (double gap)</td></tr>
<tr class="separator:a8ecbfd2806b0ec9708e85e22e2649151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57d0fb961fca0ec6dcce68e1af252c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aa57d0fb961fca0ec6dcce68e1af252c3">getBranchAndCutNodeNumber</a> ()</td></tr>
<tr class="separator:aa57d0fb961fca0ec6dcce68e1af252c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3437dbda7b181fa9d01c5ec1a98baeb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a3437dbda7b181fa9d01c5ec1a98baeb3">getNoOfActiveNodes</a> () const</td></tr>
<tr class="separator:a3437dbda7b181fa9d01c5ec1a98baeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01416188eb89d46c26d0fce099797ff6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a01416188eb89d46c26d0fce099797ff6">getUpperBound</a> () const</td></tr>
<tr class="separator:a01416188eb89d46c26d0fce099797ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22e737dc1e04a82d66e2a62ad9a590"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a3a22e737dc1e04a82d66e2a62ad9a590">mipCutInfoMsg</a> ()</td></tr>
<tr class="separator:a3a22e737dc1e04a82d66e2a62ad9a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72640275265c14c6984439cff9b4504e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a72640275265c14c6984439cff9b4504e">mipTreeInfoMsg</a> ()</td></tr>
<tr class="separator:a72640275265c14c6984439cff9b4504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d462ff8a25ec8eb97bbea6409510aaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a4d462ff8a25ec8eb97bbea6409510aaa">switchMipInfoMsg</a> (bool <a class="el" href="classCMIP.html#ac50aeee183a24470294ec4b32e8a079f">cutInfo</a>, bool treeInfo)</td></tr>
<tr class="separator:a4d462ff8a25ec8eb97bbea6409510aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCLP')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:ae15b567a7fcdf060320225b107e5a7c2 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae15b567a7fcdf060320225b107e5a7c2">getStartTime</a> () const</td></tr>
<tr class="separator:ae15b567a7fcdf060320225b107e5a7c2 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c239f18033b08ccc18a711d953765b inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a96c239f18033b08ccc18a711d953765b">getSolTime</a> () const</td></tr>
<tr class="separator:a96c239f18033b08ccc18a711d953765b inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb64ae5e18034796c87fd473f889a5fd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adb64ae5e18034796c87fd473f889a5fd">isCLP</a> ()</td></tr>
<tr class="separator:adb64ae5e18034796c87fd473f889a5fd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0040e9c15a3ed866edc35a5b1cd6896b inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0040e9c15a3ed866edc35a5b1cd6896b">openLogStream</a> (const char *name=0)</td></tr>
<tr class="separator:a0040e9c15a3ed866edc35a5b1cd6896b inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58522cc43d5bc30264c9fed54e3f8a4 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad58522cc43d5bc30264c9fed54e3f8a4">setVarInf</a> (double inf)</td></tr>
<tr class="separator:ad58522cc43d5bc30264c9fed54e3f8a4 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfd0f57b4fea770d264857d149c2c51 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3bfd0f57b4fea770d264857d149c2c51">getVarInf</a> () const</td></tr>
<tr class="separator:a3bfd0f57b4fea770d264857d149c2c51 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3fdda6619175bb60893ed01f97648d inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7a3fdda6619175bb60893ed01f97648d">writeStrToLogStream</a> (const char *str)</td></tr>
<tr class="separator:a7a3fdda6619175bb60893ed01f97648d inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9cc1618db03af0e431b1404b392af6 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5d9cc1618db03af0e431b1404b392af6">setProblemName</a> (const char *name)</td></tr>
<tr class="separator:a5d9cc1618db03af0e431b1404b392af6 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca5b92a36189f315f43067727cf510a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7ca5b92a36189f315f43067727cf510a">getProblemName</a> (char *name) const</td></tr>
<tr class="separator:a7ca5b92a36189f315f43067727cf510a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c00ecaf1e40dc3077988b1a75190e2c inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1c00ecaf1e40dc3077988b1a75190e2c">setZero</a> (double zero)</td></tr>
<tr class="separator:a1c00ecaf1e40dc3077988b1a75190e2c inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993a49b26e7fcda789a74d055b2d9d7 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4993a49b26e7fcda789a74d055b2d9d7">getZero</a> () const</td></tr>
<tr class="separator:a4993a49b26e7fcda789a74d055b2d9d7 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378a97cf0e8477e6f81c2ea40b760897 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol</a> (double tolPiv, double relTolPiv, double goodPiv, double tolPivErr, double relTolPivErr)</td></tr>
<tr class="separator:a378a97cf0e8477e6f81c2ea40b760897 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac816fe1f356205b0fef57c3cdb500ca0 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac816fe1f356205b0fef57c3cdb500ca0">getPivTol</a> () const</td></tr>
<tr class="separator:ac816fe1f356205b0fef57c3cdb500ca0 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e52370b1b816c402867dd27aeb0c64f inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1e52370b1b816c402867dd27aeb0c64f">getGoodPiv</a> () const</td></tr>
<tr class="separator:a1e52370b1b816c402867dd27aeb0c64f inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd3feb9f48d6a206cef0e7c74dceebe inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1fd3feb9f48d6a206cef0e7c74dceebe">getRelPivTol</a> () const</td></tr>
<tr class="separator:a1fd3feb9f48d6a206cef0e7c74dceebe inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f1b1273fc526e772a8bc17f7df93e5 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60f1b1273fc526e772a8bc17f7df93e5">getPivErrTol</a> () const</td></tr>
<tr class="separator:a60f1b1273fc526e772a8bc17f7df93e5 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f7fcadce90f9e2f0200641e389839 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af24f7fcadce90f9e2f0200641e389839">getRelPivErrTol</a> () const</td></tr>
<tr class="separator:af24f7fcadce90f9e2f0200641e389839 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576593762fc04542102b77b183fe1b5a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a576593762fc04542102b77b183fe1b5a">setVarTol</a> (double tol)</td></tr>
<tr class="separator:a576593762fc04542102b77b183fe1b5a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08c3dd8c2a520eab4122a2789609810 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac08c3dd8c2a520eab4122a2789609810">getVarTol</a> () const</td></tr>
<tr class="separator:ac08c3dd8c2a520eab4122a2789609810 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeddcd066d467d08fb8328f7ccae88f8 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aaeddcd066d467d08fb8328f7ccae88f8">getCtrTol</a> () const</td></tr>
<tr class="separator:aaeddcd066d467d08fb8328f7ccae88f8 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac888a61e64a5f4a3a52bbfd2cbc3cac3 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac888a61e64a5f4a3a52bbfd2cbc3cac3">setShadowPriceTol</a> (double tol)</td></tr>
<tr class="separator:ac888a61e64a5f4a3a52bbfd2cbc3cac3 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccd228f5834359466cff18b0f6f05f0 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9ccd228f5834359466cff18b0f6f05f0">getShadowPriceTol</a> () const</td></tr>
<tr class="separator:a9ccd228f5834359466cff18b0f6f05f0 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7feb77a91a7839b570a69e712da2a83 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad7feb77a91a7839b570a69e712da2a83">setRedCostTol</a> (double tol)</td></tr>
<tr class="separator:ad7feb77a91a7839b570a69e712da2a83 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a0519468aae3f041641948cf59aea2 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a14a0519468aae3f041641948cf59aea2">getRedCostTol</a> () const</td></tr>
<tr class="separator:a14a0519468aae3f041641948cf59aea2 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eb4ddddfc54fd90df48a07e89c555b inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa6eb4ddddfc54fd90df48a07e89c555b">setDegenTol</a> (double primeDegTol, double dualDegTol)</td></tr>
<tr class="separator:aa6eb4ddddfc54fd90df48a07e89c555b inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a48a82310b64fbfd5db845cf6fe11 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae39a48a82310b64fbfd5db845cf6fe11">getPrimeDegTol</a> () const</td></tr>
<tr class="separator:ae39a48a82310b64fbfd5db845cf6fe11 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0af3765cf29ebec0e93462b47958408 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa0af3765cf29ebec0e93462b47958408">getDualDegTol</a> () const</td></tr>
<tr class="separator:aa0af3765cf29ebec0e93462b47958408 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e92e08af8ffe926643a4bf18b8c4c9 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af9e92e08af8ffe926643a4bf18b8c4c9">setVarViolatThreshold</a> (double th)</td></tr>
<tr class="separator:af9e92e08af8ffe926643a4bf18b8c4c9 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529998af95e064af12df5e28790958b5 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a529998af95e064af12df5e28790958b5">getVarViolatThreshold</a> () const</td></tr>
<tr class="separator:a529998af95e064af12df5e28790958b5 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb50173d4aa205755b0808ab32912992 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adb50173d4aa205755b0808ab32912992">setShadowPriceToleranceThreshold</a> (double th)</td></tr>
<tr class="separator:adb50173d4aa205755b0808ab32912992 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91942427d24c7c88a0a3feda3bd92b1a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a91942427d24c7c88a0a3feda3bd92b1a">setScaling</a> (<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">enScaling</a> scalingMethod)</td></tr>
<tr class="separator:a91942427d24c7c88a0a3feda3bd92b1a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f638d505d663c8782b2935e8410b3be inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7f638d505d663c8782b2935e8410b3be">preprocOff</a> ()</td></tr>
<tr class="separator:a7f638d505d663c8782b2935e8410b3be inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9704ad0e87c595e671ed0d45e72eaa0 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab9704ad0e87c595e671ed0d45e72eaa0">lpInfoMsg</a> () const</td></tr>
<tr class="separator:ab9704ad0e87c595e671ed0d45e72eaa0 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6759b414050614829e2e5570e8d03fb6 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6759b414050614829e2e5570e8d03fb6">switchLpInfoMsg</a> (bool flag)</td></tr>
<tr class="separator:a6759b414050614829e2e5570e8d03fb6 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704eb701bea22a2008f3bd02f1c561cc inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a704eb701bea22a2008f3bd02f1c561cc">beSilent</a> (bool flag=true)</td></tr>
<tr class="separator:a704eb701bea22a2008f3bd02f1c561cc inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e6dfc38f4087fb3e106663c8da2639 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae1e6dfc38f4087fb3e106663c8da2639">isSilent</a> () const</td></tr>
<tr class="separator:ae1e6dfc38f4087fb3e106663c8da2639 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74448bf0bb4ddd874f517399e8789fd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad74448bf0bb4ddd874f517399e8789fd">setFrequencyForInfoMsg</a> (int fr)</td></tr>
<tr class="separator:ad74448bf0bb4ddd874f517399e8789fd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77d02d81b5e5a3899d084d4e421059e inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae77d02d81b5e5a3899d084d4e421059e">setOptFlags</a> (bool primeFeasible, bool dualFeasible)</td></tr>
<tr class="separator:ae77d02d81b5e5a3899d084d4e421059e inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c2920755af35791f7244dbe1ccdf4f inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a16c2920755af35791f7244dbe1ccdf4f">setObjective</a> (const double *dpC, bool sense=true, bool scale=true)</td></tr>
<tr class="separator:a16c2920755af35791f7244dbe1ccdf4f inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c4a43ce27925dc2b132d89475ccc0a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a80c4a43ce27925dc2b132d89475ccc0a">setObjective</a> (int i, bool sense=true)</td></tr>
<tr class="separator:a80c4a43ce27925dc2b132d89475ccc0a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cc3d96268be208d0e9a730b067f1f1 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad1cc3d96268be208d0e9a730b067f1f1">setObjSense</a> (bool sense)</td></tr>
<tr class="separator:ad1cc3d96268be208d0e9a730b067f1f1 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75327ce571f101fe443033506f7423d2 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a75327ce571f101fe443033506f7423d2">getObjSense</a> () const</td></tr>
<tr class="separator:a75327ce571f101fe443033506f7423d2 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7842343e7840db5a2284c66428a4b70 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad7842343e7840db5a2284c66428a4b70">getVarNum</a> () const</td></tr>
<tr class="separator:ad7842343e7840db5a2284c66428a4b70 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4080308e4f21d6f55514ac92fc3fb1f inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af4080308e4f21d6f55514ac92fc3fb1f">getCtrNum</a> () const</td></tr>
<tr class="separator:af4080308e4f21d6f55514ac92fc3fb1f inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368038ca0f767d2aa0deee9e68e070a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af368038ca0f767d2aa0deee9e68e070a">getNonZerosNum</a> () const</td></tr>
<tr class="separator:af368038ca0f767d2aa0deee9e68e070a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f623b653c23c1585978f1cbbccab34 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a28f623b653c23c1585978f1cbbccab34">isRowGen</a> () const</td></tr>
<tr class="separator:a28f623b653c23c1585978f1cbbccab34 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e7c2012c4b3bc852a7a2c19e5863a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad90e7c2012c4b3bc852a7a2c19e5863a">isColGen</a> ()</td></tr>
<tr class="separator:ad90e7c2012c4b3bc852a7a2c19e5863a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd">CLP</a> (const char *name)</td></tr>
<tr class="separator:a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4fd54e671d455d0c012dc5c768f1b inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a49d4fd54e671d455d0c012dc5c768f1b">CLP</a> (const <a class="el" href="classCLP.html">CLP</a> &amp;other, int thread)</td></tr>
<tr class="memdesc:a49d4fd54e671d455d0c012dc5c768f1b inherit pub_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone constructor.  <a href="classCLP.html#a49d4fd54e671d455d0c012dc5c768f1b">More...</a><br /></td></tr>
<tr class="separator:a49d4fd54e671d455d0c012dc5c768f1b inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a01cdc1056b917d6a97fc1787ba26e inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a42a01cdc1056b917d6a97fc1787ba26e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a42a01cdc1056b917d6a97fc1787ba26e">~CLP</a> ()</td></tr>
<tr class="memdesc:a42a01cdc1056b917d6a97fc1787ba26e inherit pub_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br /></td></tr>
<tr class="separator:a42a01cdc1056b917d6a97fc1787ba26e inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b435146fc416d5bc296f0acbbf029 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0d5b435146fc416d5bc296f0acbbf029">addCtr</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double lhs, double rhs)</td></tr>
<tr class="separator:a0d5b435146fc416d5bc296f0acbbf029 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7861b5b2e692f6043dfe1d7bd77e21 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double lhs, double rhs, int sz, double *dpVal, int *ipCol, bool bSort=true)</td></tr>
<tr class="separator:aee7861b5b2e692f6043dfe1d7bd77e21 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cfc7443dff945bc5a424fb161e5d5c inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac7cfc7443dff945bc5a424fb161e5d5c">safeAddRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double lhs, double rhs, int sz, double *&amp;dpVal, int *&amp;ipCol, bool bSort=true)</td></tr>
<tr class="separator:ac7cfc7443dff945bc5a424fb161e5d5c inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e6abd8eca3cbf22a958dbddbfe9069 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a41e6abd8eca3cbf22a958dbddbfe9069">addVar</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u)</td></tr>
<tr class="separator:a41e6abd8eca3cbf22a958dbddbfe9069 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1903c28e39c136ec8fcbe9cb65a8bd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">addColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u, int sz, double *dpVal, int *ipRow, bool bSort=true)</td></tr>
<tr class="separator:aae1903c28e39c136ec8fcbe9cb65a8bd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62386390656150763472f05e4419e82d inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a62386390656150763472f05e4419e82d">safeAddColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u, int sz, double *&amp;dpVal, int *&amp;ipRow, bool bSort=true)</td></tr>
<tr class="separator:a62386390656150763472f05e4419e82d inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574534be9bfcd5d37b8cd209cf2e2535 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a574534be9bfcd5d37b8cd209cf2e2535">addEntry</a> (double val, int i, int j)</td></tr>
<tr class="separator:a574534be9bfcd5d37b8cd209cf2e2535 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd55a5bdee0bded239e5d2d772cbea5 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aafd55a5bdee0bded239e5d2d772cbea5">changeEntry</a> (double val, int i, int j)</td></tr>
<tr class="separator:aafd55a5bdee0bded239e5d2d772cbea5 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b1aab13d38650f5c441d2fa986c550 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a63b1aab13d38650f5c441d2fa986c550">getRowSize</a> (int i) const</td></tr>
<tr class="separator:a63b1aab13d38650f5c441d2fa986c550 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e320a943d314b9407a03f45e6711a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a747e320a943d314b9407a03f45e6711a">getColumnSize</a> (int j) const</td></tr>
<tr class="separator:a747e320a943d314b9407a03f45e6711a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61adc020de168f43627a0d1e3e1a78dd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a61adc020de168f43627a0d1e3e1a78dd">getLHS</a> (int i) const</td></tr>
<tr class="separator:a61adc020de168f43627a0d1e3e1a78dd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4295d11a43be2e37beb19366b97c16 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acc4295d11a43be2e37beb19366b97c16">getRHS</a> (int i) const</td></tr>
<tr class="separator:acc4295d11a43be2e37beb19366b97c16 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07712842e5a79726863b4a08f3e1410a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a07712842e5a79726863b4a08f3e1410a">getVarLoBound</a> (int j) const</td></tr>
<tr class="separator:a07712842e5a79726863b4a08f3e1410a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68264a2571e3f720bddb4afb2be3e8a5 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a68264a2571e3f720bddb4afb2be3e8a5">getVarUpBound</a> (int j) const</td></tr>
<tr class="separator:a68264a2571e3f720bddb4afb2be3e8a5 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b76fdfaaea16e1d251688a596e4ad01 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1b76fdfaaea16e1d251688a596e4ad01">getObjCoeff</a> (int j) const</td></tr>
<tr class="separator:a1b76fdfaaea16e1d251688a596e4ad01 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb97ed82d53f698715069ce966a1dd0e inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeb97ed82d53f698715069ce966a1dd0e">setObjCoeff</a> (int j, double val)</td></tr>
<tr class="separator:aeb97ed82d53f698715069ce966a1dd0e inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09cc6122bc3b2f960723b9e6daabfe7 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac09cc6122bc3b2f960723b9e6daabfe7">setLpPricingRule</a> (<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a> pricingRule)</td></tr>
<tr class="separator:ac09cc6122bc3b2f960723b9e6daabfe7 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885168355b7d81cfa3cb7872ec5ec0a4 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a885168355b7d81cfa3cb7872ec5ec0a4">getPricingRule</a> () const</td></tr>
<tr class="separator:a885168355b7d81cfa3cb7872ec5ec0a4 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb08fe1a8a4075dc382d6df66638061 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8bb08fe1a8a4075dc382d6df66638061">setLpSepRule</a> (<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a> sepRule)</td></tr>
<tr class="separator:a8bb08fe1a8a4075dc382d6df66638061 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec30b96087c0a237e468907de24c75e inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acec30b96087c0a237e468907de24c75e">getSepRule</a> () const</td></tr>
<tr class="separator:acec30b96087c0a237e468907de24c75e inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7f26d09a5c395b7abe013ce5b4b571 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7c7f26d09a5c395b7abe013ce5b4b571">setMaxLuUpdateNum</a> (int maxUpdateNum)</td></tr>
<tr class="separator:a7c7f26d09a5c395b7abe013ce5b4b571 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58670ea03d928f8310d1974409daba4a inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a58670ea03d928f8310d1974409daba4a">getRowValue</a> (int i, double *dpX) const</td></tr>
<tr class="separator:a58670ea03d928f8310d1974409daba4a inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a12c913e4ddbdb194d7b75b11d0500 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a30a12c913e4ddbdb194d7b75b11d0500">setLPmethod</a> (<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a> method)</td></tr>
<tr class="separator:a30a12c913e4ddbdb194d7b75b11d0500 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19188e63c2b129617b4397812cf7b811 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a19188e63c2b129617b4397812cf7b811">getCurrentLPmethod</a> () const</td></tr>
<tr class="separator:a19188e63c2b129617b4397812cf7b811 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62425ce4381d5cb0fa084815590eeb6 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeToStop=0l, double upperBound=INF, int maxItNum=1000000000, int degCheckInterval=250, int maxDegPrc=90)</td></tr>
<tr class="separator:ac62425ce4381d5cb0fa084815590eeb6 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f4a451dece7eb131a6c63bdcc7189d inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeToStop=0l, double lowerBound=-INF, int maxItNum=1000000000, bool needSol=true, bool inconsistSertificate=false, int degCheckInterval=250, int maxDegPrc=90)</td></tr>
<tr class="separator:ae6f4a451dece7eb131a6c63bdcc7189d inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133727d823c6536163212af7e98ca50 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af133727d823c6536163212af7e98ca50">switchOffRowGen</a> ()</td></tr>
<tr class="separator:af133727d823c6536163212af7e98ca50 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc59423144491763ebe6a328b9678f inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a50fc59423144491763ebe6a328b9678f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a50fc59423144491763ebe6a328b9678f">switchOnColGen</a> ()</td></tr>
<tr class="memdesc:a50fc59423144491763ebe6a328b9678f inherit pub_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to allow generation of new columns. <br /></td></tr>
<tr class="separator:a50fc59423144491763ebe6a328b9678f inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0fb59442b39d19e5bfc77b92a935f inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a06d0fb59442b39d19e5bfc77b92a935f">setVarBounds</a> (int j, double l, double u)</td></tr>
<tr class="separator:a06d0fb59442b39d19e5bfc77b92a935f inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164c589a3f2bce353f2585f37ab5109c inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a164c589a3f2bce353f2585f37ab5109c">setVarLoBound</a> (int j, double l)</td></tr>
<tr class="separator:a164c589a3f2bce353f2585f37ab5109c inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4910c689baa5522fc29d77599affc2cb inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4910c689baa5522fc29d77599affc2cb">setVarUpBound</a> (int j, double u)</td></tr>
<tr class="separator:a4910c689baa5522fc29d77599affc2cb inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31b76176f5ffbcaf2898eaa2d1a2e24 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab31b76176f5ffbcaf2898eaa2d1a2e24">setVarFree</a> (int j)</td></tr>
<tr class="separator:ab31b76176f5ffbcaf2898eaa2d1a2e24 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde48f5ce2e42ac3feee72da0cf74ff8 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#afde48f5ce2e42ac3feee72da0cf74ff8">setCtrBounds</a> (int i, double lhs, double rhs)</td></tr>
<tr class="separator:afde48f5ce2e42ac3feee72da0cf74ff8 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260179a2e457f650376e7a92b8136549 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a260179a2e457f650376e7a92b8136549">setLHS</a> (int i, double lhs)</td></tr>
<tr class="separator:a260179a2e457f650376e7a92b8136549 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b45b189fcc1114a6dd99afb68709c2 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad8b45b189fcc1114a6dd99afb68709c2">setRHS</a> (int i, double rhs)</td></tr>
<tr class="separator:ad8b45b189fcc1114a6dd99afb68709c2 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b06d08bbbe459d890cb206b4c03328 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a53b06d08bbbe459d890cb206b4c03328">setCtrFree</a> (int i)</td></tr>
<tr class="separator:a53b06d08bbbe459d890cb206b4c03328 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b6916019aae383786af2635687f359 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af3b6916019aae383786af2635687f359">isPrepared</a> () const</td></tr>
<tr class="separator:af3b6916019aae383786af2635687f359 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277afd563c5fd0849a6480a80f486fee inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a277afd563c5fd0849a6480a80f486fee">isSolved</a> () const</td></tr>
<tr class="separator:a277afd563c5fd0849a6480a80f486fee inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f4551e040248b83ced4d34c0ab017 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a497f4551e040248b83ced4d34c0ab017">isLpInfeasible</a> () const</td></tr>
<tr class="separator:a497f4551e040248b83ced4d34c0ab017 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50da983157733dd19de4d91dfec2aabf inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a50da983157733dd19de4d91dfec2aabf">isInfeasible</a> () const</td></tr>
<tr class="separator:a50da983157733dd19de4d91dfec2aabf inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ec9a7bc4bd6a249a0c73de69f1b17 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a297ec9a7bc4bd6a249a0c73de69f1b17">isLpUnbounded</a> () const</td></tr>
<tr class="separator:a297ec9a7bc4bd6a249a0c73de69f1b17 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b51623f53e3da259dfac58d65d0d3dd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7b51623f53e3da259dfac58d65d0d3dd">getObjVal</a> () const</td></tr>
<tr class="separator:a7b51623f53e3da259dfac58d65d0d3dd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1636d6070c91135f68892056e59b33b4 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1636d6070c91135f68892056e59b33b4">getSolution</a> (double *&amp;dpX, int *&amp;ipHd)</td></tr>
<tr class="separator:a1636d6070c91135f68892056e59b33b4 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a68321fefd80cacbb77c3076703cc6 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a90a68321fefd80cacbb77c3076703cc6">getReducedCosts</a> (double *&amp;dpC, int *&amp;ipHd)</td></tr>
<tr class="separator:a90a68321fefd80cacbb77c3076703cc6 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45de9d5f0eea44f06a733026b9a99fd inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae45de9d5f0eea44f06a733026b9a99fd">getShadowPrices</a> (double *&amp;dpP, int *&amp;ipHd)</td></tr>
<tr class="separator:ae45de9d5f0eea44f06a733026b9a99fd inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f43361e3880af54ce8ff86d806d4ded inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible</a> (int &amp;m, int *&amp;ipRowHd, double *&amp;dpYctr, int &amp;n, int *&amp;ipColHd, double *&amp;dpYbd)</td></tr>
<tr class="separator:a4f43361e3880af54ce8ff86d806d4ded inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc8c6445cbc093409f21ee338f0924c inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:afdc8c6445cbc093409f21ee338f0924c inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0ea08d73d4bcbcbdb38176627aa52f inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aab0ea08d73d4bcbcbdb38176627aa52f">showWhyLpInfeasible</a> (const char *fileName)</td></tr>
<tr class="separator:aab0ea08d73d4bcbcbdb38176627aa52f inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d11405730a32a3917518bd97f06d6ae inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7d11405730a32a3917518bd97f06d6ae">whyLpUnbounded</a> (int &amp;n, double *&amp;dpX, double *&amp;dpRay, int *&amp;ipColHd)</td></tr>
<tr class="separator:a7d11405730a32a3917518bd97f06d6ae inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5f5d38fd9d40af6e38eba360bc48e2 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6d5f5d38fd9d40af6e38eba360bc48e2">showWhyLpUnbounded</a> (const char *fileName)</td></tr>
<tr class="separator:a6d5f5d38fd9d40af6e38eba360bc48e2 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf63388547e9d3523c70699094314cb inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2bf63388547e9d3523c70699094314cb">printRow</a> (int i, bool scaled=true, bool varValues=false)</td></tr>
<tr class="separator:a2bf63388547e9d3523c70699094314cb inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1562920480fa37e7107b59a80a9be3e inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad1562920480fa37e7107b59a80a9be3e">printCtr</a> (int sz, double *dpVal, int *ipCol, double b, bool side=true)</td></tr>
<tr class="separator:ad1562920480fa37e7107b59a80a9be3e inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff57f622722c92212ebc47b54e2441 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0cff57f622722c92212ebc47b54e2441">printColumn</a> (int j)</td></tr>
<tr class="separator:a0cff57f622722c92212ebc47b54e2441 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcd371acb757fe0683f639cf1cf7646 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1dcd371acb757fe0683f639cf1cf7646">printMatrix</a> (const char *fileName, bool scaled=false)</td></tr>
<tr class="separator:a1dcd371acb757fe0683f639cf1cf7646 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3621d8732a32eab9a5314e75a6068c inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5d3621d8732a32eab9a5314e75a6068c">allowNormCtrs</a> (int maxCtrNum, int avCtrSize)</td></tr>
<tr class="separator:a5d3621d8732a32eab9a5314e75a6068c inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f07b72b28d7ca0a26423c6a822dd6 inherit pub_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a098f07b72b28d7ca0a26423c6a822dd6">addNormCtr</a> (int t, int sz, int *ipVars, double tol=0.0001)</td></tr>
<tr class="separator:a098f07b72b28d7ca0a26423c6a822dd6 inherit pub_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a33363f035bbd0ac5746cc4753886b013"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCMIP.html">CMIP</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a> (const <a class="el" href="classCMIP.html">CMIP</a> *pMip, int thread)</td></tr>
<tr class="memdesc:a33363f035bbd0ac5746cc4753886b013"><td class="mdescLeft">&#160;</td><td class="mdescRight">The clone constructor.  <a href="#a33363f035bbd0ac5746cc4753886b013">More...</a><br /></td></tr>
<tr class="separator:a33363f035bbd0ac5746cc4753886b013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649cf1a63f09051dc7ac68f5af4f8e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab649cf1a63f09051dc7ac68f5af4f8e0">getThreadNum</a> () const</td></tr>
<tr class="separator:ab649cf1a63f09051dc7ac68f5af4f8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245e3f9e2217153cb75862b3a3f0767a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a245e3f9e2217153cb75862b3a3f0767a">getThreadIndex</a> () const</td></tr>
<tr class="separator:a245e3f9e2217153cb75862b3a3f0767a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc325e5a1dd43d1a87cebc5857a0a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#affc325e5a1dd43d1a87cebc5857a0a70">extendVarType</a> (int j, unsigned type) final</td></tr>
<tr class="separator:affc325e5a1dd43d1a87cebc5857a0a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06691ddef275b820b98471b8d8e3e19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ae06691ddef275b820b98471b8d8e3e19">isVarStrongIntegral</a> (int j) const final</td></tr>
<tr class="separator:ae06691ddef275b820b98471b8d8e3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89565cfb1b01944400728feca3c7d982"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a89565cfb1b01944400728feca3c7d982">isVarUsedForBranching</a> (int j) const final</td></tr>
<tr class="separator:a89565cfb1b01944400728feca3c7d982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f82a8cfe403d1d49be43e2abbd67be8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a4f82a8cfe403d1d49be43e2abbd67be8">isVarSOS</a> (int j) const</td></tr>
<tr class="separator:a4f82a8cfe403d1d49be43e2abbd67be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ecb21cc14bdb8cdeb068c13fde435d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab1ecb21cc14bdb8cdeb068c13fde435d">isVarScalable</a> (int j) const final</td></tr>
<tr class="separator:ab1ecb21cc14bdb8cdeb068c13fde435d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad146e585c3151d8858e80060ec389372"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad146e585c3151d8858e80060ec389372">isCtrIntegral</a> (int i) const</td></tr>
<tr class="separator:ad146e585c3151d8858e80060ec389372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae818e90fc48a61d0e153dbd98e92ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a8ae818e90fc48a61d0e153dbd98e92ca">isObjIntegral</a> () const</td></tr>
<tr class="separator:a8ae818e90fc48a61d0e153dbd98e92ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25a1b8ab14ae7b0a0266a7db89028f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aa25a1b8ab14ae7b0a0266a7db89028f0">isVarUpBoundLocal</a> (int j) const</td></tr>
<tr class="separator:aa25a1b8ab14ae7b0a0266a7db89028f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0cb171ac7845bad5a98e802671ee62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a1a0cb171ac7845bad5a98e802671ee62">isVarLoBoundLocal</a> (int j) const</td></tr>
<tr class="separator:a1a0cb171ac7845bad5a98e802671ee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6796e219e7afe777d33a62ba4a49e32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad6796e219e7afe777d33a62ba4a49e32">isVarMonotoneUp</a> (int j) const</td></tr>
<tr class="separator:ad6796e219e7afe777d33a62ba4a49e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa8b7bde9d6bbdf4cd3cc01a00a0a68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#affa8b7bde9d6bbdf4cd3cc01a00a0a68">isVarMonotoneDown</a> (int j) const</td></tr>
<tr class="separator:affa8b7bde9d6bbdf4cd3cc01a00a0a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e78f58e822cc004cda1d6fcf2b2c61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a91e78f58e822cc004cda1d6fcf2b2c61">isVarMonotone</a> (int j) const</td></tr>
<tr class="separator:a91e78f58e822cc004cda1d6fcf2b2c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90006f5ca6072e800c547d454341150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad90006f5ca6072e800c547d454341150">probingInfo</a> (char *timeStr, int round, int probeVarNum, int varFixed, int ctrTightened, int varBdAdded, int implications)</td></tr>
<tr class="separator:ad90006f5ca6072e800c547d454341150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9827da8d0317a1f1b546ac3421790130"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1</a> (int n, const double *dpX, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipColHd)</td></tr>
<tr class="separator:a9827da8d0317a1f1b546ac3421790130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af3635d2a8696dc3ae7b55e6006c4de"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2</a> (int n, const double *dpX, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipColHd)</td></tr>
<tr class="separator:a6af3635d2a8696dc3ae7b55e6006c4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bd4129b916c2f5f6d3a8741ae3734d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd)</td></tr>
<tr class="separator:a85bd4129b916c2f5f6d3a8741ae3734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f16e46d8cc9b738b0acd18bee6bcc7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd)</td></tr>
<tr class="separator:a1f16e46d8cc9b738b0acd18bee6bcc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13082b9c5de8ce176ce626b9d8853b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">lockColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd)</td></tr>
<tr class="separator:ab13082b9c5de8ce176ce626b9d8853b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f03143ca1246848919bb567b0bd1ec4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">unlockColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd)</td></tr>
<tr class="separator:a2f03143ca1246848919bb567b0bd1ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3798c5cb419733a4050e47215b178c48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a3798c5cb419733a4050e47215b178c48">delNodeLocalCtrs</a> (int nd)</td></tr>
<tr class="separator:a3798c5cb419733a4050e47215b178c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58771d3c7e8c151087e5d3944a97ac93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a58771d3c7e8c151087e5d3944a97ac93">delNodeLocalColumns</a> (int nd)</td></tr>
<tr class="separator:a58771d3c7e8c151087e5d3944a97ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591895e6bb2d334e6fb8f0a76711c099"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching</a> (int nodeHeight)</td></tr>
<tr class="separator:a591895e6bb2d334e6fb8f0a76711c099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46358134da85552da3e76a53ca9eaf43"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch</a> (int i)</td></tr>
<tr class="separator:a46358134da85552da3e76a53ca9eaf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931123a832a3bcf0432ecf6fdeff6479"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a931123a832a3bcf0432ecf6fdeff6479">isFeasible</a> (int n, const double *dpX, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipColHd)</td></tr>
<tr class="separator:a931123a832a3bcf0432ecf6fdeff6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33583b56007c47d05de26a005a993792"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a33583b56007c47d05de26a005a993792">getFractional</a> (double &amp;d)</td></tr>
<tr class="memdesc:a33583b56007c47d05de26a005a993792"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined prime heuristic.  <a href="#a33583b56007c47d05de26a005a993792">More...</a><br /></td></tr>
<tr class="separator:a33583b56007c47d05de26a005a993792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12f1918e4566ac5b358861a4dbfd326"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af12f1918e4566ac5b358861a4dbfd326">roundSolution</a> (double &amp;objVal, int n, double *dpX, const int *ipColHd)</td></tr>
<tr class="separator:af12f1918e4566ac5b358861a4dbfd326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0191788fe39cf446877f6bd627eeca90"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a0191788fe39cf446877f6bd627eeca90">propagate</a> ()</td></tr>
<tr class="separator:a0191788fe39cf446877f6bd627eeca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996f868ad1dbd766421fa6e8c7ae2c9d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a996f868ad1dbd766421fa6e8c7ae2c9d">storeNodeData</a> (int *ipVal)</td></tr>
<tr class="separator:a996f868ad1dbd766421fa6e8c7ae2c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa043fd46c50b56da7b303ed4d57da39"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#aaa043fd46c50b56da7b303ed4d57da39">restoreNodeData</a> (int *ipVal)</td></tr>
<tr class="separator:aaa043fd46c50b56da7b303ed4d57da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52f642c579d214dfa706ddca4abc375"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad52f642c579d214dfa706ddca4abc375">setCtrsInactive</a> (int sz, int *ipCtr) override</td></tr>
<tr class="separator:ad52f642c579d214dfa706ddca4abc375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e469aee7603340f2084491b155e76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a612e469aee7603340f2084491b155e76">setColumnsInactive</a> (int sz, int *ipCtr) override</td></tr>
<tr class="separator:a612e469aee7603340f2084491b155e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af864821866ac67b2700be91ef97bb95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#af864821866ac67b2700be91ef97bb95c">shrinkCut</a> (int maxSize, int &amp;sz, int *ipCol, double *dpVal, double &amp;b, int &amp;iFactor, bool &amp;bLocal)</td></tr>
<tr class="separator:af864821866ac67b2700be91ef97bb95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd245965e7a73e148149eb8c198dacb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#abd245965e7a73e148149eb8c198dacb4">serialize</a> (std::fstream &amp;ar, bool is_storing) override</td></tr>
<tr class="separator:abd245965e7a73e148149eb8c198dacb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dc77bf42627bf7f8981ec5b2cc2de6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#a17dc77bf42627bf7f8981ec5b2cc2de6">mipInfo</a> (char *timeElapsed, int nodeNum, int leafNum, double bestObjVal, double objBound, double gap, int solsFound, bool sense, bool header)</td></tr>
<tr class="separator:a17dc77bf42627bf7f8981ec5b2cc2de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50aeee183a24470294ec4b32e8a079f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ac50aeee183a24470294ec4b32e8a079f">cutInfo</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> time, int round, double objVal, int fracNum, int cutNum)</td></tr>
<tr class="separator:ac50aeee183a24470294ec4b32e8a079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55ab22a22515545b2f13996904e0577"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad55ab22a22515545b2f13996904e0577">cutStatistics</a> ()</td></tr>
<tr class="separator:ad55ab22a22515545b2f13996904e0577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5edb20a3c41f1655e4eedbc3514ce23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMIP.html#ad5edb20a3c41f1655e4eedbc3514ce23">solStatistics</a> (std::ostream &amp;out, const char *MIPCLver, const char *solTime, bool timeLimit, int nodeNum, bool feasible, bool hasSolution, double objVal, bool opt, double gap, bool gapLimit, double bound, int difficultNodes)</td></tr>
<tr class="separator:ad5edb20a3c41f1655e4eedbc3514ce23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classCLP')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:a2da8fa240b6d69974fb73c0ee942de52 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2da8fa240b6d69974fb73c0ee942de52">multiplyCtr</a> (int i, double factor)</td></tr>
<tr class="separator:a2da8fa240b6d69974fb73c0ee942de52 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6433f319b666c6c42389875c232f920e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6433f319b666c6c42389875c232f920e">extendCtrType</a> (int i, unsigned type)</td></tr>
<tr class="separator:a6433f319b666c6c42389875c232f920e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a388179951a58ff108cb9aeffc48aba inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5a388179951a58ff108cb9aeffc48aba">isVarIntegral</a> (int j) const</td></tr>
<tr class="separator:a5a388179951a58ff108cb9aeffc48aba inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a42d3bb1f3cd41bf5454106080139d inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a72a42d3bb1f3cd41bf5454106080139d">isVarBinary</a> (int j) const</td></tr>
<tr class="separator:a72a42d3bb1f3cd41bf5454106080139d inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed51f6357c2a1a7a9e3cd434296a41 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow</a> (int row, double *dpVal, int *ipCol, bool bScaled=false)</td></tr>
<tr class="separator:a16ed51f6357c2a1a7a9e3cd434296a41 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75754fed56e5caa1755a72a8adab225e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn</a> (int col, double *dpVal, int *ipRow, bool bScaled=false)</td></tr>
<tr class="separator:a75754fed56e5caa1755a72a8adab225e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5309eca95342409d93fec05a7375d7 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9d5309eca95342409d93fec05a7375d7">computeObjValue</a> (bool recomputeBasicVarsCost=false)</td></tr>
<tr class="separator:a9d5309eca95342409d93fec05a7375d7 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d5e85eed5683918536072019f7bda5 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a10d5e85eed5683918536072019f7bda5">shiftBounds</a> ()</td></tr>
<tr class="separator:a10d5e85eed5683918536072019f7bda5 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aead89f9f0ae4100f6639678a8ff98b inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9aead89f9f0ae4100f6639678a8ff98b">basicPreprocess</a> (bool bDominant=true)</td></tr>
<tr class="separator:a9aead89f9f0ae4100f6639678a8ff98b inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d3efb7db52940403ab6d32bfe45fb6 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af1d3efb7db52940403ab6d32bfe45fb6">preprocess</a> ()</td></tr>
<tr class="separator:af1d3efb7db52940403ab6d32bfe45fb6 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad29cf287728182fa3baf93fd121732 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a6ad29cf287728182fa3baf93fd121732"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6ad29cf287728182fa3baf93fd121732">scaleObj</a> ()</td></tr>
<tr class="memdesc:a6ad29cf287728182fa3baf93fd121732 inherit pro_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales objective with previously computed column scale factors. <br /></td></tr>
<tr class="separator:a6ad29cf287728182fa3baf93fd121732 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e23e02b2d3fa31cd46fce8405db0509 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a7e23e02b2d3fa31cd46fce8405db0509"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7e23e02b2d3fa31cd46fce8405db0509">SCL_scaleMatrix</a> ()</td></tr>
<tr class="memdesc:a7e23e02b2d3fa31cd46fce8405db0509 inherit pro_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales matrix with previously computed scale factors. <br /></td></tr>
<tr class="separator:a7e23e02b2d3fa31cd46fce8405db0509 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa07941b540e729bca314a31369373e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5fa07941b540e729bca314a31369373e">scaleMatrix</a> ()</td></tr>
<tr class="memdesc:a5fa07941b540e729bca314a31369373e inherit pro_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute factors and then scales matrix.  <a href="classCLP.html#a5fa07941b540e729bca314a31369373e">More...</a><br /></td></tr>
<tr class="separator:a5fa07941b540e729bca314a31369373e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74596843baa7984e3407a7d4016928e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ab74596843baa7984e3407a7d4016928e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab74596843baa7984e3407a7d4016928e">unscaleMatrix</a> ()</td></tr>
<tr class="memdesc:ab74596843baa7984e3407a7d4016928e inherit pro_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers matrix to initial state. <br /></td></tr>
<tr class="separator:ab74596843baa7984e3407a7d4016928e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c15331979ed725b3175a0547b8885a7 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1c15331979ed725b3175a0547b8885a7">compressMatrix</a> (int m0=0, int n0=0, bool prepFlag=true, bool bEntry=true)</td></tr>
<tr class="separator:a1c15331979ed725b3175a0547b8885a7 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28902beb78bacc0501a0991a87621655 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a28902beb78bacc0501a0991a87621655">deleteNonBasicLines</a> (int m, int n, bool bFull, double tight)</td></tr>
<tr class="separator:a28902beb78bacc0501a0991a87621655 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f06d58c9f995bbbf5942c5c812eb2 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a369f06d58c9f995bbbf5942c5c812eb2">scaleRow</a> (int sz, double *dpVal, int *ipCol)</td></tr>
<tr class="separator:a369f06d58c9f995bbbf5942c5c812eb2 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ddbe21b8a232349765cfc3017d726b inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a47ddbe21b8a232349765cfc3017d726b">scaleCtr</a> (double &amp;lhs, double &amp;rhs, int sz, double *dpVal, int *ipCol)</td></tr>
<tr class="separator:a47ddbe21b8a232349765cfc3017d726b inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fbf7efb944d49efcca01a0f9c083d7 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af9fbf7efb944d49efcca01a0f9c083d7">scaleColumn</a> (double &amp;cost, int sz, double *dpVal, int *ipCol)</td></tr>
<tr class="separator:af9fbf7efb944d49efcca01a0f9c083d7 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaddeb4967c9c44cca3505f3e8c4a99d inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adaddeb4967c9c44cca3505f3e8c4a99d">scaleVar</a> (double &amp;cost, double &amp;l, double &amp;u, int sz, double *dpVal, int *ipRow)</td></tr>
<tr class="separator:adaddeb4967c9c44cca3505f3e8c4a99d inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe129407333ac743e0c4da6dd2ae5128 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#afe129407333ac743e0c4da6dd2ae5128">allocMemForSimplex</a> ()</td></tr>
<tr class="separator:afe129407333ac743e0c4da6dd2ae5128 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099efa5c25b4be3361d2764584f4fb81 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a099efa5c25b4be3361d2764584f4fb81">buildRowColLists</a> ()</td></tr>
<tr class="separator:a099efa5c25b4be3361d2764584f4fb81 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343e6b0b673160229a69b80fc8e08f7a inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a343e6b0b673160229a69b80fc8e08f7a">allocMemForAuxArrays</a> ()</td></tr>
<tr class="separator:a343e6b0b673160229a69b80fc8e08f7a inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893045084c9180cec0420d0c1b0a6ad inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa893045084c9180cec0420d0c1b0a6ad">reallocMemForAuxArrays</a> (bool rowMem, bool colMem)</td></tr>
<tr class="separator:aa893045084c9180cec0420d0c1b0a6ad inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab223b0873095d4b64a958e83c79438e4 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab223b0873095d4b64a958e83c79438e4">saveBasis</a> (int *mem)</td></tr>
<tr class="separator:ab223b0873095d4b64a958e83c79438e4 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8da82ce47808a11b30e749fbb568b37 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae8da82ce47808a11b30e749fbb568b37">restoreBasis</a> (int *mem)</td></tr>
<tr class="separator:ae8da82ce47808a11b30e749fbb568b37 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384498ec70e9fbc955e2cffc935c20d inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2384498ec70e9fbc955e2cffc935c20d">restoreBasis</a> (int *ipRowMap, int *ipColMap)</td></tr>
<tr class="separator:a2384498ec70e9fbc955e2cffc935c20d inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9136db891a9e87dc6e2e2726feb0ab inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5a9136db891a9e87dc6e2e2726feb0ab">getCtrRightSlack</a> (const int i, bool scaled=true) const</td></tr>
<tr class="separator:a5a9136db891a9e87dc6e2e2726feb0ab inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3298cc487c5408a38b6f55262d7ad6 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6c3298cc487c5408a38b6f55262d7ad6">getCtrLeftSlack</a> (const int i, bool scaled=true) const</td></tr>
<tr class="separator:a6c3298cc487c5408a38b6f55262d7ad6 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4da1233ad71119bd3b1aabb79d0073 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aff4da1233ad71119bd3b1aabb79d0073">getPrimeSolution</a> (double *dpBasicX, double *dpX)</td></tr>
<tr class="separator:aff4da1233ad71119bd3b1aabb79d0073 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0562bb322f77d142d666ed8152b7f1 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6d0562bb322f77d142d666ed8152b7f1">getVarValue</a> (int j) const</td></tr>
<tr class="separator:a6d0562bb322f77d142d666ed8152b7f1 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857670786cb53f3ea8479db7cc3a154 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab857670786cb53f3ea8479db7cc3a154">getRowValue</a> (int i) const</td></tr>
<tr class="separator:ab857670786cb53f3ea8479db7cc3a154 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f4f473f360001301df583f052d3b53 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a99f4f473f360001301df583f052d3b53">computeX</a> (double *x=0, int col=-1)</td></tr>
<tr class="separator:a99f4f473f360001301df583f052d3b53 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e3d3e14993182d12867c6c23c2107e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a59e3d3e14993182d12867c6c23c2107e">computeY</a> (double *y=0, bool withFixedVars=false)</td></tr>
<tr class="separator:a59e3d3e14993182d12867c6c23c2107e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d2b59626190b5c3c03f3f01544255 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a029d2b59626190b5c3c03f3f01544255">updateSolution</a> ()</td></tr>
<tr class="separator:a029d2b59626190b5c3c03f3f01544255 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440356b6889cf285de7eb2a2c852a42 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3440356b6889cf285de7eb2a2c852a42">computeBasicColumnSum</a> ()</td></tr>
<tr class="separator:a3440356b6889cf285de7eb2a2c852a42 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdf654da45516869b3d507ed7a03be7 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#abbdf654da45516869b3d507ed7a03be7">incColumnSum</a> (int col, double delta)</td></tr>
<tr class="separator:abbdf654da45516869b3d507ed7a03be7 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582069e20a64bafa43df0e1d6f30c36b inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a582069e20a64bafa43df0e1d6f30c36b">solveLP</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeLimit=0, bool genFlag=true)</td></tr>
<tr class="separator:a582069e20a64bafa43df0e1d6f30c36b inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b16107bf05adff72406dbb0869d682 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a40b16107bf05adff72406dbb0869d682">addNewRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double b1, double b2, int sz, double *&amp;dpVal, int *&amp;ipCol, bool bVarScaled=true, int factor=<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a>, int n=0, bool toBasis=true)</td></tr>
<tr class="separator:a40b16107bf05adff72406dbb0869d682 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad894bdbde67dd19464df9e48ebd2c7bb inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad894bdbde67dd19464df9e48ebd2c7bb">dublicateRow</a> (int row)</td></tr>
<tr class="memdesc:ad894bdbde67dd19464df9e48ebd2c7bb inherit pro_methods_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to the matrix another copy of row <code>row</code>.  <a href="classCLP.html#ad894bdbde67dd19464df9e48ebd2c7bb">More...</a><br /></td></tr>
<tr class="separator:ad894bdbde67dd19464df9e48ebd2c7bb inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad040a1690b496a9f62cf0908b953360a inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad040a1690b496a9f62cf0908b953360a">addNewColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u, int sz, double *&amp;dpVal, int *&amp;ipRow, bool side, bool scaled=false, int factor=0, bool flag=false)</td></tr>
<tr class="separator:ad040a1690b496a9f62cf0908b953360a inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33872ba1f311ba9cd26d9e8cc0a938d0 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a33872ba1f311ba9cd26d9e8cc0a938d0">estimateCol</a> (int sz, double *dpVal, int *ipRow)</td></tr>
<tr class="separator:a33872ba1f311ba9cd26d9e8cc0a938d0 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0849fc963749a56b07560abaa6ad8 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate</a> (int n, const double *dpX, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipColHd, bool genFlag)</td></tr>
<tr class="separator:a06d0849fc963749a56b07560abaa6ad8 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0e85fa6ec0116b6b3c1ed7563071a inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a87c0e85fa6ec0116b6b3c1ed7563071a">getDualRowVars</a> (double *y, double *z, bool bScaled)</td></tr>
<tr class="separator:a87c0e85fa6ec0116b6b3c1ed7563071a inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2fde24973288a44a64fa017337364 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5ff2fde24973288a44a64fa017337364">getColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, int m, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipHd, unsigned &amp;type, double &amp;cost, double &amp;l, double &amp;u, int &amp;sz, double *dpVal, int *ipRow)</td></tr>
<tr class="separator:a5ff2fde24973288a44a64fa017337364 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc545048ac0bee2405278c5394f5a72 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6dc545048ac0bee2405278c5394f5a72">getRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, int n, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipHd, unsigned &amp;type, double &amp;lhs, double &amp;rhs, int &amp;sz, double *dpVal, int *ipCol, bool &amp;scaled)</td></tr>
<tr class="separator:a6dc545048ac0bee2405278c5394f5a72 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a22364cac6b727f5b4e8416b753e3cc inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns</a> (int m, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipRowHd, const double *dpY)</td></tr>
<tr class="separator:a7a22364cac6b727f5b4e8416b753e3cc inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf707db6eafaf6fe2248dda596475c61 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#abf707db6eafaf6fe2248dda596475c61">getVarHandle</a> (int j) const</td></tr>
<tr class="separator:abf707db6eafaf6fe2248dda596475c61 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b035339093737c069e2f6e58ffab494 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4b035339093737c069e2f6e58ffab494">getCtrHandle</a> (int i) const</td></tr>
<tr class="separator:a4b035339093737c069e2f6e58ffab494 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564de7d70495c8124d685908c64a05b4 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a564de7d70495c8124d685908c64a05b4">getCtrName</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, char *name) const</td></tr>
<tr class="separator:a564de7d70495c8124d685908c64a05b4 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a9d61baa772136537322854f15b6ed inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a24a9d61baa772136537322854f15b6ed">getVarName</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, char *name) const</td></tr>
<tr class="separator:a24a9d61baa772136537322854f15b6ed inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa885958373244ebe82c17796bf17dd29 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa885958373244ebe82c17796bf17dd29">isVarFixed</a> (int j) const</td></tr>
<tr class="separator:aa885958373244ebe82c17796bf17dd29 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e92ccb47a2381fdc335faec89bfc84d inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8e92ccb47a2381fdc335faec89bfc84d">isVarFree</a> (int j) const</td></tr>
<tr class="separator:a8e92ccb47a2381fdc335faec89bfc84d inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a9d2aaa65e01f1f08113fcae7b8a8c inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad8a9d2aaa65e01f1f08113fcae7b8a8c">isVarBounded</a> (int j) const</td></tr>
<tr class="separator:ad8a9d2aaa65e01f1f08113fcae7b8a8c inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e297bc60583f0a97604e536364ff803 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3e297bc60583f0a97604e536364ff803">isVarLoBounded</a> (int j) const</td></tr>
<tr class="separator:a3e297bc60583f0a97604e536364ff803 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9166442b72ec9b457b643150e198cafa inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9166442b72ec9b457b643150e198cafa">isVarUpBounded</a> (int j) const</td></tr>
<tr class="separator:a9166442b72ec9b457b643150e198cafa inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2d9a525711f3ea84041d576e81a2ae inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4b2d9a525711f3ea84041d576e81a2ae">isCtrEq</a> (int i) const</td></tr>
<tr class="separator:a4b2d9a525711f3ea84041d576e81a2ae inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2c0fafb334e3f569d3e425ad66b431 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adf2c0fafb334e3f569d3e425ad66b431">isCtrFree</a> (int i) const</td></tr>
<tr class="separator:adf2c0fafb334e3f569d3e425ad66b431 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2f383c7cc7adc1f0b9aec343fd7d5 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa6d2f383c7cc7adc1f0b9aec343fd7d5">isCtrBounded</a> (int i) const</td></tr>
<tr class="separator:aa6d2f383c7cc7adc1f0b9aec343fd7d5 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58999f5b5a8426cdb355c2a7432f658a inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a58999f5b5a8426cdb355c2a7432f658a">isCtrLoBounded</a> (int i) const</td></tr>
<tr class="separator:a58999f5b5a8426cdb355c2a7432f658a inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a6c79534131e46e17853f4b7d4ee8 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a883a6c79534131e46e17853f4b7d4ee8">isCtrUpBounded</a> (int i) const</td></tr>
<tr class="separator:a883a6c79534131e46e17853f4b7d4ee8 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b924d5bbf633e2f350e5051aa4a8d2b inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3b924d5bbf633e2f350e5051aa4a8d2b">getScaledObjVal</a> (double val) const</td></tr>
<tr class="separator:a3b924d5bbf633e2f350e5051aa4a8d2b inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5be852e69e8ce4f885d59825b425214 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab5be852e69e8ce4f885d59825b425214">getNotScaledObjVal</a> (double val) const</td></tr>
<tr class="separator:ab5be852e69e8ce4f885d59825b425214 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad291b60e0912a053f08bd0981244502d inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad291b60e0912a053f08bd0981244502d">getPartitionNum</a> () const</td></tr>
<tr class="separator:ad291b60e0912a053f08bd0981244502d inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cad4021fc1fb67c4dd0290b51f099d6 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1cad4021fc1fb67c4dd0290b51f099d6">getLPItNum</a> () const</td></tr>
<tr class="separator:a1cad4021fc1fb67c4dd0290b51f099d6 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811a70fe6c1839a2378815f19468cc08 inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a811a70fe6c1839a2378815f19468cc08">getDegItNum</a> () const</td></tr>
<tr class="separator:a811a70fe6c1839a2378815f19468cc08 inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aee610537e542da711336710937131e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3aee610537e542da711336710937131e">infoMessage</a> (const char *msg, int level=0)</td></tr>
<tr class="separator:a3aee610537e542da711336710937131e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f873f131cfe55c8e9df25eca7b43b inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a633f873f131cfe55c8e9df25eca7b43b">lpInfo</a> (const char *method, const char *time, int itNum, int degItNum, double objVal)</td></tr>
<tr class="separator:a633f873f131cfe55c8e9df25eca7b43b inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d8af63bdc483cc78628d591ff5f90e inherit pro_methods_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac1d8af63bdc483cc78628d591ff5f90e">STRBR_estimateObjDecrease</a> (double lowerBound, int maxItNum)</td></tr>
<tr class="separator:ac1d8af63bdc483cc78628d591ff5f90e inherit pro_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a947b55db79ad1cb039daf0d7ccb25bf6"><td class="memItemLeft" align="right" valign="top"><a id="a947b55db79ad1cb039daf0d7ccb25bf6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CTree</b></td></tr>
<tr class="separator:a947b55db79ad1cb039daf0d7ccb25bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4873f34061ba9472894c3d324e83c4"><td class="memItemLeft" align="right" valign="top"><a id="adf4873f34061ba9472894c3d324e83c4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CImpl</b></td></tr>
<tr class="separator:adf4873f34061ba9472894c3d324e83c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc8e0ec8b1f0639c46fcddb468634ae"><td class="memItemLeft" align="right" valign="top"><a id="a1cc8e0ec8b1f0639c46fcddb468634ae"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CAUT</b></td></tr>
<tr class="separator:a1cc8e0ec8b1f0639c46fcddb468634ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classCLP')"><img src="closed.png" alt="-"/>&#160;Data Fields inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:a5a6d9c16c926728d109d9fc34fbd4245 inherit pub_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5a6d9c16c926728d109d9fc34fbd4245">m_sWarningMsg</a> [256]</td></tr>
<tr class="memdesc:a5a6d9c16c926728d109d9fc34fbd4245 inherit pub_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character array for using as message strings.  <a href="classCLP.html#a5a6d9c16c926728d109d9fc34fbd4245">More...</a><br /></td></tr>
<tr class="separator:a5a6d9c16c926728d109d9fc34fbd4245 inherit pub_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5aaf8a2deb3a8c6380dd8b2794bc0 inherit pub_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a27f5aaf8a2deb3a8c6380dd8b2794bc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a27f5aaf8a2deb3a8c6380dd8b2794bc0">m_bPrimeFeasible</a></td></tr>
<tr class="memdesc:a27f5aaf8a2deb3a8c6380dd8b2794bc0 inherit pub_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, the current basic solution is prime feasible. <br /></td></tr>
<tr class="separator:a27f5aaf8a2deb3a8c6380dd8b2794bc0 inherit pub_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c1f5196e7d2d16acffe6f27ed63ff8 inherit pub_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a36c1f5196e7d2d16acffe6f27ed63ff8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a36c1f5196e7d2d16acffe6f27ed63ff8">m_bDualFeasible</a></td></tr>
<tr class="memdesc:a36c1f5196e7d2d16acffe6f27ed63ff8 inherit pub_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, the current basic solution is dual feasible. <br /></td></tr>
<tr class="separator:a36c1f5196e7d2d16acffe6f27ed63ff8 inherit pub_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef37bdd66600918cc1bb08ea500660a5 inherit pub_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aef37bdd66600918cc1bb08ea500660a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aef37bdd66600918cc1bb08ea500660a5">m_bRowNorm</a></td></tr>
<tr class="memdesc:aef37bdd66600918cc1bb08ea500660a5 inherit pub_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, <code>m_dpNorm[i]</code> is the norm of <code>m_ipBasicRow[i]</code> in the current basis <br /></td></tr>
<tr class="separator:aef37bdd66600918cc1bb08ea500660a5 inherit pub_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e15dd25a2c5580df88289f4e3b89a8 inherit pub_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a17e15dd25a2c5580df88289f4e3b89a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a17e15dd25a2c5580df88289f4e3b89a8">m_bColNorm</a></td></tr>
<tr class="memdesc:a17e15dd25a2c5580df88289f4e3b89a8 inherit pub_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, <code>m_dpNorm[i]</code> is the norm of <code>i</code>-th non-basic row. <br /></td></tr>
<tr class="separator:a17e15dd25a2c5580df88289f4e3b89a8 inherit pub_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classCLP')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:acbcd9ecf00ad8658d570dd803b0aabe3 inherit pub_static_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acbcd9ecf00ad8658d570dd803b0aabe3">INF</a> =1.0e+20</td></tr>
<tr class="memdesc:acbcd9ecf00ad8658d570dd803b0aabe3 inherit pub_static_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">default value of infinity.  <a href="classCLP.html#acbcd9ecf00ad8658d570dd803b0aabe3">More...</a><br /></td></tr>
<tr class="separator:acbcd9ecf00ad8658d570dd803b0aabe3 inherit pub_static_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921256fa400b2cdb6c5008bf189aa7a8 inherit pub_static_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a921256fa400b2cdb6c5008bf189aa7a8">VAR_INF</a> =1.0e+12</td></tr>
<tr class="memdesc:a921256fa400b2cdb6c5008bf189aa7a8 inherit pub_static_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">default value of infinity for variables.  <a href="classCLP.html#a921256fa400b2cdb6c5008bf189aa7a8">More...</a><br /></td></tr>
<tr class="separator:a921256fa400b2cdb6c5008bf189aa7a8 inherit pub_static_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f1d2167504fa29b777f6b88259803d inherit pub_static_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa9f1d2167504fa29b777f6b88259803d">MAX_BIG_M</a> =1.0e+20</td></tr>
<tr class="memdesc:aa9f1d2167504fa29b777f6b88259803d inherit pub_static_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">default value for big <code>M</code> used in the one phase implementation of the prime simplex algorithm.  <a href="classCLP.html#aa9f1d2167504fa29b777f6b88259803d">More...</a><br /></td></tr>
<tr class="separator:aa9f1d2167504fa29b777f6b88259803d inherit pub_static_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc0df6ea9e3d6ede8c252b9d67b0d4a inherit pub_static_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8bc0df6ea9e3d6ede8c252b9d67b0d4a">SHIFT</a> =0x40000000</td></tr>
<tr class="memdesc:a8bc0df6ea9e3d6ede8c252b9d67b0d4a inherit pub_static_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals to (std::numeric_limits&lt;int&gt;::max() &gt;&gt; 1).  <a href="classCLP.html#a8bc0df6ea9e3d6ede8c252b9d67b0d4a">More...</a><br /></td></tr>
<tr class="separator:a8bc0df6ea9e3d6ede8c252b9d67b0d4a inherit pub_static_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa854c8728a5654b1844419dd2cb5b7c8 inherit pub_static_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aa854c8728a5654b1844419dd2cb5b7c8"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa854c8728a5654b1844419dd2cb5b7c8">msgNoSolution</a> []</td></tr>
<tr class="memdesc:aa854c8728a5654b1844419dd2cb5b7c8 inherit pub_static_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant string for no-solution message. <br /></td></tr>
<tr class="separator:aa854c8728a5654b1844419dd2cb5b7c8 inherit pub_static_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classCLP')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:a75b5306fe2f902f31ce3d368aa1ba14f inherit pro_static_methods_classCLP"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a75b5306fe2f902f31ce3d368aa1ba14f">GCD</a> (double a, double b)</td></tr>
<tr class="separator:a75b5306fe2f902f31ce3d368aa1ba14f inherit pro_static_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1fe3f4410af3413f07297d2930c142 inherit pro_static_methods_classCLP"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aee1fe3f4410af3413f07297d2930c142">modInv</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> a, <a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> m)</td></tr>
<tr class="separator:aee1fe3f4410af3413f07297d2930c142 inherit pro_static_methods_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classCLP"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classCLP')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classCLP.html">CLP</a></td></tr>
<tr class="memitem:a8b5f7c2e56e6ff229d6768c960107792 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a8b5f7c2e56e6ff229d6768c960107792"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8b5f7c2e56e6ff229d6768c960107792">m_iThread</a></td></tr>
<tr class="memdesc:a8b5f7c2e56e6ff229d6768c960107792 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a thread in a multi-threaded MIP-application. <br /></td></tr>
<tr class="separator:a8b5f7c2e56e6ff229d6768c960107792 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60763e772c634000fd63fdab5b77942d inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a60763e772c634000fd63fdab5b77942d"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60763e772c634000fd63fdab5b77942d">m_strProblemName</a> [32]</td></tr>
<tr class="memdesc:a60763e772c634000fd63fdab5b77942d inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores problem name. <br /></td></tr>
<tr class="separator:a60763e772c634000fd63fdab5b77942d inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b5998c291b14964f472f569da4d59c inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ac4b5998c291b14964f472f569da4d59c"></a>
std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac4b5998c291b14964f472f569da4d59c">m_pLogStream</a></td></tr>
<tr class="memdesc:ac4b5998c291b14964f472f569da4d59c inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOG file. <br /></td></tr>
<tr class="separator:ac4b5998c291b14964f472f569da4d59c inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f7d6e938f1b4a1dc51b386bfe6457f inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a72f7d6e938f1b4a1dc51b386bfe6457f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a72f7d6e938f1b4a1dc51b386bfe6457f">m_bSense</a></td></tr>
<tr class="memdesc:a72f7d6e938f1b4a1dc51b386bfe6457f inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objective sense: if <code>true</code> - maximize, if <code>false</code> - minimize. <br /></td></tr>
<tr class="separator:a72f7d6e938f1b4a1dc51b386bfe6457f inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7953644c5b1f45524141bce781d0a6 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aaf7953644c5b1f45524141bce781d0a6">m_iState</a></td></tr>
<tr class="separator:aaf7953644c5b1f45524141bce781d0a6 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6a5c813dbf43e1d52c91fe53b595ab inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aaa6a5c813dbf43e1d52c91fe53b595ab">m_iS</a></td></tr>
<tr class="memdesc:aaa6a5c813dbf43e1d52c91fe53b595ab inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a state of the last LP solved.  <a href="classCLP.html#aaa6a5c813dbf43e1d52c91fe53b595ab">More...</a><br /></td></tr>
<tr class="separator:aaa6a5c813dbf43e1d52c91fe53b595ab inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25af32c327f27ddc37b545b684b1648c inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a25af32c327f27ddc37b545b684b1648c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a25af32c327f27ddc37b545b684b1648c">m_iN</a></td></tr>
<tr class="memdesc:a25af32c327f27ddc37b545b684b1648c inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of variables in the currently processed LP. <br /></td></tr>
<tr class="separator:a25af32c327f27ddc37b545b684b1648c inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fd87707ca8fee20e2bcfa16bc8a472 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a60fd87707ca8fee20e2bcfa16bc8a472"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60fd87707ca8fee20e2bcfa16bc8a472">m_iN0</a></td></tr>
<tr class="memdesc:a60fd87707ca8fee20e2bcfa16bc8a472 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of variables in the root LP; if columns are generated, <code>m_iN0 &lt;= m_iN</code>. <br /></td></tr>
<tr class="separator:a60fd87707ca8fee20e2bcfa16bc8a472 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63be14e1c20432ed14e6eef4a05c3ab5 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a63be14e1c20432ed14e6eef4a05c3ab5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a63be14e1c20432ed14e6eef4a05c3ab5">m_iNmax</a></td></tr>
<tr class="memdesc:a63be14e1c20432ed14e6eef4a05c3ab5 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of variables. <br /></td></tr>
<tr class="separator:a63be14e1c20432ed14e6eef4a05c3ab5 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f06b19b6118f2fe4d6738378e0d9d inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ab80f06b19b6118f2fe4d6738378e0d9d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab80f06b19b6118f2fe4d6738378e0d9d">m_iM</a></td></tr>
<tr class="memdesc:ab80f06b19b6118f2fe4d6738378e0d9d inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of constraints in the currently processed LP. <br /></td></tr>
<tr class="separator:ab80f06b19b6118f2fe4d6738378e0d9d inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814cf77a7bc8afa14067072039c57d74 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a814cf77a7bc8afa14067072039c57d74"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a814cf77a7bc8afa14067072039c57d74">m_iM0</a></td></tr>
<tr class="memdesc:a814cf77a7bc8afa14067072039c57d74 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of constraints in the root LP; if rows (cuts) are generated, <code>m_iM0 &lt;= m_iM</code>. <br /></td></tr>
<tr class="separator:a814cf77a7bc8afa14067072039c57d74 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63a7c7ed4a5ca7f2101addf51d340f9 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad63a7c7ed4a5ca7f2101addf51d340f9">m_iMmax</a></td></tr>
<tr class="memdesc:ad63a7c7ed4a5ca7f2101addf51d340f9 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of constraints.  <a href="classCLP.html#ad63a7c7ed4a5ca7f2101addf51d340f9">More...</a><br /></td></tr>
<tr class="separator:ad63a7c7ed4a5ca7f2101addf51d340f9 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cbde24ca42fcc1037d85f07f33b19e inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a76cbde24ca42fcc1037d85f07f33b19e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a76cbde24ca42fcc1037d85f07f33b19e">m_iNZ</a></td></tr>
<tr class="memdesc:a76cbde24ca42fcc1037d85f07f33b19e inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzero entries in the currently processed matrix. <br /></td></tr>
<tr class="separator:a76cbde24ca42fcc1037d85f07f33b19e inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac294d872173aa963637137e49fb10bf2 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ac294d872173aa963637137e49fb10bf2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac294d872173aa963637137e49fb10bf2">m_iNZ0</a></td></tr>
<tr class="memdesc:ac294d872173aa963637137e49fb10bf2 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzero entries in the root LP matrix. <br /></td></tr>
<tr class="separator:ac294d872173aa963637137e49fb10bf2 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60913419a10a2601b7f070aed76015b1 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60913419a10a2601b7f070aed76015b1">m_iNZmax</a></td></tr>
<tr class="memdesc:a60913419a10a2601b7f070aed76015b1 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of entries.  <a href="classCLP.html#a60913419a10a2601b7f070aed76015b1">More...</a><br /></td></tr>
<tr class="separator:a60913419a10a2601b7f070aed76015b1 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd5da42d59717f1534c3f2a6ce6d8ed inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a3dd5da42d59717f1534c3f2a6ce6d8ed"></a>
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">enAlign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3dd5da42d59717f1534c3f2a6ce6d8ed">m_iAlign</a></td></tr>
<tr class="memdesc:a3dd5da42d59717f1534c3f2a6ce6d8ed inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how matrix entries are listed. <br /></td></tr>
<tr class="separator:a3dd5da42d59717f1534c3f2a6ce6d8ed inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af090a53877a7aeeb727300ccfcc6d94e inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af090a53877a7aeeb727300ccfcc6d94e">m_iObjScaleExp</a></td></tr>
<tr class="memdesc:af090a53877a7aeeb727300ccfcc6d94e inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">objective scaling factor.  <a href="classCLP.html#af090a53877a7aeeb727300ccfcc6d94e">More...</a><br /></td></tr>
<tr class="separator:af090a53877a7aeeb727300ccfcc6d94e inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93c3fc14884e838e6328920c7f6448e inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ae93c3fc14884e838e6328920c7f6448e"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae93c3fc14884e838e6328920c7f6448e">m_dpC</a></td></tr>
<tr class="memdesc:ae93c3fc14884e838e6328920c7f6448e inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost vector, array of size <code>m_iNmax</code>. <br /></td></tr>
<tr class="separator:ae93c3fc14884e838e6328920c7f6448e inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120dd7b29e4a02f0edf3eea60af6a2e1 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a120dd7b29e4a02f0edf3eea60af6a2e1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a120dd7b29e4a02f0edf3eea60af6a2e1">m_dpC0</a></td></tr>
<tr class="memdesc:a120dd7b29e4a02f0edf3eea60af6a2e1 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to stored objective vector. To prevent cycling, <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code> perturbs the objective; <code>m_dpC0</code> is used to restore the original objective. <br /></td></tr>
<tr class="separator:a120dd7b29e4a02f0edf3eea60af6a2e1 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a933977c2361e2360df3bb9d448db37 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4a933977c2361e2360df3bb9d448db37">m_dpB</a></td></tr>
<tr class="memdesc:a4a933977c2361e2360df3bb9d448db37 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">left and right hand sides of constraints.  <a href="classCLP.html#a4a933977c2361e2360df3bb9d448db37">More...</a><br /></td></tr>
<tr class="separator:a4a933977c2361e2360df3bb9d448db37 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8735dcf46c1ca6e4f37d0634c78342 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ace8735dcf46c1ca6e4f37d0634c78342"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ace8735dcf46c1ca6e4f37d0634c78342">m_dpD</a></td></tr>
<tr class="memdesc:ace8735dcf46c1ca6e4f37d0634c78342 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower and upper bounds of variables. <br /></td></tr>
<tr class="separator:ace8735dcf46c1ca6e4f37d0634c78342 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0784e3d47802aad24840672c9a4cd7 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aac0784e3d47802aad24840672c9a4cd7"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aac0784e3d47802aad24840672c9a4cd7">m_ipPrevColEntry</a></td></tr>
<tr class="memdesc:aac0784e3d47802aad24840672c9a4cd7 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipPrevColEntry[j]</code> is the entry in column <code>m_ipCol[j]</code> preceding entry <code>j</code>. <br /></td></tr>
<tr class="separator:aac0784e3d47802aad24840672c9a4cd7 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d075c2be48dc6b0aa64967d54583220 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a0d075c2be48dc6b0aa64967d54583220"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0d075c2be48dc6b0aa64967d54583220">m_ipPrevRowEntry</a></td></tr>
<tr class="memdesc:a0d075c2be48dc6b0aa64967d54583220 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipPrevRowEntry[j]</code> is the entry in row <code>m_ipRow[j]</code> preceding entry <code>j</code>. <br /></td></tr>
<tr class="separator:a0d075c2be48dc6b0aa64967d54583220 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1e71b44043192cf3e74c3ec9f9e06 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aa2d1e71b44043192cf3e74c3ec9f9e06"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa2d1e71b44043192cf3e74c3ec9f9e06">m_ipRow</a></td></tr>
<tr class="memdesc:aa2d1e71b44043192cf3e74c3ec9f9e06 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipRow[j]</code> is row index of entry <code>j</code>. <br /></td></tr>
<tr class="separator:aa2d1e71b44043192cf3e74c3ec9f9e06 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af517ac42acc4c149076aab9765759210 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="af517ac42acc4c149076aab9765759210"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af517ac42acc4c149076aab9765759210">m_ipCol</a></td></tr>
<tr class="memdesc:af517ac42acc4c149076aab9765759210 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipCol[j]</code> is column index of entry <code>j</code>. <br /></td></tr>
<tr class="separator:af517ac42acc4c149076aab9765759210 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4618967508a06f46e5bfe2e2221f5dd9 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a4618967508a06f46e5bfe2e2221f5dd9"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4618967508a06f46e5bfe2e2221f5dd9">m_dpVal</a></td></tr>
<tr class="memdesc:a4618967508a06f46e5bfe2e2221f5dd9 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_dpVal[j]</code> is coefficient for entry <code>j</code>. <br /></td></tr>
<tr class="separator:a4618967508a06f46e5bfe2e2221f5dd9 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36958ccba70e68da5c1e73a8bc8aad25 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a36958ccba70e68da5c1e73a8bc8aad25"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a36958ccba70e68da5c1e73a8bc8aad25">m_ipLastRowEntry</a></td></tr>
<tr class="memdesc:a36958ccba70e68da5c1e73a8bc8aad25 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iMmax</code>, <code>m_ipLastRowEntry[i]</code> starts the linked list of entries in row <code>i</code>. <br /></td></tr>
<tr class="separator:a36958ccba70e68da5c1e73a8bc8aad25 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89405f9b533ac5f20f21a7c47bce336 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ac89405f9b533ac5f20f21a7c47bce336"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac89405f9b533ac5f20f21a7c47bce336">m_ipRowSize</a></td></tr>
<tr class="memdesc:ac89405f9b533ac5f20f21a7c47bce336 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iMmax</code>, <code>m_ipRowSize[i]</code> is number of entries in row <code>i</code>. <br /></td></tr>
<tr class="separator:ac89405f9b533ac5f20f21a7c47bce336 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11832a0463a436f527cc319597198e1 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="af11832a0463a436f527cc319597198e1"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af11832a0463a436f527cc319597198e1">m_ipLastColEntry</a></td></tr>
<tr class="memdesc:af11832a0463a436f527cc319597198e1 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNmax</code>, <code>m_ipLastColEntry[i]</code> starts the linked list of entries in column <code>i</code>. <br /></td></tr>
<tr class="separator:af11832a0463a436f527cc319597198e1 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6f14513019232c1c65cd0ae6e51e1 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ad3d6f14513019232c1c65cd0ae6e51e1"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad3d6f14513019232c1c65cd0ae6e51e1">m_ipColSize</a></td></tr>
<tr class="memdesc:ad3d6f14513019232c1c65cd0ae6e51e1 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipColSize[i]</code> is number of entries in column <code>i</code>. <br /></td></tr>
<tr class="separator:ad3d6f14513019232c1c65cd0ae6e51e1 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b73524e19624b92f012306cc7dafcb inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">signed char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a70b73524e19624b92f012306cc7dafcb">m_cpRowScale</a></td></tr>
<tr class="memdesc:a70b73524e19624b92f012306cc7dafcb inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">row factors.  <a href="classCLP.html#a70b73524e19624b92f012306cc7dafcb">More...</a><br /></td></tr>
<tr class="separator:a70b73524e19624b92f012306cc7dafcb inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14d891f81497d3a31f6f1f9b734c134 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">signed char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac14d891f81497d3a31f6f1f9b734c134">m_cpColScale</a></td></tr>
<tr class="memdesc:ac14d891f81497d3a31f6f1f9b734c134 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">column factors.  <a href="classCLP.html#ac14d891f81497d3a31f6f1f9b734c134">More...</a><br /></td></tr>
<tr class="separator:ac14d891f81497d3a31f6f1f9b734c134 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb7d1b7e39c81ac444918c5fc0881f inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a81eb7d1b7e39c81ac444918c5fc0881f">m_ipRowHd</a></td></tr>
<tr class="memdesc:a81eb7d1b7e39c81ac444918c5fc0881f inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">row handles.  <a href="classCLP.html#a81eb7d1b7e39c81ac444918c5fc0881f">More...</a><br /></td></tr>
<tr class="separator:a81eb7d1b7e39c81ac444918c5fc0881f inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0a7058459b5d9e59394e5620ebcdda inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acd0a7058459b5d9e59394e5620ebcdda">m_ipColHd</a></td></tr>
<tr class="memdesc:acd0a7058459b5d9e59394e5620ebcdda inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">column handles.  <a href="classCLP.html#acd0a7058459b5d9e59394e5620ebcdda">More...</a><br /></td></tr>
<tr class="separator:acd0a7058459b5d9e59394e5620ebcdda inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0505305247f3bc5762990010d0645c58 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0505305247f3bc5762990010d0645c58">m_ipVarType</a></td></tr>
<tr class="memdesc:a0505305247f3bc5762990010d0645c58 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">types of variables.  <a href="classCLP.html#a0505305247f3bc5762990010d0645c58">More...</a><br /></td></tr>
<tr class="separator:a0505305247f3bc5762990010d0645c58 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ad613a157f4931a769199ea1ccba9c inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac3ad613a157f4931a769199ea1ccba9c">m_ipCtrType</a></td></tr>
<tr class="memdesc:ac3ad613a157f4931a769199ea1ccba9c inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">constraint types.  <a href="classCLP.html#ac3ad613a157f4931a769199ea1ccba9c">More...</a><br /></td></tr>
<tr class="separator:ac3ad613a157f4931a769199ea1ccba9c inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21df2d76f49c7588ac116b9a79d0d71 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ab21df2d76f49c7588ac116b9a79d0d71"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab21df2d76f49c7588ac116b9a79d0d71">m_dZeroEntry</a></td></tr>
<tr class="memdesc:ab21df2d76f49c7588ac116b9a79d0d71 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">all numbers that are less than <code>m_dZeroEntry</code> are treated as zeroes. <br /></td></tr>
<tr class="separator:ab21df2d76f49c7588ac116b9a79d0d71 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fd13cbc419c481c38f09a9a8b234db inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a52fd13cbc419c481c38f09a9a8b234db"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a52fd13cbc419c481c38f09a9a8b234db">m_dVarInf</a></td></tr>
<tr class="memdesc:a52fd13cbc419c481c38f09a9a8b234db inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>-m_dVarInf &lt;= x[j] &lt;= m_dVarInf</code>, default value is <code><a class="el" href="classCLP.html#a921256fa400b2cdb6c5008bf189aa7a8" title="default value of infinity for variables.">CLP::VAR_INF</a>=1.0e+12</code>. <br /></td></tr>
<tr class="separator:a52fd13cbc419c481c38f09a9a8b234db inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb103b64297bd6cf28ee7fa50d32fa48 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aeb103b64297bd6cf28ee7fa50d32fa48"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeb103b64297bd6cf28ee7fa50d32fa48">m_dCtrTol</a></td></tr>
<tr class="memdesc:aeb103b64297bd6cf28ee7fa50d32fa48 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for constraints. <br /></td></tr>
<tr class="separator:aeb103b64297bd6cf28ee7fa50d32fa48 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c000d1bd8bc51c7872e33ca11fa7686 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a0c000d1bd8bc51c7872e33ca11fa7686"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0c000d1bd8bc51c7872e33ca11fa7686">m_dVarTol</a></td></tr>
<tr class="memdesc:a0c000d1bd8bc51c7872e33ca11fa7686 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for variables. <br /></td></tr>
<tr class="separator:a0c000d1bd8bc51c7872e33ca11fa7686 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d431fa624d05fde00e75d793e74dd9 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ab6d431fa624d05fde00e75d793e74dd9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab6d431fa624d05fde00e75d793e74dd9">m_dShadowPriceTol</a></td></tr>
<tr class="memdesc:ab6d431fa624d05fde00e75d793e74dd9 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for shadow prices (dual variables). <br /></td></tr>
<tr class="separator:ab6d431fa624d05fde00e75d793e74dd9 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13b134629f365286becda3397120a15 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="af13b134629f365286becda3397120a15"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af13b134629f365286becda3397120a15">m_dRedCostTol</a></td></tr>
<tr class="memdesc:af13b134629f365286becda3397120a15 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for reduced costs. <br /></td></tr>
<tr class="separator:af13b134629f365286becda3397120a15 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21faebf3aca5e76c26162dcc6f7af10 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="af21faebf3aca5e76c26162dcc6f7af10"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af21faebf3aca5e76c26162dcc6f7af10">m_dFixedCost</a></td></tr>
<tr class="memdesc:af21faebf3aca5e76c26162dcc6f7af10 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total cost of all variables fixed during preprocessing. <br /></td></tr>
<tr class="separator:af21faebf3aca5e76c26162dcc6f7af10 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a4c907971c3140868db8a99830bafc inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ad6a4c907971c3140868db8a99830bafc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad6a4c907971c3140868db8a99830bafc">m_dObjFactor</a></td></tr>
<tr class="memdesc:ad6a4c907971c3140868db8a99830bafc inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original objective was divided by m_dObjFactor;. <br /></td></tr>
<tr class="separator:ad6a4c907971c3140868db8a99830bafc inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4ede14bcdeb44ff803c44cc2e37ef inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aa6d4ede14bcdeb44ff803c44cc2e37ef"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa6d4ede14bcdeb44ff803c44cc2e37ef">m_dBasicVarCost</a></td></tr>
<tr class="memdesc:aa6d4ede14bcdeb44ff803c44cc2e37ef inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total cost of basic variables. <br /></td></tr>
<tr class="separator:aa6d4ede14bcdeb44ff803c44cc2e37ef inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c79e4dd452b61c4d80fc05d29c9c69 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a49c79e4dd452b61c4d80fc05d29c9c69"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a49c79e4dd452b61c4d80fc05d29c9c69">m_dObjVal</a></td></tr>
<tr class="memdesc:a49c79e4dd452b61c4d80fc05d29c9c69 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current value of the objective. <br /></td></tr>
<tr class="separator:a49c79e4dd452b61c4d80fc05d29c9c69 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16e5422603adf31dcc8fe6e946b3735 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ae16e5422603adf31dcc8fe6e946b3735"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae16e5422603adf31dcc8fe6e946b3735">m_dpX</a></td></tr>
<tr class="memdesc:ae16e5422603adf31dcc8fe6e946b3735 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime solution; array of size <code>m_iMmax</code>. <br /></td></tr>
<tr class="separator:ae16e5422603adf31dcc8fe6e946b3735 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedabe5376d21b4b511bdcd03a980e3fe inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aedabe5376d21b4b511bdcd03a980e3fe"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aedabe5376d21b4b511bdcd03a980e3fe">m_dpPi</a></td></tr>
<tr class="memdesc:aedabe5376d21b4b511bdcd03a980e3fe inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual solution (potentials), array of size <code>m_iNmax</code>. <br /></td></tr>
<tr class="separator:aedabe5376d21b4b511bdcd03a980e3fe inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54abac0d68019e329bd6cc684ebcd05 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="af54abac0d68019e329bd6cc684ebcd05"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af54abac0d68019e329bd6cc684ebcd05">m_dpUd</a></td></tr>
<tr class="memdesc:af54abac0d68019e329bd6cc684ebcd05 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>m_iNmax</code>. <br /></td></tr>
<tr class="separator:af54abac0d68019e329bd6cc684ebcd05 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95b1ea11a1eb67618d7439f7aa0022 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="adf95b1ea11a1eb67618d7439f7aa0022"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adf95b1ea11a1eb67618d7439f7aa0022">m_dpUb</a></td></tr>
<tr class="memdesc:adf95b1ea11a1eb67618d7439f7aa0022 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>m_iMmax</code>. <br /></td></tr>
<tr class="separator:adf95b1ea11a1eb67618d7439f7aa0022 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb819eb1c693514af99250dc539dddde inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aeb819eb1c693514af99250dc539dddde"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeb819eb1c693514af99250dc539dddde">m_ipArray</a></td></tr>
<tr class="memdesc:aeb819eb1c693514af99250dc539dddde inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size max{<code>m_iNmax,m_iMmax</code>}. <br /></td></tr>
<tr class="separator:aeb819eb1c693514af99250dc539dddde inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18035b5a7afb286429309ac7bf5e891 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ac18035b5a7afb286429309ac7bf5e891"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac18035b5a7afb286429309ac7bf5e891">m_dpArray</a></td></tr>
<tr class="memdesc:ac18035b5a7afb286429309ac7bf5e891 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>m_iMmax+m_iNmax</code> <br /></td></tr>
<tr class="separator:ac18035b5a7afb286429309ac7bf5e891 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda3beaf46e6502f563596b9b18e0b5c inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aeda3beaf46e6502f563596b9b18e0b5c"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeda3beaf46e6502f563596b9b18e0b5c">m_dpW</a></td></tr>
<tr class="memdesc:aeda3beaf46e6502f563596b9b18e0b5c inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>2*m_iMmax</code> <br /></td></tr>
<tr class="separator:aeda3beaf46e6502f563596b9b18e0b5c inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b96d180aada982ac9509c6cb50f114 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a29b96d180aada982ac9509c6cb50f114"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a29b96d180aada982ac9509c6cb50f114">m_dpFd</a></td></tr>
<tr class="memdesc:a29b96d180aada982ac9509c6cb50f114 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size max{<code>2*m_iNmax</code>}, this array may be freely used in user defined cut or column generating procedures. <br /></td></tr>
<tr class="separator:a29b96d180aada982ac9509c6cb50f114 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71711b97d43dd4803e2c75033905fb30 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a71711b97d43dd4803e2c75033905fb30"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a71711b97d43dd4803e2c75033905fb30">m_ipFd</a></td></tr>
<tr class="memdesc:a71711b97d43dd4803e2c75033905fb30 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array that shares memory with &lsquo;m_dpFd&rsquo;. <br /></td></tr>
<tr class="separator:a71711b97d43dd4803e2c75033905fb30 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e68dbc786c90e43be5fcad0154274 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ae38e68dbc786c90e43be5fcad0154274"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae38e68dbc786c90e43be5fcad0154274">m_dpFb</a></td></tr>
<tr class="memdesc:ae38e68dbc786c90e43be5fcad0154274 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>max{2*m_iMax,m_iNmax}</code>, this array may be freely used in user defined cut or column generating procedures. <br /></td></tr>
<tr class="separator:ae38e68dbc786c90e43be5fcad0154274 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f23a7edca7c9542be3158f05d59cfd inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa9f23a7edca7c9542be3158f05d59cfd">m_dpNorm</a></td></tr>
<tr class="memdesc:aa9f23a7edca7c9542be3158f05d59cfd inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">row or column norms in the current basis.  <a href="classCLP.html#aa9f23a7edca7c9542be3158f05d59cfd">More...</a><br /></td></tr>
<tr class="separator:aa9f23a7edca7c9542be3158f05d59cfd inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683b03d53603fec9f8bb3e0800f697f0 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a683b03d53603fec9f8bb3e0800f697f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a683b03d53603fec9f8bb3e0800f697f0">m_iBasisSize</a></td></tr>
<tr class="memdesc:a683b03d53603fec9f8bb3e0800f697f0 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nontrivial (b1 &lt;= Ax &lt;= b2) inequalities in the basis. <br /></td></tr>
<tr class="separator:a683b03d53603fec9f8bb3e0800f697f0 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23ed97c6887b059d2066950213df2e5 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae23ed97c6887b059d2066950213df2e5">m_ipBasicRow</a></td></tr>
<tr class="memdesc:ae23ed97c6887b059d2066950213df2e5 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of basic rows.  <a href="classCLP.html#ae23ed97c6887b059d2066950213df2e5">More...</a><br /></td></tr>
<tr class="separator:ae23ed97c6887b059d2066950213df2e5 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac6fb5c88b7e46c5df16aff64fe75c7 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2ac6fb5c88b7e46c5df16aff64fe75c7">m_ipRowMap</a></td></tr>
<tr class="separator:a2ac6fb5c88b7e46c5df16aff64fe75c7 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e4edaf1625342659a98a2ba97514c2 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="aa0e4edaf1625342659a98a2ba97514c2"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa0e4edaf1625342659a98a2ba97514c2">m_ipBasicColumn</a></td></tr>
<tr class="memdesc:aa0e4edaf1625342659a98a2ba97514c2 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of basic columns. <br /></td></tr>
<tr class="separator:aa0e4edaf1625342659a98a2ba97514c2 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40da01358a5856facd1f09ae37a30b3e inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a40da01358a5856facd1f09ae37a30b3e">m_ipColMap</a></td></tr>
<tr class="separator:a40da01358a5856facd1f09ae37a30b3e inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fcbe1d95a832210b0f0e5d86df78bb inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a24fcbe1d95a832210b0f0e5d86df78bb"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a24fcbe1d95a832210b0f0e5d86df78bb">m_dpBeta</a></td></tr>
<tr class="memdesc:a24fcbe1d95a832210b0f0e5d86df78bb inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">values of non-basic rows, the value of row <code>i</code> is A_ix. <br /></td></tr>
<tr class="separator:a24fcbe1d95a832210b0f0e5d86df78bb inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6a79711fc48cbf193ded2444bb381 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a6ae6a79711fc48cbf193ded2444bb381"></a>
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6ae6a79711fc48cbf193ded2444bb381">m_eDefLPmethod</a></td></tr>
<tr class="memdesc:a6ae6a79711fc48cbf193ded2444bb381 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP method to solve the root LP. <br /></td></tr>
<tr class="separator:a6ae6a79711fc48cbf193ded2444bb381 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5320d1ef11c1b15e977377e21c2b4f8f inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a5320d1ef11c1b15e977377e21c2b4f8f"></a>
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5320d1ef11c1b15e977377e21c2b4f8f">m_eLPmethod</a></td></tr>
<tr class="memdesc:a5320d1ef11c1b15e977377e21c2b4f8f inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">currently used LP method. <br /></td></tr>
<tr class="separator:a5320d1ef11c1b15e977377e21c2b4f8f inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec180e2e7d3217a7e10de6bbdc3a1d9 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a8ec180e2e7d3217a7e10de6bbdc3a1d9"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8ec180e2e7d3217a7e10de6bbdc3a1d9">m_uRowColGenRule</a></td></tr>
<tr class="memdesc:a8ec180e2e7d3217a7e10de6bbdc3a1d9 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitwise OR of the members of <code>enRowColGenRule</code>; by default, all flags are set to <code>1</code>. <br /></td></tr>
<tr class="separator:a8ec180e2e7d3217a7e10de6bbdc3a1d9 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0091e586c5494aaf315cd888a272d69 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ae0091e586c5494aaf315cd888a272d69"></a>
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae0091e586c5494aaf315cd888a272d69">m_eSepRule</a></td></tr>
<tr class="memdesc:ae0091e586c5494aaf315cd888a272d69 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">currently used separation rule. <br /></td></tr>
<tr class="separator:ae0091e586c5494aaf315cd888a272d69 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956dade3f7dc89a9eac2dc4e78839fb inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a9956dade3f7dc89a9eac2dc4e78839fb"></a>
<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9956dade3f7dc89a9eac2dc4e78839fb">m_ePricingRule</a></td></tr>
<tr class="memdesc:a9956dade3f7dc89a9eac2dc4e78839fb inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">currently used pricing rule. <br /></td></tr>
<tr class="separator:a9956dade3f7dc89a9eac2dc4e78839fb inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaa7b865b5dd74040a394fc75bf82c2 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a2eaa7b865b5dd74040a394fc75bf82c2"></a>
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2eaa7b865b5dd74040a394fc75bf82c2">m_eLpSepRule</a></td></tr>
<tr class="memdesc:a2eaa7b865b5dd74040a394fc75bf82c2 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">separation rule used for solving pure LPs as well as root LPs when solving MIPs. <br /></td></tr>
<tr class="separator:a2eaa7b865b5dd74040a394fc75bf82c2 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2e7d8f12feb9b9733c39a85ccbd5b inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a17e2e7d8f12feb9b9733c39a85ccbd5b"></a>
<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a17e2e7d8f12feb9b9733c39a85ccbd5b">m_eLpPricingRule</a></td></tr>
<tr class="memdesc:a17e2e7d8f12feb9b9733c39a85ccbd5b inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">pricing rule used for solving pure LPs as well as root LPs when solving MIPs. <br /></td></tr>
<tr class="separator:a17e2e7d8f12feb9b9733c39a85ccbd5b inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cd21a6ec2235b331ec6028d4fc0796 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a78cd21a6ec2235b331ec6028d4fc0796"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a78cd21a6ec2235b331ec6028d4fc0796">m_iPreproc</a></td></tr>
<tr class="memdesc:a78cd21a6ec2235b331ec6028d4fc0796 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code> preprocessing is on; default value is <code>true</code>. <br /></td></tr>
<tr class="separator:a78cd21a6ec2235b331ec6028d4fc0796 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab88d3ae9edeb713cf10c5e902b3d8b inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a1ab88d3ae9edeb713cf10c5e902b3d8b"></a>
CPrepStack *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1ab88d3ae9edeb713cf10c5e902b3d8b">m_pPrepStack</a></td></tr>
<tr class="memdesc:a1ab88d3ae9edeb713cf10c5e902b3d8b inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the preprocessing stack. <br /></td></tr>
<tr class="separator:a1ab88d3ae9edeb713cf10c5e902b3d8b inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02c276e8722797060de6ce60c584603 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac02c276e8722797060de6ce60c584603">m_iUpdatePrimeSol</a></td></tr>
<tr class="memdesc:ac02c276e8722797060de6ce60c584603 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of modified bounds of non-basic variables.  <a href="classCLP.html#ac02c276e8722797060de6ce60c584603">More...</a><br /></td></tr>
<tr class="separator:ac02c276e8722797060de6ce60c584603 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0c15b9fea34f0c6b2c35daf355e6e inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="ab1c0c15b9fea34f0c6b2c35daf355e6e"></a>
CLU *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab1c0c15b9fea34f0c6b2c35daf355e6e">m_pLU</a></td></tr>
<tr class="memdesc:ab1c0c15b9fea34f0c6b2c35daf355e6e inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an object of class CLU, that solves linear systems. <br /></td></tr>
<tr class="separator:ab1c0c15b9fea34f0c6b2c35daf355e6e inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15c88aa7b438465151ddf272299b81 inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="adc15c88aa7b438465151ddf272299b81"></a>
<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adc15c88aa7b438465151ddf272299b81">m_lStartTime</a></td></tr>
<tr class="memdesc:adc15c88aa7b438465151ddf272299b81 inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start time of solving problem. <br /></td></tr>
<tr class="separator:adc15c88aa7b438465151ddf272299b81 inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a280474af48da416e332e4b3b12aa inherit pro_attribs_classCLP"><td class="memItemLeft" align="right" valign="top"><a id="a323a280474af48da416e332e4b3b12aa"></a>
<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a323a280474af48da416e332e4b3b12aa">m_lSolTime</a></td></tr>
<tr class="memdesc:a323a280474af48da416e332e4b3b12aa inherit pro_attribs_classCLP"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution time. <br /></td></tr>
<tr class="separator:a323a280474af48da416e332e4b3b12aa inherit pro_attribs_classCLP"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> has been designed for solving Mixed Integer Programs (MIPs) </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} &amp; c^Tx \to \max,\\ &amp; b_1 \le Ax \le b_2,\\ &amp; l \le x \le u,\\ &amp; x_i\in\mathbb{Z}\quad\forall\; i\in I, \end{align*}" src="form_303.png"/>
</p>
<p> by the branch-and-cut or branch-and-price method.</p>
<p><b>Examples</b> of how to use <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> class:</p><ul>
<li><a class="el" href="primer.html">MIPCL Primer</a>;</li>
<li><a class="el" href="fcnf.html">Fixed Charge Network Flows</a>;</li>
<li><a class="el" href="infLP.html">Why does an LP have no solution?</a>;</li>
<li><a class="el" href="subgraph.html">Connected subgraphs</a>;</li>
<li><a class="el" href="MSched.html">Scheduling one machine (User Branching)</a>;</li>
<li><a class="el" href="gap.html">Generalized assignment problem</a>;</li>
<li><a class="el" href="tsp.html">Traveling salesman problem</a> </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae5b975320472b5fb8fbdd4269387012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b975320472b5fb8fbdd4269387012e">&#9670;&nbsp;</a></span>enBranchRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012e">CMIP::enBranchRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Branching rules. </p>
<p>For each integer-valued variable <img class="formulaInl" alt="$j$" src="form_304.png"/> with fractional value <img class="formulaInl" alt="$x_j$" src="form_77.png"/>, we estimate from below</p><ul>
<li><img class="formulaInl" alt="$\lambda^{\mathrm{down}}_j$" src="form_305.png"/>: decrease of the objective if we branch by this variable down;</li>
<li><img class="formulaInl" alt="$\lambda^{\mathrm{up}}_j$" src="form_306.png"/>: decrease of the objective if we branch by this variable up.</li>
</ul>
<p>Then we compute the score <img class="formulaInl" alt="$\lambda_j$" src="form_307.png"/> as a function of <img class="formulaInl" alt="$\lambda^{\mathrm{down}}_j\text{ and } \lambda^{\mathrm{up}}_j$" src="form_308.png"/>, say, <img class="formulaInl" alt="$\lambda_j=\lambda^{\mathrm{down}}_j \cdot \lambda^{\mathrm{up}}_j$" src="form_309.png"/>, or <img class="formulaInl" alt="$\lambda_j=\min{\lambda^{\mathrm{down}}_j,\lambda^{\mathrm{up}}_j}$" src="form_310.png"/>. A variable <img class="formulaInl" alt="$j^*$" src="form_311.png"/> with maximum score is selected for doing branching. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae5b975320472b5fb8fbdd4269387012ea88b647fd0ac9c572310d382c48f12e9d"></a>STRONG_BR&#160;</td><td class="fielddoc"><p>Strong branching (default strategy). </p>
<p>A candidate set of fractional variables is selected; for every candidate <img class="formulaInl" alt="$x_j$" src="form_77.png"/>, for each of 2 branches a fixed number (approximately 10) of dual iterates are performed and the decrease of the objective value is fixed; the product of these two decreases is the score. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae5b975320472b5fb8fbdd4269387012ea8d5340d688c46d8433f563f3e27c6e2f"></a>MAX_SCORE&#160;</td><td class="fielddoc"><p>Score branching. </p>
<p>Let <img class="formulaInl" alt="$\lambda^{\mathrm{down}}_j$" src="form_305.png"/> (resp., <img class="formulaInl" alt="$\lambda^{\mathrm{up}}_j$" src="form_306.png"/>) be the decrease of the objective after performing one dual iterate; the minimum of these two decreases is the score. </p>
</td></tr>
</table>

</div>
</div>
<a id="af376f7257f718501639a17f9ac0e44fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af376f7257f718501639a17f9ac0e44fa">&#9670;&nbsp;</a></span>enCtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa">CMIP::enCtrType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIP types of constraints. </p>
<p>The type of a constraint is the bitwise OR of the members of two enumerations <a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5" title="LP types of constraints.">CLP::enCtrType</a> and <a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa" title="MIP types of constraints.">CMIP::enCtrType</a>. A constraint is of a particular type if it can be transformed to that type by complementing some binary variables. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa35908d1b46af1db5beac2afda8ab0443"></a>CTR_LOCAL&#160;</td><td class="fielddoc"><p>The constraint is <em>local</em> for node being processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa267dcabdd7dc4f41568926f889c78834"></a>CTR_INT_VARS&#160;</td><td class="fielddoc"><p>All variables and coefficients are integral in this constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa521403a776c48d87365dbde76f965ced"></a>CTR_INT_COEFF&#160;</td><td class="fielddoc"><p>All coefficients are integral in this constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faaa85c6252ffd40b0868c7fcee80680bf6"></a>CTR_INT&#160;</td><td class="fielddoc"><p>The constraint with all variables and coefficients being integral. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa7c534f91d259b798737681c8ffcce176"></a>CTR_VAR&#160;</td><td class="fielddoc"><p><em>Variable bound</em>, i.e. <img class="formulaInl" alt="$z_i \le (\ge) a_jx_j +b,\quad z_i\in\mathbb{R},\; x_j\in \{0,1\}$" src="form_322.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa0cb55d55ce364d7fdb844f6dae6329d1"></a>CTR_BINPACK&#160;</td><td class="fielddoc"><p><em>Bin packing</em>, i.e., <img class="formulaInl" alt="$\sum_{i\in I} a_i x_i + a_j x_j \le a_j,\quad j\not\in I, x_j\in\{0,1\},\; x_i\in\{0,1\}\;\forall\: i\in I$" src="form_323.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa53d2704d65bc36d4e97200da08886908"></a>CTR_KNAPSACK&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} a_i x_i \le b,\quad x_i\in\{0,1\}\;\forall\: i\in I$" src="form_324.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faac8b20b9e1cd38e68ca22106b14b1230e"></a>CTR_MX_KNAPSACK&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} a_i x_i + \sum_{j\in J} q_j z_j \le b,\quad x_i\in\{0,1\}\;\forall\: i\in I$" src="form_325.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa31bf0a7a42fc21b4fe4968c7273dcae7"></a>CTR_PACKING&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} x_i \le 1,\quad x_i\in\{0,1\}\;\forall\: i\in I$" src="form_326.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faaed432778f21bc50db9a1a4188a2566dd"></a>CTR_INV_KNAPSACK&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} x_i \le b,\quad x_i\in \{0,1\}\;\forall\: i\in I$" src="form_327.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faaca34092df8bd6211bccd9bd48c149cc8"></a>CTR_COVERING&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} x_i \ge 1,\quad x_i\in\{0,1\}\;\forall\: i\in I$" src="form_328.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa92003ad7d22f0d30a1c5fc490181c3eb"></a>CTR_CARDINALITY&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} x_i \le k,\quad x_i\in\{0,1\}\;\forall\: i\in I$" src="form_329.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa6ba88b6a9073807f328549410f72830c"></a>CTR_GUB&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} x_i \le 1,\quad x_i\in\{0,1\}\;\forall\: i\in I$" src="form_326.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faad3fe8c4fc08dc8e88dba26b9d3616301"></a>CTR_SOS1&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} z_i \le (=) 1,\quad z_i \ge 0\;\forall\: i\in I \text{ and only one } z_i \text{ takes non-zero value} $" src="form_330.png"/>. </p>
<p>A <b>SOS1</b>-constraint is a <b>GUB</b>-constraint (of type <code>CTR_GUB</code>) such that a) all its variables are present in exactly the same other constraints, and b) in any of those constraints, if we list the coefficients of SOS1-variables in the order these variables are present in the base SOS1-constraint, we get an increasing or decreasing sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faac75afc03827aa23fd4de17c4709ebb2d"></a>CTR_SOS2&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} z_i \le (=) 1,\quad z_i \ge 0\;\forall\: i\in I,\text{ and if } z_i&gt; 0,\: z_j&gt;0, \text{ then } |i-j| = 1$" src="form_331.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faadbc9d352261997c3fd5f593b8d1afeed"></a>CTR_01FLOW&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} a_i z_i \le (=) b,\quad 0\le z_i \le \alpha_ix_i +\beta_i \text{ with } x_i\in \{0,1\},\; i\in I$" src="form_332.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa9a263ebfc8abf4a62d47039085bd6e20"></a>CTR_WITH_VAR_BOUNDS&#160;</td><td class="fielddoc"><p><img class="formulaInl" alt="$\sum_{i\in I} a_i z_i \le (=) b,\quad 0\le z_i \le a_ix_i +b_i \text{ with } x_i\in\{0,1\},\; i\in J\subset I$" src="form_333.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa119b93713f932e4e840f9013ad54a917"></a>CTR_WITH_UNIQUE&#160;</td><td class="fielddoc"><p>Any constraint with only one non-binary variable. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa006d51c9b93668064e5f5bfe8f155612"></a>CTR_PARITY&#160;</td><td class="fielddoc"><p>Any integer constraint with more than two odd coefficients. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa5de7f272abe121f28889c80c47899f49"></a>CTR_MX_01&#160;</td><td class="fielddoc"><p>The constraint has binary and non-binary variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa7d426fae269a3e39a06f0850edccaac6"></a>CTR_MX_INT&#160;</td><td class="fielddoc"><p>The constraint has integer and non-integer variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa709798502a1e5a80fb7f1125960005d3"></a>CTR_GEN&#160;</td><td class="fielddoc"><p>All other constraints (currently not used). </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faae089e9d7fd1b8477aabfd2fe998d668b"></a>CTR_NOT_INV&#160;</td><td class="fielddoc"><p>Not all absolute coefficient values are ones. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faae82bbd707aa61770ac144fd4a66fd617"></a>CTR_BRANCHING_INV&#160;</td><td class="fielddoc"><p>Invariant knapsack used in balancing branching. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faaa19ce6f174c3e604c53691da1cf96306"></a>CTR_WITH_DEP_BINS&#160;</td><td class="fielddoc"><p>There are implication relations, <img class="formulaInl" alt="$x_i=a\; \Rightarrow\; x_j=b,\; (a,b \in \{0,1\}$" src="form_334.png"/>), between their binary variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa480931fb76d027def1865726a54c90bf"></a>CTR_IN_POOL&#160;</td><td class="fielddoc"><p>The constraint is stored in pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faae91595a30db12719b37362eae12229fb"></a>CTR_LB_UNBOUNDED&#160;</td><td class="fielddoc"><p>The flag is <em>privately</em> used in preprocessing subroutines. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faaccbede0c0280c6776777b5703e3f63f2"></a>CTR_UB_UNBOUNDED&#160;</td><td class="fielddoc"><p>The flag is <em>privately</em> used in preprocessing subroutines. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa2f5b437914f56a60c96e5a343dc3d68e"></a>CTR_OBJ&#160;</td><td class="fielddoc"><p>The constraint represents the objective, its lhs and rhs are lower and upper bounds on the optimal objective value. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faad1a0c96a86d30fcfe854d689674c1237"></a>CTR_BINARY&#160;</td><td class="fielddoc"><p>All variables are binaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa6d9c88d15e4ad3471db9ba20646ff6b1"></a>CTR_MIR&#160;</td><td class="fielddoc"><p>The constraint includes integer variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa1994a0fd29ad8b3a3e8c49c30062365f"></a>CTR_FULLY_CLASSIFIED&#160;</td><td class="fielddoc"><p>Mask of all fully classified constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="af376f7257f718501639a17f9ac0e44faa4d2981c59898d32ea96b50bc3023366f"></a>CTR_CLASSIFIED&#160;</td><td class="fielddoc"><p>Mask of automatically assigning flags. </p>
</td></tr>
</table>

</div>
</div>
<a id="a811eee6c5be7e08f960b81b915903f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811eee6c5be7e08f960b81b915903f51">&#9670;&nbsp;</a></span>enCutType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">CMIP::enCutType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cut types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a99737be7316cf6a64792502118a5db49"></a>CUT_TYPE_NUM&#160;</td><td class="fielddoc"><p>Number of cut types (classes). </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51abaded67558f828ac94b136f333c857b6"></a>_CLICK&#160;</td><td class="fielddoc"><p>Click cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51adcb2fb5aaf88f239cabff4a16025e222"></a>_KNAPSACK&#160;</td><td class="fielddoc"><p>Cuts generated for knapsack constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a35d5989046e08d403e2bdd6ee1ba2c60"></a>_MX_KNAPSACK&#160;</td><td class="fielddoc"><p>Generalized cover cuts generated for mixed-knapsacks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51abb52ac6410dfa6d09091679cf36a99e8"></a>_MIR&#160;</td><td class="fielddoc"><p>Mixed-Integer-Rounding (MIR) cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a4e6e15f790aa2fead31d18d3061d2121"></a>_FLOW_COVER&#160;</td><td class="fielddoc"><p>Flow-cover cuts generated by 0,1-flow constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a96de701f910454927407881df4e4bae6"></a>_SPARSE_MOD2&#160;</td><td class="fielddoc"><p>Sparse (0,1/2)-Chvatal-Gomory (mod2) cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51ac258411021659473e3f6ee340cef1fb1"></a>_DENSE_MOD2&#160;</td><td class="fielddoc"><p>Dense (0,1/2)-Chvatal-Gomory (mod2) cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51af1d8f5b9b895b0400a9502c1fcdb14cc"></a>_SPARSE_GOMORY&#160;</td><td class="fielddoc"><p>Sparse mixed-integer Gomory cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51acc1bd08d03c2f45089e7045eca97d2c2"></a>_DENSE_GOMORY&#160;</td><td class="fielddoc"><p>Dense mixed-integer Gomory cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a23d4152710b226279f0178a6ebdbb08b"></a>_PARITY&#160;</td><td class="fielddoc"><p>Parity cuts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51ac253ae251b45243b4f836a86189be248"></a>_VAR_BOUND&#160;</td><td class="fielddoc"><p>Implied variable bounds. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51ab04954a20b550af33565ed3b7c3f84de"></a>_SIMPLE_DJ&#160;</td><td class="fielddoc"><p>Simple disjunctions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a6e3169701a722108fe0e1603c097b7be"></a>_USER_DEF&#160;</td><td class="fielddoc"><p>Cuts generated in user procedures <code>saparate()</code>, <a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a><code>, and <a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a811eee6c5be7e08f960b81b915903f51a2f7a5fe95afea24d320bd88f5de6acaa"></a>CUTS_TO_POOL&#160;</td><td class="fielddoc"><p>The mask of cuts send to the pool. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2394ed0f7beb2a12444f132a7eab2572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2394ed0f7beb2a12444f132a7eab2572">&#9670;&nbsp;</a></span>enRoundType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">CMIP::enRoundType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounding rules. </p>
<p>Specifies all possible values of m_eRoundType, which determines how non-integral solutions are rounded. if m_eRoundType != ROUND_NONE, at each node, an optimal solution is rounding in hope to get a feasible solution. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2394ed0f7beb2a12444f132a7eab2572a59b58433a95682c6a846b0097f4f2e50"></a>ROUND_NONE&#160;</td><td class="fielddoc"><p>None of rounding procedures is called. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2394ed0f7beb2a12444f132a7eab2572aa822662f72823e61cd6e0801fc5a819b"></a>ROUND_OFF&#160;</td><td class="fielddoc"><p>Round off values of all integral variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2394ed0f7beb2a12444f132a7eab2572a975785e0d00b7cf5ea4de85c27bcc8db"></a>ROUND_DOWN&#160;</td><td class="fielddoc"><p>Round down values of all integral variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2394ed0f7beb2a12444f132a7eab2572aefb1ffd5caf6a30247b0bd1af4af8ff8"></a>ROUND_UP&#160;</td><td class="fielddoc"><p>Round up values of all integral variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2394ed0f7beb2a12444f132a7eab2572a52f5b7c1ac584c52f3360b7423fd1286"></a>ROUND_USER&#160;</td><td class="fielddoc"><p>User defined procedure is called for rounding integer variables. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab867a6a47fb83f4d984b7f3442364044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab867a6a47fb83f4d984b7f3442364044">&#9670;&nbsp;</a></span>enRowColGenRule2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCMIP.html#ab867a6a47fb83f4d984b7f3442364044">CMIP::enRowColGenRule2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extension of <code>enRowColGenRule</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab867a6a47fb83f4d984b7f3442364044a70b92ce675e1f9b4d2e55ba4e5c0416e"></a>GEN1_PROC&#160;</td><td class="fielddoc"><p>If <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code> has been overloaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab867a6a47fb83f4d984b7f3442364044ab87f3cee60cb9285159a78beaff3b89e"></a>GEN2_PROC&#160;</td><td class="fielddoc"><p>If <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code> has been overloaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab867a6a47fb83f4d984b7f3442364044a32eb18230d33f54ebd8a3682d8233f0e"></a>STOP_AUTO_CUTS&#160;</td><td class="fielddoc"><p>If the flag is set, generation of auto cuts is stopped. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab867a6a47fb83f4d984b7f3442364044aede6ed455518715ffa44fdb00f5aed53"></a>WITH_AUTO_CUTS&#160;</td><td class="fielddoc"><p><code>autoCuts()</code> was not called at the previous call to <code>generateCuts()</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab867a6a47fb83f4d984b7f3442364044a0d4d867e7b3edbecaa7d60f0266d9bdb"></a>NO_SOLVER_DECISIONS&#160;</td><td class="fielddoc"><p>If user resets any parameter affecting cut generation, <em>MIPCL</em> does not change standard settings of all parameter affecting cut generation. </p>
</td></tr>
</table>

</div>
</div>
<a id="a70cd164e97628571f7d774472a1e2c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cd164e97628571f7d774472a1e2c92">&#9670;&nbsp;</a></span>enVarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92">CMIP::enVarType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIP types of variables. </p>
<p>The type of a variable is the bitwise OR of the members of two enumerations, <code><a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627" title="LP types of variables.">CLP::enVarType</a></code> and <code><a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92" title="MIP types of variables.">CMIP::enVarType</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92ab5dfcb211c4819d366c25dd0e4a56a65"></a>VAR_BIN&#160;</td><td class="fielddoc"><p>Binary variable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a518e7a36ebcf2977d775b4696ffec8f8"></a>VAR_4_INT&#160;</td><td class="fielddoc"><p>Both bounds, lower and upper, are in [0,15]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a4621f50af165f42bf8ce3aad39f04aed"></a>VAR_8_INT&#160;</td><td class="fielddoc"><p>Both bounds, lower and upper, are in [0,255]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a667ce0c9c3579f13c5b1ca8659c6250c"></a>VAR_IN_VAR_LB&#160;</td><td class="fielddoc"><p>The non-binary variable occurs in some lower variable bound constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a631f6ad805812377ed0c49193c493fd6"></a>VAR_0_IN_VAR_CTR&#160;</td><td class="fielddoc"><p>If binary variable is set to <code>0</code>, then some variable bound constraint becomes a restriction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a6ea3f4544166057b2e776633c441e1b4"></a>VAR_IN_VAR_UB&#160;</td><td class="fielddoc"><p>The variable occurs in some upper variable bound constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a4994cf072954654a80da9e6f4ef55ed2"></a>VAR_1_IN_VAR_CTR&#160;</td><td class="fielddoc"><p>If the binary variable is set to <code>1</code>, then some variable bound constraint becomes a restriction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92af3004f227d58b7c1ed029881d4b25d97"></a>VAR_IN_VAR_CTR&#160;</td><td class="fielddoc"><p>The variable occurs in either lower, or upper variable bound constraint. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa7c534f91d259b798737681c8ffcce176" title="Variable bound, i.e. .">CTR_VAR</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92af7d2048da43730b29b5abf90af662181"></a>VAR_IN_GUB&#160;</td><td class="fielddoc"><p>The variable occurs in <em>GUB</em> constraints, which are cardinality packing constraints. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa31bf0a7a42fc21b4fe4968c7273dcae7" title=".">CTR_PACKING</a> and <a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa92003ad7d22f0d30a1c5fc490181c3eb" title=".">CTR_CARDINALITY</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a7b87472eea419a78ae0fb1d58b186728"></a>VAR_IN_PACKING&#160;</td><td class="fielddoc"><p>The variable occurs in <em>packing</em> constraints. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa31bf0a7a42fc21b4fe4968c7273dcae7" title=".">CTR_PACKING</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92ae0703d97b963923b264a2f044a04d24c"></a>VAR_UNIQUE&#160;</td><td class="fielddoc"><p>The non-binary variable that occurs in constraints which all other variables are binary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92acbf05c12f2c4bb9e531c4f4d0d99a859"></a>VAR_MON_UP&#160;</td><td class="fielddoc"><p>The variable can be increased up to its upper bound without violating feasibility. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a37032a742081244d6d881cad9c2ac2f5"></a>VAR_MON_DOWN&#160;</td><td class="fielddoc"><p>The variable can be decreased up to its lower bound without violating feasibility. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92af35bd0e227833cc438b46b4d7a62888c"></a>VAR_MONOTONE&#160;</td><td class="fielddoc"><p>The variable is monotone down or up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a925000c8908ddf99423d5a344493ca77"></a>VAR_BINPACK&#160;</td><td class="fielddoc"><p>The variable occurs in <em>bin-packing</em> constraint (currently is not used). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faa0cb55d55ce364d7fdb844f6dae6329d1" title="Bin packing, i.e., .">CTR_BINPACK</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a072e81fe33895815cea2c62254e34ef5"></a>VAR_IN_POOL&#160;</td><td class="fielddoc"><p>The column corresponding to this variable is stored in the pool. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a5dbd6dab1a084bd055f9d6ff0495f465"></a>VAR_SOS&#160;</td><td class="fielddoc"><p>The variable occurs in a <em>SOS1</em> or <em>SOS2</em> constraint. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faad3fe8c4fc08dc8e88dba26b9d3616301" title=".">CTR_SOS1</a>, <a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44faac75afc03827aa23fd4de17c4709ebb2d" title=".">CTR_SOS2</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92aec67bac21d7e1b3cb3640fe9cb260b9b"></a>VAR_CLASSIFIED&#160;</td><td class="fielddoc"><p>mask of automatically assigned flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a9738e26aaaa83e9b549867c5a3b29ed0"></a>VAR_PRI_MIN&#160;</td><td class="fielddoc"><p>The priority of any variable is an integer from <code>VAR_PRI_MIN</code> to <code>VAR_PRI_MAX</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a70cd164e97628571f7d774472a1e2c92a16c559a2b894103d6e267e9f25bf7d1c"></a>VAR_PRI_MAX&#160;</td><td class="fielddoc"><p>The priority of any variable is an integer from <code>VAR_MIN_PRI</code> to <code>VAR_MAX_PRI</code>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0565b27e1966ceb19380a4d3d7bcec5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0565b27e1966ceb19380a4d3d7bcec5a">&#9670;&nbsp;</a></span>CMIP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMIP::CMIP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor initializes an "empty" <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> object and sets the problem name to <code>name</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>problem name of no more than '30' characters; if <code>name==0</code>, problem name will be a featureless "LP". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa30befe3b11b8199abae19c7d9824d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30befe3b11b8199abae19c7d9824d85">&#9670;&nbsp;</a></span>CMIP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMIP::CMIP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCMIP.html">CMIP</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone constructor. </p>
<pre class="fragment">It is  used in multithreaded applications.
The cloned object shares many members with the object being cloned.
\param[in] other reference to a `CMIP` object being cloned;
\param[in]  thread thread-index.
</pre> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;CMemoryException&lt;/tt&gt;</td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c7398f71012d27f00d10db22b6b458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7398f71012d27f00d10db22b6b458b">&#9670;&nbsp;</a></span>addCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::addCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVarScaled</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function adds a new cut to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of the constraint,<ul>
<li>if <code>hd &gt;= 0</code>, you must overload getRow function;</li>
<li>if <code>hd == -1</code>, the constraint is added to the pool immediately;</li>
<li>if <code>hd &lt; -1</code> (most common option), the constraint is added to the pool if it is tight (holds as equality) for an optimal LP solution; </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of the constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b1,b2</td><td>left hand side (LHS) and right hand side (RHS), respectively; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of nonzero entries; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>sz</code>, <code>dpVal[i]</code> is coefficient in column <code>ipCol[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVarScaled</td><td>is <code>true</code> if cut is written in scaled variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>the constraint has been already scaled (multiplied) by <code>2^{factor}</code>, if <code>factor==NOT_SCALED</code>, <b>MIPCL</b> will scale this constraint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>if <code>n &gt; m_iN</code>, then <code>n</code> is the number of variables in the original (non-preprocessed) problem; in this case the constraint must be preprocessed; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the newly created constraint. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1604c7b6dbaf45be61c6b35c40099241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1604c7b6dbaf45be61c6b35c40099241">&#9670;&nbsp;</a></span>areCutsSentToPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::areCutsSentToPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if cuts of type <code>cutType</code> are immediately sent to the pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, <a class="el" href="classCMIP.html#a55f2bd9ff7223e25affc96cb5a71bd55">sendCutsToPool</a>. </dd></dl>

</div>
</div>
<a id="ac16bad8fb24b4beb74a0499c96f6dfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16bad8fb24b4beb74a0499c96f6dfd0">&#9670;&nbsp;</a></span>BranchAndCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::BranchAndCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>timeLimit</em> = <code>0l</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure creates a number of threads each of which calls <code>BranchAndCutWorker()</code> that implements the branch-and-cut/price algorithm. Each instance of BranchAndCutWorker() stops if duality (integrality) gap (i.e., difference between upper and lower bounds on the optimal objective value) is less than the value of <code>gap</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeLimit</td><td>limit on solution time (in seconds); <code>timeLimit==0l</code> means no time limitation; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>duality gap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">optimize()</a>, <a class="el" href="classCMIP.html#a8ecbfd2806b0ec9708e85e22e2649151">setDualGap()</a>. </dd></dl>

</div>
</div>
<a id="ab756898acb767ab51422d24daf075b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab756898acb767ab51422d24daf075b96">&#9670;&nbsp;</a></span>changeObjBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::changeObjBound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When a new solution is found which is better than the record solution, <code><a class="el" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">changeRecord()</a></code> procedure is called to replace the record solution for a new one. Sometimes, e.g. when an initial solution is known, it is needed to change only the bound on the objective value. In such cases, <code><a class="el" href="classCMIP.html#ab756898acb767ab51422d24daf075b96">changeObjBound()</a></code> should be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objVal</td><td>new lower (for maximization problem) or upper (for minimization problem) bound, which is usually objective value of best solution found so far. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">changeRecord()</a>. </dd></dl>

</div>
</div>
<a id="a911ab2e8695ccca2a10d6492df428d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911ab2e8695ccca2a10d6492df428d7c">&#9670;&nbsp;</a></span>changeRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::changeRecord </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The best solution found so far is called a <em>record solution</em>, and its objective value is known as a <em>record</em>, which is a <em>lower</em> or <em>upper</em> bound on the optimal objective value. The procedure is called when a new best solution is found to store it as the record solution. When solving structured problems (such as TSP), the user can overload <code><a class="el" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">changeRecord()</a></code> to store record solutions more efficiently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objVal</td><td>objective value; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpX,ipHd</td><td>solution, <code>dpX[j]</code> is value of variable with handle <code>ipHd[j]</code>, <code>j=1,...,n</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ab756898acb767ab51422d24daf075b96">changeObjBound()</a>. </dd></dl>

</div>
</div>
<a id="a33363f035bbd0ac5746cc4753886b013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33363f035bbd0ac5746cc4753886b013">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMIP.html">CMIP</a> * CMIP::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCMIP.html">CMIP</a> *&#160;</td>
          <td class="paramname"><em>pMip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The clone constructor. </p>
<p>The function clones an instance of <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMip</td><td>pointer to an instance of <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> class to be cloned; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>index from {1,2,...,__MAX_THREAD_NUM}. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5a190e3a9fea5b1ee960edf73d9fa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a190e3a9fea5b1ee960edf73d9fa66">&#9670;&nbsp;</a></span>closeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::closeMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function overloads the function of the base class <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a27e86b274e43b78732ff9f51b9249f33">CLP::closeMatrix()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a27e86b274e43b78732ff9f51b9249f33">CLP</a>.</p>

</div>
</div>
<a id="ac50aeee183a24470294ec4b32e8a079f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50aeee183a24470294ec4b32e8a079f">&#9670;&nbsp;</a></span>cutInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::cutInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>round</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fracNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cutNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After each <em>cut generating round</em> (i.e., after calling the cut generating procedure), the solver calls <code><a class="el" href="classCMIP.html#ac50aeee183a24470294ec4b32e8a079f">cutInfo()</a></code> to inform about the progress in decreasing the objective value of the relaxation LP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>time elapsed since the solution process has started; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">round</td><td>cut generating round; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objVal</td><td>objective value of the relaxation LP; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fracNum</td><td>number of integral variables taking fractional values in the current LP solution; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutNum</td><td>number of cuts generated at this particular round. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When developing an application with a GUI interface, the user may wish to overload this function. </dd></dl>

</div>
</div>
<a id="ad55ab22a22515545b2f13996904e0577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55ab22a22515545b2f13996904e0577">&#9670;&nbsp;</a></span>cutStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::cutStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After having been processed the root node, the solver prints into the standard output stream how many cuts of each type were generated, and how many of them were present in the matrix at the beginning of the next cut generating round.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When developing an application with a GUI interface, the user may wish to overload this function. </dd></dl>

</div>
</div>
<a id="a58771d3c7e8c151087e5d3944a97ac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58771d3c7e8c151087e5d3944a97ac93">&#9670;&nbsp;</a></span>delNodeLocalColumns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CMIP::delNodeLocalColumns </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that implements its own pool for storing generated columns. When a node is pruned, <code><a class="el" href="classCMIP.html#a58771d3c7e8c151087e5d3944a97ac93">delNodeLocalColumns()</a></code> is called to allow the derived class to eliminate, if necessary, all the columns that are local for node <code>nd</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>pruned node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">lockColumn()</a>, <a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">unlockColumn()</a>. </dd></dl>

</div>
</div>
<a id="a3798c5cb419733a4050e47215b178c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3798c5cb419733a4050e47215b178c48">&#9670;&nbsp;</a></span>delNodeLocalCtrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CMIP::delNodeLocalCtrs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that implements its own pool for storing generated inequalities. When a node is pruned, <code><a class="el" href="classCMIP.html#a3798c5cb419733a4050e47215b178c48">delNodeLocalCtrs()</a></code> is called to allow the derived class to eliminate, if necessary, all the constraints that are local for node <code>nd</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nd</td><td>pruned node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr()</a>, <a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr()</a>. </dd></dl>

</div>
</div>
<a id="a3af7a8fc2a88d4194ef5410c5f980e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af7a8fc2a88d4194ef5410c5f980e12">&#9670;&nbsp;</a></span>doNotUsePool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::doNotUsePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this function only in case when cuts of all types are not supposed to be generated. In such a case you can still overload <a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a>, <a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a>, and <a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a> procedures to generate problem specific constraints. In such a case, you have to overload <a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow()</a> function from the base class LP. </p>

</div>
</div>
<a id="affc325e5a1dd43d1a87cebc5857a0a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc325e5a1dd43d1a87cebc5857a0a70">&#9670;&nbsp;</a></span>extendVarType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::extendVarType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function overload the function of the base class. The functions extends the type of variable <code>j</code> by bitwise ORing its current type with the flags stored in the parameter <code>type</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>bitwise OR of members of <code>enVarType</code> and <code><a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92" title="MIP types of variables.">CMIP::enVarType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627" title="LP types of variables.">CLP::enVarType</a>, <a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92" title="MIP types of variables.">CMIP::enVarType</a>, and <code><a class="el" href="classCLP.html#ae90bf133c46fe102d2b10805f8bfdec3">CLP::extendVarType()</a></code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#ae90bf133c46fe102d2b10805f8bfdec3">CLP</a>.</p>

</div>
</div>
<a id="a9827da8d0317a1f1b546ac3421790130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9827da8d0317a1f1b546ac3421790130">&#9670;&nbsp;</a></span>genCut1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::genCut1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipColHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To generate problem specific cuts, <b>MIPCL</b> allows the user to overload any of three virtual functions: <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code> (a member of <a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a> class), <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code>, and <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>. The solver in turn calls <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code>, <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code>, its internal cut generating procedure, and then <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>. Both, <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code> and <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code> are called only if their predecessors failed to produce any cut.</p>
<p>Rule of Thumb:</p><ul>
<li><code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code> produces all the inequalities that constitute a part of the problem formulation (for example, TSP cut inequalities);</li>
<li>strong (facet defining and etc.) cuts are generated by <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code> (for example, TSP comb inequalities);</li>
<li>less stronger cuts must be generated by <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpX,ipColHd</td><td>arrays of size <code>n</code> that represent a solution to cut off; <code>dpX[i]</code> is the value of the variable with handle <code>ipColHd[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one cut has been detected </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>, <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">CLP::separate()</a></code>. </dd></dl>

</div>
</div>
<a id="a6af3635d2a8696dc3ae7b55e6006c4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af3635d2a8696dc3ae7b55e6006c4de">&#9670;&nbsp;</a></span>genCut2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::genCut2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipColHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code>, except that <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code> is called only if all the other cut generating procedures failed to produce any cut. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a>. </dd></dl>

</div>
</div>
<a id="aa3e107e66010b65ac0736cb5aa59bcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e107e66010b65ac0736cb5aa59bcca">&#9670;&nbsp;</a></span>getAbsObjTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getAbsObjTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>objective tolerance value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ac2f725a78d773cf02ced8e67a10ec67f">setAbsObjTol()</a>. </dd></dl>

</div>
</div>
<a id="a202b4cd994beec8cb31d82a70d2018c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202b4cd994beec8cb31d82a70d2018c4">&#9670;&nbsp;</a></span>getBinaryVarNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getBinaryVarNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of binary variables. </dd></dl>

</div>
</div>
<a id="aa57d0fb961fca0ec6dcce68e1af252c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57d0fb961fca0ec6dcce68e1af252c3">&#9670;&nbsp;</a></span>getBranchAndCutNodeNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getBranchAndCutNodeNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>total number of branch-and-cut nodes. </dd></dl>

</div>
</div>
<a id="a059ecd9b515d788e4f3c48a791caa6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059ecd9b515d788e4f3c48a791caa6b0">&#9670;&nbsp;</a></span>getCurrentNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getCurrentNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>index of the currently processed node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a3544f1e816f2ebf936ab4e902d028465">getCurrentNodeHeight()</a>. </dd></dl>

</div>
</div>
<a id="a3544f1e816f2ebf936ab4e902d028465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3544f1e816f2ebf936ab4e902d028465">&#9670;&nbsp;</a></span>getCurrentNodeHeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getCurrentNodeHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>height of the currently processed node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a059ecd9b515d788e4f3c48a791caa6b0">getCurrentNode()</a>. </dd></dl>

</div>
</div>
<a id="a33583b56007c47d05de26a005a993792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33583b56007c47d05de26a005a993792">&#9670;&nbsp;</a></span>getFractional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getFractional </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined prime heuristic. </p>
<pre class="fragment">The procedure selects a variable to branch on it.
\param[out] d current value of variable `j` which is return value.
\return variable `j` to split its domain into two parts, `[m_dpD[j&lt;&lt;1],d]` and `[d+1,m_dpD[(j&lt;&lt;1)+1]]`
</pre><p> if <code>j</code> is negative, then no fractional variable has been detected. </p>

</div>
</div>
<a id="ab63b4079041f615a75bfcb43ad9e674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63b4079041f615a75bfcb43ad9e674a">&#9670;&nbsp;</a></span>getIntegerVarNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getIntegerVarNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of integer variables. </dd></dl>

</div>
</div>
<a id="a089696de273ee17ef5a6097d29266d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089696de273ee17ef5a6097d29266d3c">&#9670;&nbsp;</a></span>getIntTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getIntTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>integrality tolerance. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a4e7edb32b7ba21e11aad07e4757703a1">setIntTol()</a>. </dd></dl>

</div>
</div>
<a id="a3437dbda7b181fa9d01c5ec1a98baeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3437dbda7b181fa9d01c5ec1a98baeb3">&#9670;&nbsp;</a></span>getNoOfActiveNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getNoOfActiveNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of leaves in the search tree. </dd></dl>

</div>
</div>
<a id="ab8baddc2199be1f6af77ecd291c9f659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8baddc2199be1f6af77ecd291c9f659">&#9670;&nbsp;</a></span>getObjBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getObjBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently upper bound on the objective value defined to be the largest value of the nodes LPs among all search tree leaves. </dd></dl>

</div>
</div>
<a id="a20fbbc89c2f826b79800e949979013bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fbbc89c2f826b79800e949979013bc">&#9670;&nbsp;</a></span>getObjLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getObjLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Any MIP is transformed into the form when the objective is maximized. The function returns the transformed objective value of the currently best solution. It is usually called when the problem is being solved. </p><dl class="section return"><dt>Returns</dt><dd>objective value of the best MIP solution found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a7242040205f7dfa8bf29b7d7f1acb1f8">getObjVal()</a>, <a class="el" href="classCMIP.html#a1c902f2a8553bd70f0465b9e3141005e">safeGetObjLowerBound()</a>. </dd></dl>

</div>
</div>
<a id="a7242040205f7dfa8bf29b7d7f1acb1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7242040205f7dfa8bf29b7d7f1acb1f8">&#9670;&nbsp;</a></span>getObjVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getObjVal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is usually called when the problem has been solved already. </p><dl class="section return"><dt>Returns</dt><dd>original objective value of the best MIP solution found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a20fbbc89c2f826b79800e949979013bc">getObjLowerBound()</a>, <a class="el" href="classCMIP.html#a1c902f2a8553bd70f0465b9e3141005e">safeGetObjLowerBound()</a>. </dd></dl>

</div>
</div>
<a id="a5a67bed916bee0574d519110c1456120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a67bed916bee0574d519110c1456120">&#9670;&nbsp;</a></span>getProbingDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getProbingDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of rounds when probing binary variables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ad175289865b9117fc7505c6d4e5fa28d">setProbingDepth()</a>, setProbingRoundNum(). </dd></dl>

</div>
</div>
<a id="a67130ed26ea4f8fef22909e1d0d6013e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67130ed26ea4f8fef22909e1d0d6013e">&#9670;&nbsp;</a></span>getRealVarNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getRealVarNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of real valued variables. </dd></dl>

</div>
</div>
<a id="a74c8fcbb2b4a9bda5de72679ced4cf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c8fcbb2b4a9bda5de72679ced4cf4f">&#9670;&nbsp;</a></span>getRelObjDecPerCutRoundAtNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getRelObjDecPerCutRoundAtNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>prc minimum relative decrease of the upper bound per cut round for not-root nodes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a5d0820008f5502c3d44ff063c3cfd02d">setRelObjDecPerCutRoundAtNodes()</a>. </dd></dl>

</div>
</div>
<a id="acbb24a09d08c67dd3c13e70d9e3014fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb24a09d08c67dd3c13e70d9e3014fe">&#9670;&nbsp;</a></span>getRelObjDecPerCutRoundAtRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getRelObjDecPerCutRoundAtRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>prc minimum relative decrease of the upper bound per cut round at the root node. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#aaa3582cea3c5dcaa29339562496c1b39">setRelObjDecPerCutRoundAtRoot()</a>. </dd></dl>

</div>
</div>
<a id="ada95006ce13736b0bf0b78ce263c2d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada95006ce13736b0bf0b78ce263c2d22">&#9670;&nbsp;</a></span>getRoundingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">enRoundType</a> CMIP::getRoundingType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>type (direction )of rounding fractional components. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572" title="Rounding rules.">enRoundType</a>, <a class="el" href="classCMIP.html#a4a1a5a7c0984a3417c60c75a33d721c9">setRoundingType()</a>. </dd></dl>

</div>
</div>
<a id="a0c57da801f3b302738c905583db3de67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c57da801f3b302738c905583db3de67">&#9670;&nbsp;</a></span>getSolNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getSolNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of MIP solutions found so far. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a5988aab7a8267c5735a51b3bc902cc95">safeGetSolNum()</a>. </dd></dl>

</div>
</div>
<a id="a536ace1560abb8de5c9b7941720df9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536ace1560abb8de5c9b7941720df9b4">&#9670;&nbsp;</a></span>getSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getSolution </td>
          <td>(</td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function returns two pointers to the internal <b>MIPCL</b> arrays storing the solution found so far. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpX,ipHd</td><td><code>dpX[j]</code> is the value of variable whose handle is <code>ipHd[j]</code>, <code>j=1,...,n</code>, where <code>n</code> is the return value. Do not modify the values of both arrays <code>dpX</code> and <code>ipHd</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of variables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a1636d6070c91135f68892056e59b33b4">CLP::getSolution()</a>. </dd></dl>

</div>
</div>
<a id="a245e3f9e2217153cb75862b3a3f0767a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245e3f9e2217153cb75862b3a3f0767a">&#9670;&nbsp;</a></span>getThreadIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getThreadIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In multithreaded application a separate <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> object is created for each thread. The threads share common memory, which is allocated and released by the object of thread 0. </p><dl class="section return"><dt>Returns</dt><dd>thread index of calling object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a8b5f7c2e56e6ff229d6768c960107792" title="Index of a thread in a multi-threaded MIP-application.">CLP::m_iThread</a> </dd></dl>

</div>
</div>
<a id="ab649cf1a63f09051dc7ac68f5af4f8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab649cf1a63f09051dc7ac68f5af4f8e0">&#9670;&nbsp;</a></span>getThreadNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getThreadNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of threads currently used. </dd></dl>

</div>
</div>
<a id="a64877ecd5bddd9146d300fc015df4c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64877ecd5bddd9146d300fc015df4c44">&#9670;&nbsp;</a></span>getToleranceForCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getToleranceForCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tolerance value for the cuts of type <code>cutType</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, setToleranseForCut(). </dd></dl>

</div>
</div>
<a id="a01416188eb89d46c26d0fce099797ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01416188eb89d46c26d0fce099797ff6">&#9670;&nbsp;</a></span>getUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::getUpperBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current upper bound on the optimal objective value. </dd></dl>

</div>
</div>
<a id="a1b49eced2ef53c891ef679c0432d0f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b49eced2ef53c891ef679c0432d0f79">&#9670;&nbsp;</a></span>getVarPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::getVarPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>priority of variable <code>j</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a521debeb6b0b75a3520f289cd049d9e2">setVarPriority()</a>, <a class="el" href="classCMIP.html#a9297389c022da8127e141b52fe8b4a4c">incVarPriority()</a>. </dd></dl>

</div>
</div>
<a id="a9297389c022da8127e141b52fe8b4a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9297389c022da8127e141b52fe8b4a4c">&#9670;&nbsp;</a></span>incVarPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::incVarPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function increases the priority of a given variable by a given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inc</td><td>value of increase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a521debeb6b0b75a3520f289cd049d9e2">setVarPriority()</a>, <a class="el" href="classCMIP.html#a1b49eced2ef53c891ef679c0432d0f79">getVarPriority()</a>. </dd></dl>

</div>
</div>
<a id="ad3bf1030fd521268ac03695aeb83bfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bf1030fd521268ac03695aeb83bfdd">&#9670;&nbsp;</a></span>isCtrGlobal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isCtrGlobal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constraint <code>i</code> is global; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ad146e585c3151d8858e80060ec389372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad146e585c3151d8858e80060ec389372">&#9670;&nbsp;</a></span>isCtrIntegral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isCtrIntegral </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constraint is declared as being <em>integral</em> if all its variables are integer-valued as well as all its coefficients are integers. The slack of an inequality (defined as the difference between its right and left hand sides) takes only integral value; this property may be useful in cut generating procedures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constraint <code>i</code> is integral; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a931123a832a3bcf0432ecf6fdeff6479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931123a832a3bcf0432ecf6fdeff6479">&#9670;&nbsp;</a></span>isFeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CMIP::isFeasible </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipColHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are practical applications with some requirements that are difficult to be expressed by means of inequalities. As alternative, we can implement a special branching strategy that eliminates all the solutions not valid for those difficult constraints. In such a case, we need to overload three functions: <code><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching()</a></code>, <code><a class="el" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch()</a></code>, and <code><a class="el" href="classCMIP.html#a931123a832a3bcf0432ecf6fdeff6479">isFeasible()</a></code>.</p>
<p>Any time when a new solution has been computed that satisfies all the constraints known to the solver, <code><a class="el" href="classCMIP.html#a931123a832a3bcf0432ecf6fdeff6479">isFeasible()</a></code> is called to verify whether that solution is really feasible for the problem being solved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpX,ipColHd</td><td>for <code>j=1,...,n</code>, <code>dpX[j]</code> is the value of variable with handle <code>ipColHd[j]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the solution given by <code>dpX</code> and <code>ipColHd</code> is feasible; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching()</a>, <a class="el" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch()</a>. </dd></dl>

</div>
</div>
<a id="a8ae818e90fc48a61d0e153dbd98e92ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae818e90fc48a61d0e153dbd98e92ca">&#9670;&nbsp;</a></span>isObjIntegral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isObjIntegral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The objective is <em>integral</em> if its optimal value is an integer. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the objective is integral; otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a5825362f7121939d1dd3060e50198706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5825362f7121939d1dd3060e50198706">&#9670;&nbsp;</a></span>isPureLP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isPureLP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>/return <code>true</code> if the problem being solved is an LP (has no integer variable). </p>

<p>Reimplemented from <a class="el" href="classCLP.html#a5042f6464f736fffb5321693464b8339">CLP</a>.</p>

</div>
</div>
<a id="a79a188db14fbd2a57e18729cd7376a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a188db14fbd2a57e18729cd7376a89">&#9670;&nbsp;</a></span>isSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one feasible solution has been found so far. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a8af1978cf8a498333938e780412f33e9">CLP</a>.</p>

</div>
</div>
<a id="aaf58cfeaa80ef422892f96b6cc298fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf58cfeaa80ef422892f96b6cc298fdc">&#9670;&nbsp;</a></span>isSolutionOptimal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isSolutionOptimal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First, <code><a class="el" href="classCMIP.html#a79a188db14fbd2a57e18729cd7376a89">isSolution()</a></code> is called; if it returns <code>true</code>, then we can call this function to verify whether the solution found by <b>MIPCL</b> is optimal. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code>, if an optimal solution has been found. </dd></dl>

</div>
</div>
<a id="a1a0cb171ac7845bad5a98e802671ee62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0cb171ac7845bad5a98e802671ee62">&#9670;&nbsp;</a></span>isVarLoBoundLocal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarLoBoundLocal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a not-root node, an upper bound for a variable is <em>local</em> if its value differs from that at the root node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lower bound of variable <code>j</code> is local; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#aa25a1b8ab14ae7b0a0266a7db89028f0">isVarUpBoundLocal()</a>. </dd></dl>

</div>
</div>
<a id="a91e78f58e822cc004cda1d6fcf2b2c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e78f58e822cc004cda1d6fcf2b2c61">&#9670;&nbsp;</a></span>isVarMonotone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarMonotone </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variable is <em>monotone</em> if it is either monotone up or monotone down. Usually, a monotone variable is among the last candidates for choosing it as the branching variable since it is always possible to round off such a variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is monotone; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ad6796e219e7afe777d33a62ba4a49e32">isVarMonotoneUp()</a>, <a class="el" href="classCMIP.html#a91e78f58e822cc004cda1d6fcf2b2c61">isVarMonotone()</a>. </dd></dl>

</div>
</div>
<a id="affa8b7bde9d6bbdf4cd3cc01a00a0a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa8b7bde9d6bbdf4cd3cc01a00a0a68">&#9670;&nbsp;</a></span>isVarMonotoneDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarMonotoneDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variable is <em>monotone down</em> if, given any solution of the relaxation LP, we can decrease the value of the considered variable without violating any constraint other than the lower bound of this variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is monotone down; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ad6796e219e7afe777d33a62ba4a49e32">isVarMonotoneUp()</a>, <a class="el" href="classCMIP.html#a91e78f58e822cc004cda1d6fcf2b2c61">isVarMonotone()</a>. </dd></dl>

</div>
</div>
<a id="ad6796e219e7afe777d33a62ba4a49e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6796e219e7afe777d33a62ba4a49e32">&#9670;&nbsp;</a></span>isVarMonotoneUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarMonotoneUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variable is <em>monotone up</em> if, given any solution of the relaxation LP, we can increase the value of the considered variable without violating any constraint other than the upper bound of this variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is monotone up; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#affa8b7bde9d6bbdf4cd3cc01a00a0a68">isVarMonotoneDown()</a>, <a class="el" href="classCMIP.html#a91e78f58e822cc004cda1d6fcf2b2c61">isVarMonotone()</a>. </dd></dl>

</div>
</div>
<a id="ab1ecb21cc14bdb8cdeb068c13fde435d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ecb21cc14bdb8cdeb068c13fde435d">&#9670;&nbsp;</a></span>isVarScalable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarScalable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Strong integral and SOS variables are <em>not scalable</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is <em>scalable</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ae06691ddef275b820b98471b8d8e3e19">isVarStrongIntegral()</a>, <a class="el" href="classCMIP.html#a4f82a8cfe403d1d49be43e2abbd67be8">isVarSOS()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#ae0e84d3f6fbde33cc62795e5176f2eb3">CLP</a>.</p>

</div>
</div>
<a id="a4f82a8cfe403d1d49be43e2abbd67be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f82a8cfe403d1d49be43e2abbd67be8">&#9670;&nbsp;</a></span>isVarSOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarSOS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> appears in a SOS1 or SOS2-constraint. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a89565cfb1b01944400728feca3c7d982">isVarUsedForBranching()</a>. </dd></dl>

</div>
</div>
<a id="ae06691ddef275b820b98471b8d8e3e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06691ddef275b820b98471b8d8e3e19">&#9670;&nbsp;</a></span>isVarStrongIntegral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarStrongIntegral </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using different preprocessing techniques one can deduce that some variables initially not declared as integer-valued may take only integer values. The solver declares such variables as integral (this may help the solver in generating stronger cuts) but assigns them the lowest priority to avoid branching by such variables. It worth noting, that, for technical reasons, <b>MIPCL</b> assigns to variables of the lowest priority the maximum possible priority value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is integer-valued. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a89565cfb1b01944400728feca3c7d982">isVarUsedForBranching()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#af5d0a21407f597a92d9f5924cef1714c">CLP</a>.</p>

</div>
</div>
<a id="aa25a1b8ab14ae7b0a0266a7db89028f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25a1b8ab14ae7b0a0266a7db89028f0">&#9670;&nbsp;</a></span>isVarUpBoundLocal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarUpBoundLocal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a not-root node, a lower variable bound for a variable is <em>local</em> if its value differs from that at the root node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lower bound of variable <code>j</code> is local; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a1a0cb171ac7845bad5a98e802671ee62">isVarLoBoundLocal()</a>.</dd></dl>
<p>A MIP is considered as a feasibility problem if the objective is empty or the goal is to minimize a binary variable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the problem being solved is a feasibility problem. </dd></dl>

</div>
</div>
<a id="a89565cfb1b01944400728feca3c7d982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89565cfb1b01944400728feca3c7d982">&#9670;&nbsp;</a></span>isVarUsedForBranching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::isVarUsedForBranching </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We say that a variable is <em>used for branching</em> if its lower and upper bounds may be changed during the branching process. Let us also note that real-valued variables (say, those in SOS2-constraints) can be fixed during the branching process. So, they are used for branching as well as strong integral variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> can be chosen for branching. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a89565cfb1b01944400728feca3c7d982">isVarUsedForBranching()</a>. </dd>
<dd>
<a class="el" href="classCMIP.html#ae06691ddef275b820b98471b8d8e3e19">isVarStrongIntegral()</a>, <a class="el" href="classCMIP.html#a4f82a8cfe403d1d49be43e2abbd67be8">isVarSOS()</a>, <a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a0ce3965a0ec3cd2275ce18a2045f594f">CLP</a>.</p>

</div>
</div>
<a id="ab13082b9c5de8ce176ce626b9d8853b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13082b9c5de8ce176ce626b9d8853b7">&#9670;&nbsp;</a></span>lockColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CMIP::lockColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that implements its own pool for storing generated columns. When a new node is added to the search tree, <code><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">lockColumn()</a></code> is called for any column generated by the derived class column generating procedure (i.e., <a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns()</a> unless that column was sent to the <b>MIPCL</b> pool. Properly implemented two functions, <code><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">lockColumn()</a></code>, <code><a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">unlockColumn()</a></code>, and <code><a class="el" href="classCMIP.html#a58771d3c7e8c151087e5d3944a97ac93">delNodeLocalColumns()</a></code> allow derived classes to delete, if necessary, unused columns from their pools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>column handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">unlockColumn()</a>, <a class="el" href="classCMIP.html#a58771d3c7e8c151087e5d3944a97ac93">delNodeLocalColumns()</a>. </dd></dl>

</div>
</div>
<a id="a85bd4129b916c2f5f6d3a8741ae3734d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bd4129b916c2f5f6d3a8741ae3734d">&#9670;&nbsp;</a></span>lockCtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CMIP::lockCtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that implements its own pool for storing generated inequalities. When a new node is added to the search tree, <code><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr()</a></code> is called for any constraint generated by the derived class cut generating procedures (i.e. <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code>, <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code>, and <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>) unless that constraint was sent to the <b>MIPCL</b> pool. Properly implemented two functions, <code><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr()</a></code> and <code><a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr()</a></code>, allow derived classes to delete, if necessary, unused cuts from their pools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>constraint handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr()</a>, <a class="el" href="classCMIP.html#a3798c5cb419733a4050e47215b178c48">delNodeLocalCtrs()</a>. </dd></dl>

</div>
</div>
<a id="a3a22e737dc1e04a82d66e2a62ad9a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22e737dc1e04a82d66e2a62ad9a590">&#9670;&nbsp;</a></span>mipCutInfoMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::mipCutInfoMsg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> cut-messages are to be printed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a4d462ff8a25ec8eb97bbea6409510aaa">CMIP::switchMipInfoMsg()</a> </dd></dl>

</div>
</div>
<a id="a17dc77bf42627bf7f8981ec5b2cc2de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dc77bf42627bf7f8981ec5b2cc2de6">&#9670;&nbsp;</a></span>mipInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::mipInfo </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>timeElapsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>leafNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bestObjVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>solsFound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function prints into the standard output stream a message string which describes the current state of the solution process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeElapsed</td><td>string representation of time elapsed since solution process started; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeNum</td><td>total number of nodes; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leafNum</td><td>number of leaves (non-processed nodes) in the search tree; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bestObjVal</td><td>best objective value achieved so far; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objBound</td><td>lower or upper (<code>sense=true</code>) bound on the optimal objective value; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>relative (in percents) difference between <code>bestObjVal</code> and <code>objBound</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solsFound</td><td>number of solutions found so far; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sense</td><td>if <code>true</code>, objective is maximized; otherwise, minimized; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>if <code>true</code>, the header is displayed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When developing an application with a GUI interface, the user may wish to overload this function. </dd></dl>

</div>
</div>
<a id="a72640275265c14c6984439cff9b4504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72640275265c14c6984439cff9b4504e">&#9670;&nbsp;</a></span>mipTreeInfoMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::mipTreeInfoMsg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> run time messages are to be printed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a4d462ff8a25ec8eb97bbea6409510aaa">CMIP::switchMipInfoMsg()</a> </dd></dl>

</div>
</div>
<a id="a93d43af3654fd597ed45fbebd6ddf6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d43af3654fd597ed45fbebd6ddf6d8">&#9670;&nbsp;</a></span>openMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::openMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRowGen</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bColGen</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mMax</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMax</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nzMax</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function overloads the function of the base class <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">CLP::openMatrix()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">CLP</a>.</p>

</div>
</div>
<a id="af68f591f9fb72ea0dfe2e7964c8265da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68f591f9fb72ea0dfe2e7964c8265da">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>timeLimit</em> = <code>0l</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>solFileName</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure solves the root LP, and then, if its solution is not integral, calls <code><a class="el" href="classCMIP.html#ac16bad8fb24b4beb74a0499c96f6dfd0">BranchAndCut()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeLimit</td><td>limit on solution time (in seconds); <code>timeLimit==0l</code> means no time limitation; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>integrality gap; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solFileName</td><td>pointer to string with file name for storing intermediate solutions; if <code>solFileName=0</code>, intermediate solutions are not stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#acac38ce07ce257c0a7ee44dfc12e59b4">CLP::optimize()</a>, <a class="el" href="classCMIP.html#ac16bad8fb24b4beb74a0499c96f6dfd0">BranchAndCut()</a>, <a class="el" href="classCMIP.html#a8ecbfd2806b0ec9708e85e22e2649151">setDualGap()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#acac38ce07ce257c0a7ee44dfc12e59b4">CLP</a>.</p>

</div>
</div>
<a id="a12182abf970a184aeb1dba3658f619c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12182abf970a184aeb1dba3658f619c4">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::prepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This procedure does a lot of useful things: allocates memory, applies different preprocessing techniques, scales the matrix, and so on. In many cases, we can get substantially simpler (for solving) problem, which is still equivalent to the original (user) problem. The latter means that, given an optimal solution to the transformed problem, we can easily compute an optimal solution to the original problem. </p><dl class="section return"><dt>Returns</dt><dd><code>false</code> if inconsistency has been detected; otherwise, <code>true</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a06cdbbfacf5e68b29ac174c97a392e47">CLP</a>.</p>

</div>
</div>
<a id="a91249febf036dd979f7584bc0962137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91249febf036dd979f7584bc0962137a">&#9670;&nbsp;</a></span>printSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::printSolution </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure writes MIP solutions into the file. The user can overload this function to store solutions in an appropriate way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>name of the file to store solutions; if <code>fileName=</code>0`, the solver makes up the file name by appending the extension ".sol" to the name of the problem being solved. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a1f2b66733b6e5eea018d638c4f9538ef">CLP</a>.</p>

</div>
</div>
<a id="ad90006f5ca6072e800c547d454341150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90006f5ca6072e800c547d454341150">&#9670;&nbsp;</a></span>probingInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::probingInfo </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>timeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>round</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>probeVarNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varFixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ctrTightened</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varBdAdded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>implications</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure displays preprocessing statistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeStr</td><td>string representation of time elapsed since MIPCL have been started; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">round</td><td>probing round; if <code>round &lt; 0</code>, round field should not be displayed; if <code>round==0</code>, only header is displayed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probeVarNum</td><td>number of variables having been probed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">varFixed</td><td>number of variables having been fixed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrTightened</td><td>number of constraints having been tightened; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">varBdAdded</td><td>number of new variable bounds having been added; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">implications</td><td>number of entries in implication matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0191788fe39cf446877f6bd627eeca90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0191788fe39cf446877f6bd627eeca90">&#9670;&nbsp;</a></span>propagate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::propagate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The user can overload this function to implement some problem specific propagation algorithm. To access variable bounds, one can call the following functions: <code><a class="el" href="classCLP.html#ad7842343e7840db5a2284c66428a4b70">getVarNum()</a></code>, <code>getVarHd()</code>, <code><a class="el" href="classCLP.html#a07712842e5a79726863b4a08f3e1410a">getVarLoBound()</a></code>, <code><a class="el" href="classCLP.html#a68264a2571e3f720bddb4afb2be3e8a5">getVarUpBound()</a></code>. Do not change variable bounds directly correcting values in <code>m_dpD</code>, instead, use the functions <code><a class="el" href="classCLP.html#a164c589a3f2bce353f2585f37ab5109c">setVarLoBound()</a></code>, <code><a class="el" href="classCLP.html#a4910c689baa5522fc29d77599affc2cb">setVarUpBound()</a></code>, or <code><a class="el" href="classCLP.html#a06d0fb59442b39d19e5bfc77b92a935f">setVarBounds()</a></code>. </p><dl class="section return"><dt>Returns</dt><dd><code>false</code> if inconsistency has been detected; otherwise, <code>true</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a164c589a3f2bce353f2585f37ab5109c">CLP::setVarLoBound()</a>, <a class="el" href="classCLP.html#a4910c689baa5522fc29d77599affc2cb">CLP::setVarUpBound()</a>, <a class="el" href="classCLP.html#a06d0fb59442b39d19e5bfc77b92a935f">CLP::setVarBounds()</a>. </dd></dl>

</div>
</div>
<a id="a2c3a97823fbb2c93ac23647f649485b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3a97823fbb2c93ac23647f649485b6">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function resumes the state in which the problem was before the solution procedure has started. </p>

<p>Reimplemented from <a class="el" href="classCLP.html#af2f6b96b5f6164fda355bfeb10d5ed4a">CLP</a>.</p>

</div>
</div>
<a id="aaa043fd46c50b56da7b303ed4d57da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa043fd46c50b56da7b303ed4d57da39">&#9670;&nbsp;</a></span>restoreNodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::restoreNodeData </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Taking as input the data stored by <code><a class="el" href="classCMIP.html#a996f868ad1dbd766421fa6e8c7ae2c9d">storeNodeData()</a></code>, the function must restore the node to be processed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipVal</td><td>data needed to restore the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12f1918e4566ac5b358861a4dbfd326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12f1918e4566ac5b358861a4dbfd326">&#9670;&nbsp;</a></span>roundSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CMIP::roundSolution </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>objVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ipColHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to round a non-integer solution stored in <code>dpX</code> and <code>ipColHd</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of <code>dpX</code> and <code>ipColHd</code> (number of variables); </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dpX</td><td><code>dpX[i]</code> is the value of the variable with handle <code>ipColHd[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipColHd</td><td>stores handles of the variables; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">objVal</td><td>on input, upper (for maximization problem) or lower (minimization) bound on objective value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the procedure succeeded in constructing a feasible solution ( stored in <code>dpX</code> and <code>ipColHd</code>) with objective value better than input value of <code>objVal</code>. </dd></dl>

</div>
</div>
<a id="a657eca92c7b8409105bf501334121d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657eca92c7b8409105bf501334121d05">&#9670;&nbsp;</a></span>safeAddCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::safeAddCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVarScaled</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a safer version of <code><a class="el" href="classCMIP.html#a3c7398f71012d27f00d10db22b6b458b">addCut()</a></code>. If <code>dpVal</code> and <code>ipCol</code> are references to __ MIPCL__ internal arrays such as <code>m_dpFb</code> or <code>m_ipArray</code>, memory for such arrays may be reallocated during the call to <code><a class="el" href="classCMIP.html#a3c7398f71012d27f00d10db22b6b458b">addCut()</a></code>, and, as a consequence, the pointers <code>dpVal</code> and <code>ipCol</code> becomes not valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of the constraint,<ul>
<li>if <code>hd &gt;= 0</code>, you must overload getRow function;</li>
<li>if <code>hd == -1</code>, the constraint is added to the pool immediately;</li>
<li>if <code>hd &lt; -1</code> (most common option), the constraint is added to the pool if it is tight (holds as equality) for an optimal LP solution; </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>inequality type (bitwise OR of <code>enVarType</code> members); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b1,b2</td><td>left hand side (LHS) and right hand side (RHS), respectively; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of nonzero entries; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>sz</code>, <code>dpVal[i]</code> is coefficient in column <code>ipCol[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>if <code>n &gt; m_iN</code>, then <code>n</code> is the number of variables in the original (non-preprocessed) problem; in this case the constraint must be preprocessed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVarScaled</td><td>is <code>true</code> if cut is written in scaled variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>the constraint has been already scaled (multiplied) by <code>2^{factor}</code>, if <code>factor==NOT_SCALED</code>, <b>MIPCL</b> will scale this constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the newly created constraint. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a3c7398f71012d27f00d10db22b6b458b">addCut()</a>. </dd></dl>

</div>
</div>
<a id="a1c902f2a8553bd70f0465b9e3141005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c902f2a8553bd70f0465b9e3141005e">&#9670;&nbsp;</a></span>safeGetObjLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CMIP::safeGetObjLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A thread safe version of <a class="el" href="classCMIP.html#a20fbbc89c2f826b79800e949979013bc">getObjLowerBound()</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>m_dAbsObjTol</code> plus the objective value of the best MIP solution found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a7242040205f7dfa8bf29b7d7f1acb1f8">getObjVal()</a>, <a class="el" href="classCMIP.html#a1c902f2a8553bd70f0465b9e3141005e">safeGetObjLowerBound()</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>this function locks for reading <code>m_pRecord</code>. </dd></dl>

</div>
</div>
<a id="a5988aab7a8267c5735a51b3bc902cc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5988aab7a8267c5735a51b3bc902cc95">&#9670;&nbsp;</a></span>safeGetSolNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::safeGetSolNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread safe version <a class="el" href="classCMIP.html#a0c57da801f3b302738c905583db3de67">getSolNum()</a>. </p><dl class="section return"><dt>Returns</dt><dd>number of MIP solutions found so far. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a0c57da801f3b302738c905583db3de67">getSolNum()</a>. </dd></dl>

</div>
</div>
<a id="a55f2bd9ff7223e25affc96cb5a71bd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f2bd9ff7223e25affc96cb5a71bd55">&#9670;&nbsp;</a></span>sendCutsToPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::sendCutsToPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Usually, cuts are sent to the pool if they are in the matrix when the processed subproblem is added to the search tree as a new leaf. Call this function to immediately send to the pool all newly generated cuts of type <code>cutType</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, <a class="el" href="classCMIP.html#a1604c7b6dbaf45be61c6b35c40099241">areCutsSentToPool</a>. </dd></dl>

</div>
</div>
<a id="abd245965e7a73e148149eb8c198dacb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd245965e7a73e148149eb8c198dacb4">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::serialize </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_storing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function stores into (or restores from) the stream <code>ar</code> <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> objects (all its member storing permanent data). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>reference to a stream; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_storing</td><td>if <code>true</code>, the object is written to the stream; otherwise, the object is restored from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Derived classes may overload this function to store additional information. In such a case, call first <code><a class="el" href="classCMIP.html#abd245965e7a73e148149eb8c198dacb4">serialize()</a></code> of the base class. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a2bf78b8f2562769fda19237d42f8c0da">CLP::serialize()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a2bf78b8f2562769fda19237d42f8c0da">CLP</a>.</p>

</div>
</div>
<a id="ac2f725a78d773cf02ced8e67a10ec67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f725a78d773cf02ced8e67a10ec67f">&#9670;&nbsp;</a></span>setAbsObjTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setAbsObjTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets the objective tolerance value: If the difference between the upper and lower bounds on the optimal objective value is less than the objective tolerance value, the solver returns the best solution found as a good approximate solution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#aa3e107e66010b65ac0736cb5aa59bcca">getAbsObjTol()</a>. </dd></dl>

</div>
</div>
<a id="a8b241b19aabf10c7ceacb29e14c8dfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b241b19aabf10c7ceacb29e14c8dfec">&#9670;&nbsp;</a></span>setAutoCutPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setAutoCutPattern </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The solver automatically generates cuts for first <code>m_iAutoCutNodes</code> processed nodes, and also for nodes of height less or equal than <code>m_iAutoCutNodeHeight</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeNum</td><td>number of nodes for which cuts are generated; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>cuts are generated for nodes of height <code>&lt;= height</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a15c3e1b3638bb6b2f5530695fced2204">setCutTypePattern()</a>, <a class="el" href="classCMIP.html#af2c5ca136bb8c1026feaab06b084a7f6">setAutoCutRounds()</a>. </dd></dl>

</div>
</div>
<a id="af2c5ca136bb8c1026feaab06b084a7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c5ca136bb8c1026feaab06b084a7f6">&#9670;&nbsp;</a></span>setAutoCutRounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setAutoCutRounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>At any node the solver calls cut generating procedures a restricted number of times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atRoot</td><td>at root node, solver repeatedly calls its cut generating procedure at most <code>atRoot</code> times. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atNodes</td><td>at not-root nodes, solver repeatedly calls its cut generating procedure at most <code>atNodes</code> times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a8b241b19aabf10c7ceacb29e14c8dfec">setAutoCutPattern()</a>. </dd></dl>

</div>
</div>
<a id="ac6a1572e10422013f655348ef8dbeb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a1572e10422013f655348ef8dbeb9d">&#9670;&nbsp;</a></span>setBranchingRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setBranchingRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012e">enBranchRule</a>&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets a new search rule. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>search rule to for low-height nodes; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ae5b975320472b5fb8fbdd4269387012e" title="Branching rules.">enBranchRule</a>. </dd></dl>

</div>
</div>
<a id="a612e469aee7603340f2084491b155e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612e469aee7603340f2084491b155e76">&#9670;&nbsp;</a></span>setColumnsInactive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setColumnsInactive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure is called any time a group of columns are removed from the matrix. This procedure must be overloaded in any derived class that generates columns and stores them in its own pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of columns; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipCtr</td><td>list of <code>sz</code> constraints. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a2d7c374f8854c9e143e645737bfa981f">CLP</a>.</p>

</div>
</div>
<a id="a7cf01e2b4af3a8452700f34228bf227b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf01e2b4af3a8452700f34228bf227b">&#9670;&nbsp;</a></span>setCtrCutTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setCtrCutTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>new tolerance value for cuts currently present in the matrix; only if a non-basic cut-inequality is violated by more than <code>tol</code>, then the corresponding row can be chosen as the pivot row. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad52f642c579d214dfa706ddca4abc375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52f642c579d214dfa706ddca4abc375">&#9670;&nbsp;</a></span>setCtrsInactive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setCtrsInactive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure is called any time a group of constraints (inequalities) are removed from the matrix. This procedure must be overloaded in any derived class that generates inequalities and stores them in its own pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of constraints; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipCtr</td><td>list of <code>sz</code> columns. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a2294953950b9fd61ca9b1e9d9d9893be">CLP</a>.</p>

</div>
</div>
<a id="a74d43cf4b29aad6073839da5acad5d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d43cf4b29aad6073839da5acad5d3e">&#9670;&nbsp;</a></span>setCtrTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setCtrTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ctrTol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets the tolerance value for regular (not cuts) constraints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrTol</td><td>maximum violation allowed for all constraints (excluding cuts). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a8eda3b06a9294104d19ad3fce885b007">CLP::setCtrTol()</a>, <a class="el" href="classCLP.html#aaeddcd066d467d08fb8328f7ccae88f8">CLP::getCtrTol()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classCLP.html#a8eda3b06a9294104d19ad3fce885b007">CLP</a>.</p>

</div>
</div>
<a id="a15c3e1b3638bb6b2f5530695fced2204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c3e1b3638bb6b2f5530695fced2204">&#9670;&nbsp;</a></span>setCutTypePattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setCutTypePattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The solver automatically generates cuts of type <code>cutType</code> only for first <code>m_ipCutNodes[cutType]</code> processed nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeNum</td><td>number of nodes for which cuts of type <code>cutType</code> are generated; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>cuts of type <code>i</code> are generated for nodes of height <code>&lt;= height</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, <a class="el" href="classCMIP.html#a8b241b19aabf10c7ceacb29e14c8dfec">setAutoCutPattern()</a>; </dd></dl>

</div>
</div>
<a id="a8ecbfd2806b0ec9708e85e22e2649151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecbfd2806b0ec9708e85e22e2649151">&#9670;&nbsp;</a></span>setDualGap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setDualGap </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a MIP, the difference between the optimal values of the relaxation LP and MIP itself is known as <em>duality</em> (or <em>integrality</em>) <em>gap</em>. Generating cuts and doing branching, the solver decreases this duality gap. At a particular moment, the duality gap is the difference between the current upper and lower bounds on the optimal objective value. If this current duality gap does not exceeds some limit (given by the user or computed by the solver), the solver terminates, and the best found solution is printed as a solution to the problem. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>duality gap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">optimize()</a>, <a class="el" href="classCMIP.html#ac16bad8fb24b4beb74a0499c96f6dfd0">BranchAndCut()</a>. </dd></dl>

</div>
</div>
<a id="acff45e2bff01ee9845669f94df2539f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff45e2bff01ee9845669f94df2539f3">&#9670;&nbsp;</a></span>setGomoryCutDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setGomoryCutDensity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sparsePrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>densePrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gomory cuts are considered as sparse if the number of variables in them is less than <code>sparsePrc*m_iN/100</code> (let us remember that <code>m_iN</code> is the number of all variables), and as dense if the number of variables in them is less than <code>sdensePrc*m_iN</code>. Any cut of size greater than <code>sdensePrc*m_iN/100</code> is considered as super-dense and is rejected (not generated). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsePrc</td><td>percentage (relative to the total number of variables in the problem) of variable in sparse cuts; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">densePrc</td><td>percentage of variable in dense cuts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e7edb32b7ba21e11aad07e4757703a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7edb32b7ba21e11aad07e4757703a1">&#9670;&nbsp;</a></span>setIntTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setIntTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>intTol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An integer variable is assumed to be integral if the absolute difference between its value and the nearest integer to this value is less than the integrality tolerance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intTol</td><td>new integrality tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a089696de273ee17ef5a6097d29266d3c">getIntTol()</a>. </dd></dl>

</div>
</div>
<a id="aee3a33b857f07b76fde8c2f6c107671a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3a33b857f07b76fde8c2f6c107671a">&#9670;&nbsp;</a></span>setMaxCutRoundNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMaxCutRoundNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>roundNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The solver calls the cut generating procedure for a particular cut type a limited number of times.
This function reestablishes that limit.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roundNum</td><td>number of rounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, <a class="el" href="classCMIP.html#a084044b520ec47ae6631728cf7bdead3">setMaxCutsPerRound()</a>. </dd></dl>

</div>
</div>
<a id="a4d1fbef433174ee6e7591c5be4979359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1fbef433174ee6e7591c5be4979359">&#9670;&nbsp;</a></span>setMaxCutSize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMaxCutSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeAtRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeAtNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cuts of size greater than some predefined limit are rejected. This procedure sets new limits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeAtRoot</td><td>maximum cut size at root nodes; if <code>sizeAtRoot</code> is negative, then the existing limit remains unchanged; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeAtNodes</td><td>maximum cut size at non-root nodes; if <code>sizeAtNodes</code> is negative, then the existing limit remains unchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae82bd5785a5ec7076215195671612de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82bd5785a5ec7076215195671612de1">&#9670;&nbsp;</a></span>setMaxCutSize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMaxCutSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The solver adds to the matrix as well as to the pool cuts of restricted size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>new value of maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad81c837355b4aeeed7b71425a86a1f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81c837355b4aeeed7b71425a86a1f4c">&#9670;&nbsp;</a></span>setMaxCutSize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMaxCutSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">At each cut generation round, the cut generating procedure for a particular cut type, `cutType`,
generates only those cuts which size is not greater than the value of `m_ipMaxCutSize[cutType]`.
This function sets a new limit.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>maximum cut size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>. </dd></dl>

</div>
</div>
<a id="a084044b520ec47ae6631728cf7bdead3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084044b520ec47ae6631728cf7bdead3">&#9670;&nbsp;</a></span>setMaxCutsPerRound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMaxCutsPerRound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cutNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">At each cut generation round, the cut generating procedure for a particular cut type
generates no more than a predefined number of cuts.
This function reestablishes that limit.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutNum</td><td>number of cuts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, <a class="el" href="classCMIP.html#aee3a33b857f07b76fde8c2f6c107671a">setMaxCutRoundNum()</a>. </dd></dl>

</div>
</div>
<a id="a79a23431b4ea125ffacd5dec82593a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a23431b4ea125ffacd5dec82593a30">&#9670;&nbsp;</a></span>setMinCutRounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMinCutRounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure sets minimum numbers of rounds to generate cuts at the root and not-root nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atRoot</td><td>minimum number of rounds to generate cuts at root node; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atNodes</td><td>minimum number of rounds to generate cuts at not-root nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24af606d30c50453c6d57201a4e11259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24af606d30c50453c6d57201a4e11259">&#9670;&nbsp;</a></span>setMod2CutDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setMod2CutDensity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sparsePrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>densePrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mod2-cuts (or (0,1/2)-Chvatal-Gomory cuts) are considered as sparse if the number of variables in them is less than <code>sparsePrc*m_iN/100</code> (let us remember that <code>m_iN</code> is the number of a<code>variables), and as dense if the number of variables in them is less than</code>sdensePrc*m_iN<code>. Any cut of size greater than</code>sdensePrc*m_iN/100` is considered as super-dense and is rejected (not generated). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sparsePrc</td><td>percentage (relative to the total number of variables in the problem) of variable in sparse cuts; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">densePrc</td><td>percentage of variable in dense cuts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af672b53dd171f20e86eec46ee4afff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af672b53dd171f20e86eec46ee4afff48">&#9670;&nbsp;</a></span>setNodePricingRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setNodePricingRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td>
          <td class="paramname"><em>pricingRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The functions sets the <em>pricing rule</em> to be used for solving not-root node LPs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pricingRule</td><td>new pricing rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5" title="Pricing rules.">enPricingRule</a>, <a class="el" href="classCLP.html#a885168355b7d81cfa3cb7872ec5ec0a4">getPricingRule()</a>, setMipPricingRule(). </dd></dl>

</div>
</div>
<a id="af3fe024329716cf3bdfbb5f66cb852b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fe024329716cf3bdfbb5f66cb852b9">&#9670;&nbsp;</a></span>setNodeSepRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setNodeSepRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td>
          <td class="paramname"><em>sepRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets the <em>separaion rule</em> used when not-root node LPs of MIPs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sepRule</td><td>new separation rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584" title="Separation rules.">enSepRule</a>, <a class="el" href="classCLP.html#acec30b96087c0a237e468907de24c75e">getSepRule()</a>, CMIP::setMipSepRule(). </dd></dl>

</div>
</div>
<a id="a063157583e0246322c62cb5fbd0d0cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063157583e0246322c62cb5fbd0d0cee">&#9670;&nbsp;</a></span>setPoolCutTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setPoolCutTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>new tolerance value for pool cuts; only if an appropriate cut in the pool is violated by more than <code>tol</code>, then it is extracted to the constraint matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad175289865b9117fc7505c6d4e5fa28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad175289865b9117fc7505c6d4e5fa28d">&#9670;&nbsp;</a></span>setProbingDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setProbingDepth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>new maximum number of rounds when probing binary variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a5a67bed916bee0574d519110c1456120">getProbingDepth()</a>, setProbingRoundNum(). </dd></dl>

</div>
</div>
<a id="a5d0820008f5502c3d44ff063c3cfd02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0820008f5502c3d44ff063c3cfd02d">&#9670;&nbsp;</a></span>setRelObjDecPerCutRoundAtNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setRelObjDecPerCutRoundAtNodes </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets a new minimum relative decrease of the upper bound (objective value of the relaxation LP) per cut round for not-root nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prc</td><td>minimum relative decrease of the upper bound per cut round for not-root nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a74c8fcbb2b4a9bda5de72679ced4cf4f">getRelObjDecPerCutRoundAtNodes()</a>, <a class="el" href="classCMIP.html#aaa3582cea3c5dcaa29339562496c1b39">setRelObjDecPerCutRoundAtRoot()</a>. </dd></dl>

</div>
</div>
<a id="aaa3582cea3c5dcaa29339562496c1b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3582cea3c5dcaa29339562496c1b39">&#9670;&nbsp;</a></span>setRelObjDecPerCutRoundAtRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setRelObjDecPerCutRoundAtRoot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The rules that are used by the solver to choose a right moment to stop generating cuts are complicated. The progress in decreasing the upper bound on the optimal objective value is the key factor affecting the whole cut generation process. setObjDecFracPerCutRoundAtRoot() sets a new minimum relative decrease of the upper bound (objective value of the relaxation LP) per cut round for the root node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prc</td><td>minimum relative decrease of the upper bound per cut round for the root node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#acbb24a09d08c67dd3c13e70d9e3014fe">getRelObjDecPerCutRoundAtRoot()</a>, <a class="el" href="classCMIP.html#a5d0820008f5502c3d44ff063c3cfd02d">setRelObjDecPerCutRoundAtNodes()</a>. </dd></dl>

</div>
</div>
<a id="a4a1a5a7c0984a3417c60c75a33d721c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1a5a7c0984a3417c60c75a33d721c9">&#9670;&nbsp;</a></span>setRoundingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setRoundingType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572">enRoundType</a>&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function specifies a way of rounding optimal LP solutions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>direction of rounding fractional components; if <code>dir==ROUND_USER</code>, <code><a class="el" href="classCMIP.html#af12f1918e4566ac5b358861a4dbfd326">roundSolution()</a></code> with four argument has to be overloaded to implement problem specific rounding strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a2394ed0f7beb2a12444f132a7eab2572" title="Rounding rules.">enRoundType</a>, <a class="el" href="classCMIP.html#ada95006ce13736b0bf0b78ce263c2d22">getRoundingType()</a>. </dd></dl>

</div>
</div>
<a id="a1b26ee9f905292075e66031728bffca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b26ee9f905292075e66031728bffca3">&#9670;&nbsp;</a></span>setThreadNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setThreadNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>threadNum &gt; 0</code> and <code>threadNum &lt; __MAX_THREAD_NUM</code>, the function sets the number of threads to threadNum; otherwise, the function does nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadNum</td><td>number of threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa179f37b0953fd296869589ec9497fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa179f37b0953fd296869589ec9497fcb">&#9670;&nbsp;</a></span>setToleranceForCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setToleranceForCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51">enCutType</a>&#160;</td>
          <td class="paramname"><em>cutType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutType</td><td>cut type; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>cut inequality is assumed as being violated, and then added to the matrix, if the inequality is violated by at least <code>tol</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a811eee6c5be7e08f960b81b915903f51" title="Cut types.">enCutType</a>, getToleranseForCut(). </dd></dl>

</div>
</div>
<a id="a521debeb6b0b75a3520f289cd049d9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521debeb6b0b75a3520f289cd049d9e2">&#9670;&nbsp;</a></span>setVarPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::setVarPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer variables can be assigned priorities, i.e., integer numbers from <code>VAR_PRI_MIN</code> to <code>VAR_PRI_MAX</code>, which are used when selecting a variable for branching. The higher priority the more chances for a fractional variable to be chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable which priority to be changed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pr</td><td>new priority </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a9297389c022da8127e141b52fe8b4a4c">incVarPriority()</a>, <a class="el" href="classCMIP.html#a1b49eced2ef53c891ef679c0432d0f79">getVarPriority()</a>. </dd></dl>

</div>
</div>
<a id="af864821866ac67b2700be91ef97bb95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af864821866ac67b2700be91ef97bb95c">&#9670;&nbsp;</a></span>shrinkCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::shrinkCut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure reduces size of the cut by removing some variables taking their bound values; this may make the cut local. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>maximally allowed cut size; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sz</td><td>size of arrays <code>ipCol</code> and <code>dpVal</code> (size of cut); </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ipCol,dpVal,b</td><td>inequality <code>sum(i=0..sz-1) dpVal[i]*x(ipCol[i]) &lt;= b</code> represents both, input and output, cuts; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iFactor</td><td><code>sum(i=0..sz-1) r(i)</code>, where <code>frexp(fabs(m_dpVal[i]),r(i))</code>; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bLocal</td><td>is <code>true</code> if resulting cut is local. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61b10d75afbbfba3a87c0b4506207fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b10d75afbbfba3a87c0b4506207fce">&#9670;&nbsp;</a></span>skipSymmetrySearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::skipSymmetrySearch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this function to prevent MIPCL from searching for symmetries. </p>

</div>
</div>
<a id="ad5edb20a3c41f1655e4eedbc3514ce23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5edb20a3c41f1655e4eedbc3514ce23">&#9670;&nbsp;</a></span>solStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::solStatistics </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>MIPCLver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>solTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timeLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>feasible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gapLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>difficultNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function prints into the stream <code>out</code> solution statistics such as: whether the problem is feasible or not, solution time, whether optimality was proven or not, and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MIPCLver</td><td><b>MIPCL</b> version; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solTime</td><td>string representation of solution time; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeLimit</td><td>if <code>true</code>, time limit has been reached; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeNum</td><td>number of processed nodes; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feasible</td><td>if <code>false</code>, problem is infeasible; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hasSolution</td><td>if <code>true</code>, solution (not necessary optimal) has been found; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objVal</td><td>objective value of best solution; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>if <code>true</code>, optimality has been proven; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>duality gap; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gapLimit</td><td>if <code>true</code>, solution process has been terminated since required duality gap had been reached; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bound</td><td>depending on value of <code>sense</code>, lower or upper bound on optimal objective value; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">difficultNodes</td><td>number of nodes processed with numerical difficulties; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>reference to a stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="MIPCLmsgs.html">Using MIPCL in GUI applications</a> </dd></dl>

</div>
</div>
<a id="a591895e6bb2d334e6fb8f0a76711c099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591895e6bb2d334e6fb8f0a76711c099">&#9670;&nbsp;</a></span>startBranching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::startBranching </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeHeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure decides how to branch at the node being processed. It is called by the solver when it starts processing a new node. Overloading <code><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching()</a></code> together with <a class="el" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch()</a>, allows the user to take full control on the branching process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeHeight</td><td>height (in the search tree) of the currently processed node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of branches. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch()</a>.</dd></dl>
<p>The procedure performs <em>orbital branching</em>. It is applied for the current search tree node, and</p><ul>
<li>computes the stabilizer subgroup of the <em>global symmetry group</em>;</li>
<li>chooses an orbit (of this computed subgroup) that contains a binary variable taking a fractional value; the orbit of size <code>m_iFxNum</code> is stored in <code>m_ipFxVar</code> array, and <code>m_iBrCol</code> stores an orbit variable.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if required orbit and variable in it do exist. </dd></dl>

</div>
</div>
<a id="a996f868ad1dbd766421fa6e8c7ae2c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996f868ad1dbd766421fa6e8c7ae2c9d">&#9670;&nbsp;</a></span>storeNodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CMIP::storeNodeData </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is called to prepare information for storing in the node of the search tree. This function can be overloaded to exploit problem specifics and store node data more efficiently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ipVal</td><td>array to write down node data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes stored in <code>ipVal</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#aaa043fd46c50b56da7b303ed4d57da39">restoreNodeData()</a>. </dd></dl>

</div>
</div>
<a id="a4d462ff8a25ec8eb97bbea6409510aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d462ff8a25ec8eb97bbea6409510aaa">&#9670;&nbsp;</a></span>switchMipInfoMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMIP::switchMipInfoMsg </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cutInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>treeInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is called to switch on or off printing <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> run time messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cutInfo</td><td>if <code>true</code>, the solver will start printing cut statistics; otherwise, will stop printing such messages; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">treeInfo</td><td>if <code>true</code>, the solver will start printing branch-and-cut statistics; otherwise, will stop printing such messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace5502b6ddd5a187bc086504b16dadef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5502b6ddd5a187bc086504b16dadef">&#9670;&nbsp;</a></span>timeLimitStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::timeLimitStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if solution procedure stopped after exceeding given time limit. </dd></dl>

</div>
</div>
<a id="a2f03143ca1246848919bb567b0bd1ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f03143ca1246848919bb567b0bd1ec4">&#9670;&nbsp;</a></span>unlockColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CMIP::unlockColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that implements its own pool for storing generated columns. When a new node is extracted from the search tree, <code><a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">unlockColumn()</a></code> is called for any column generated by the derived class column generating procedure (i.e., <code><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns()</a></code> unless that column was sent to the <b>MIPCL</b> pool. Properly implemented two functions, <code><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">lockColumn()</a></code> and <code><a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">unlockColumn()</a></code>, and <code><a class="el" href="classCMIP.html#a58771d3c7e8c151087e5d3944a97ac93">delNodeLocalColumns()</a></code> allow derived classes to delete, if necessary, unused columns from their pools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>column handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">lockColumn()</a>, <a class="el" href="classCMIP.html#a58771d3c7e8c151087e5d3944a97ac93">delNodeLocalColumns()</a>. </dd></dl>

</div>
</div>
<a id="a1f16e46d8cc9b738b0acd18bee6bcc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f16e46d8cc9b738b0acd18bee6bcc7e">&#9670;&nbsp;</a></span>unlockCtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CMIP::unlockCtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that implements its own pool for storing generated inequalities. When a new node is extracted from the search tree, <code><a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr()</a></code> is called for any constraint generated by the derived class cut generating procedures (i.e. <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code>, <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1()</a></code>, and <code><a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">genCut2()</a></code>) unless that constraint was sent to the <b>MIPCL</b> pool. Properly implemented two functions, <code><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr()</a></code>, <code><a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr()</a></code>, and <code><a class="el" href="classCMIP.html#a3798c5cb419733a4050e47215b178c48">delNodeLocalCtrs()</a></code> allow derived classes to delete, if necessary, unused cuts from their pools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>constraint handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr()</a>, <a class="el" href="classCMIP.html#a3798c5cb419733a4050e47215b178c48">delNodeLocalCtrs()</a>. </dd></dl>

</div>
</div>
<a id="a46358134da85552da3e76a53ca9eaf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46358134da85552da3e76a53ca9eaf43">&#9670;&nbsp;</a></span>updateBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CMIP::updateBranch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets new bounds for integer variables or/and adds new constraints to the matrix to transform the parent node problem into the problem of branch <code>i</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>branch index, when <code>i</code> is nonnegative integer that is less than the value returned by <code><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if inconsistency has been detected; otherwise, <code>true</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching()</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/nick/programs/mip/mipcl/headers/<a class="el" href="cmip_8h_source.html">cmip.h</a></li>
<li>/home/nick/programs/mip/mipcl/sources/cmip.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:35 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
