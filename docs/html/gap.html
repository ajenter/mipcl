<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: Generalized assignment problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Generalized assignment problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_mipclGAP"></a>
Generalized assignment problem</h1>
<p>The generalized assignment problem can be considered as the following parallel machine scheduling problem. Each of $m$ independent tasks must be processed without interruptions by one of $n$ parallel machines; it takes <img class="formulaInl" alt="$p_{ij}$" src="form_161.png"/> units of time and costs <img class="formulaInl" alt="$c_{ij}$" src="form_162.png"/> if task <em>i</em> is processed on machine <em>j</em>. The <em>load</em> (total running time) of machine <em>j</em> must not exceed <img class="formulaInl" alt="$l_j$" src="form_163.png"/>. A <em>schedule</em> is represented by an <img class="formulaInl" alt="$m\times n\text{-matrix } X=\{x_{ij}\}$" src="form_164.png"/> with <img class="formulaInl" alt="$x_{ij}=1$" src="form_165.png"/> if task <em>i</em> is assigned (for processing) to machine <em>j</em>. The <em>generalized assignment problem</em> is to find such a schedule that admits all the above requirements and has the minimum total assignment cost. It is formulated as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{i=1}^m\sum_{j=1}^n c_{ij}\, x_{ij} &amp;\to \min,\tag{1.a}\\ \sum_{j=1}^n x_{ij} &amp;= 1,\quad i=1,\ldots,m,\tag{1.b}\\ \sum_{i=1}^m p_{ij}x_{ij} &amp;\le l_j,\quad j=1,\ldots,n,\tag{1.c}\\ x_{ij} &amp;\in \{0,1\},\quad i=1,\ldots,m;\; j=1,\ldots,n.\tag{1.d} \end{align*}" src="form_166.png"/>
</p>
<p> Here, the objective (1.a) is to minimize the total assignment cost, the constraints (1.b) require that each task be assigned to exactly one machine, and the <em>capacity inequalities</em> (1.c) restrict the machine loads.</p>
<p>Setting </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ X_j=\{z\in \{0,1\}^m:\; \sum_{i=1}^m p_{ij} z_i \le l_j\}, \]" src="form_167.png"/>
</p>
<p> we can reformulate problem (1) in the following way:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{j=1}^n \sum_{a\in X_j}\left(\sum_{i=1}^m c_{ij}a_i\right) \lambda^j_a &amp;\to \min,\tag{2.a}\\ \sum_{j=1}^n \sum_{a\in X_j} a \lambda^j_a &amp;= \mathrm{e},\tag{2.b}\\ \sum_{a\in X_j} \lambda^j_a &amp;\le 1,\quad j=1,\ldots,n,\tag{2.c}\\ \lambda^j_a \in \{0,1\},\; a &amp;\in X_j,\quad j=1,\ldots,n.\tag{2.d} \end{align*}" src="form_168.png"/>
</p>
<p> Here <code>e</code> denotes the vector with all <em>m</em> components equal to <code>1</code>. Observe that in (2.c) we have substituted the equal sign for the less or equal sign since the set <img class="formulaInl" alt="$X_j$" src="form_169.png"/> contains the zero vector.</p>
<h2><a class="anchor" id="sec_CGenAssignDef"></a>
Class CGenAssign</h2>
<p>To apply a branch-and-price algorithm for solving integer program (2), we need to extend <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> to get a new class that overloads a few virtual functions of the base class.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cmip_8h.html">cmip.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>CGenAssign: <span class="keyword">public</span> <a class="code" href="classCMIP.html">CMIP</a></div><div class="line">{</div><div class="line">        <span class="keywordtype">bool</span> m_bOK;</div><div class="line">        <span class="keywordtype">int</span> m_iTskNum, m_iMachNum; </div><div class="line">        <span class="keywordtype">int</span> *m_ipMachCap, *m_ipCost, *m_ipProcTime; </div><div class="line">        <span class="keywordtype">int</span> *m_ipAssign; </div><div class="line">        <span class="keywordtype">int</span> m_iSizeOfNodeData; </div><div class="line"></div><div class="line">        <span class="keywordtype">int</span>* m_ipNd;</div><div class="line">        <span class="keywordtype">int</span> m_iCurTsk, m_iCurMach;</div><div class="line">        <span class="keywordtype">int</span> m_iQ; </div><div class="line">        <span class="keywordtype">double</span> *m_dpKn;</div><div class="line">        <span class="keywordtype">int</span> *m_ipKn;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">        CGenAssign(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span>* l, <span class="keywordtype">int</span>* c, <span class="keywordtype">int</span>* p);</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">        CGenAssign(<span class="keyword">const</span> CGenAssign &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">        <a class="code" href="classCMIP.html">CMIP</a>* <a class="code" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a>(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">#endif  </span></div><div class="line">        <span class="keyword">virtual</span> ~CGenAssign();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">void</span> buildMaster(); </div><div class="line">        <span class="keywordtype">void</span> setGammaEntry(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> val);</div><div class="line">        <span class="keywordtype">int</span> getGammaEntry(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j);</div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns</a>(<span class="keywordtype">int</span> ctrNum, <span class="keyword">const</span> tagHANDLE* ipRowHd, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpY);</div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching</a>(<span class="keywordtype">int</span> <span class="comment">/*nodeHeight*/</span>);</div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch</a>(<span class="keywordtype">int</span> k);</div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="classCMIP.html#a996f868ad1dbd766421fa6e8c7ae2c9d">storeNodeData</a>(<span class="keywordtype">void</span>*&amp; pMem);</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#aaa043fd46c50b56da7b303ed4d57da39">restoreNodeData</a>(<span class="keywordtype">void</span>* pMem);</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">changeRecord</a>(<span class="keywordtype">double</span> objVal, <span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipHd);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a91249febf036dd979f7584bc0962137a">printSolution</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName);</div><div class="line">};</div></div><!-- fragment --><p>First, let us describe <code>CGenAssign</code> members:</p><ul>
<li><code>m_iTskNum</code>: number of tasks (<code>m</code>);</li>
<li><code>m_iMachNum</code>: number of tasks and machines (<code>n</code>);</li>
<li><code>m_ipMachCap</code>: array of size <code>m</code>, where <code>m_ipMachCap[j]</code> is running time of machine <code>j=0,...,m-1</code>;</li>
<li><code>m_ipCost</code>: array of size <code>m*n</code>, where <code>m_ipCost[j*m+i]</code> is cost of running task <code>i=0,...,m-1</code> on machine <code>j=0,...,n-1</code>;</li>
<li><code>m_ipProcTime</code>: array of size <code>m*n</code>, where <code>m_ipProcTime[j*m+i]</code> is processing time of task <code>i=0,...,m-1</code> on machine <code>j=0,...,n-1</code>;</li>
<li><code>m_ipAssign</code>: array of size <code>m</code> to store best (record) solutions, where task <code>i</code> is processed by machine <code>m_ipAssign}[i]</code> (<code>i=0,...,m-1</code>);</li>
<li><code>m_iSizeOfNodeData</code>: size of array <code>m_ipNd</code>;</li>
<li><code>m_ipNd</code>: array used to store the matrix <img class="formulaInl" alt="$\Gamma$" src="form_170.png"/> which element <img class="formulaInl" alt="$\gamma_{ij}$" src="form_171.png"/> is<ul>
<li><code>0</code> if task <em>i</em> has not been assigned to any machine so far,</li>
<li><code>1</code> if task <em>i</em> has been assigned to machine <em>j</em>,</li>
<li><code>2</code> if task <em>i</em> must not be assigned to machine <em>j</em>;</li>
</ul>
</li>
<li><code>m_iCurTsk</code>, <code>m_iCurMach</code>: integer parameters that are set in <code>startBranching()</code>, when currently selected search tree node was divided into two branches:<ul>
<li>branch~1: task <code>m_iCurTsk</code> was assigned to machine <code>m_iCurMach</code>,</li>
<li>branch~2: task <code>m_iCurTsk</code> was prohibited for assigning to machine <code>m_iCurMach</code>.</li>
</ul>
</li>
<li><code>m_iQ</code>: maximum of machine capacities;</li>
<li><code>m_ipKn</code>, <code>m_dpKn</code>: arrays needed to call <code>binKnapsack()</code> that solves pricing problem (see <a class="el" href="gap.html#sec_gapPricing">Pricing problem</a>).</li>
</ul>
<h2><a class="anchor" id="sec_gapConstr"></a>
Constructor and destructor</h2>
<p>The task of the constructor is to allocate memory for dynamic arrays and then build the initial master problem (see <a class="el" href="gap.html#sec_gapMaster">Master problem</a>). The constructor is presented below.</p>
 </p><div class="fragment"><div class="line">CGenAssign::CGenAssign(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span>* l, <span class="keywordtype">int</span>* c, <span class="keywordtype">int</span>* p):</div><div class="line">        <a class="code" href="classCMIP.html">CMIP</a>(name), m_bOK{<span class="keyword">true</span>},</div><div class="line">        m_iTskNum(m), m_iMachNum(n),</div><div class="line">        m_ipMachCap(l), m_ipCost(c), m_ipProcTime(p)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> q{m*n};</div><div class="line">        <span class="keywordtype">int</span> k{q&gt;&gt;4};</div><div class="line">        <span class="keywordflow">if</span> (q &amp; 0xF)</div><div class="line">                ++k;</div><div class="line">        q=0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j={0}; j &lt; n; j++) {</div><div class="line">        <span class="keywordflow">if</span> (l[j] &gt; q)</div><div class="line">            q=l[j];</div><div class="line">    }</div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">                m_ipAssign= <span class="keyword">new</span>(std::nothrow) <span class="keywordtype">int</span>[m];</div><div class="line">                m_ipNd = <span class="keyword">new</span>(std::nothrow) <span class="keywordtype">int</span>[m_iSizeOfNodeData=k];</div><div class="line">                KNAPSACK::getMemForBinKnapsack(m,m_iQ=q,m_dpKn,m_ipKn);</div><div class="line">        } <span class="keywordflow">catch</span>(std::bad_alloc* e) {</div><div class="line">                m_bOK=<span class="keyword">false</span>;</div><div class="line">                strcpy(m_sWarningMsg,<span class="stringliteral">&quot;CGenAssign::CGenAssign(: &quot;</span>);</div><div class="line">                strncat(m_sWarningMsg,e-&gt;what(),128);</div><div class="line">                <span class="keyword">delete</span> e;</div><div class="line">    }</div><div class="line">        <span class="keywordflow">if</span> (m_bOK) {</div><div class="line">                memset(m_ipNd,0,m_iSizeOfNodeData*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line">                buildMaster();</div><div class="line">        }</div><div class="line">} <span class="comment">// end of CGenAssign::CGenAssign()</span></div></div><!-- fragment --><p>The constructor input parameters are</p><ul>
<li><code>name</code>: name of <b>MIPCL</b> application;</li>
<li><code>m</code>: number of tasks;</li>
<li><code>n</code>: number of machines;</li>
<li><code>l</code>: array of size <code>n</code>, where <code>l[j]</code> is running time of machine <code>j</code>;</li>
<li><code>c</code>: array of size <code>m*n</code>, where <code>c[j*m+i]</code> is cost of processing task <code>i</code> on machine <code>j</code>;</li>
<li><code>p</code>: array of size <code>m*n</code>, where <code>p[j*m+i]</code> is processing time of task <code>i</code> on machine <code>j</code>.</li>
</ul>
<p>First, the constructor assignes the values of input parameters, <code>m,</code>n<code>,</code>l<code>,</code>c<code>, and</code>p<code>, to the corresponding class members,</code>m_iMachNum<code>,</code>m_ipMachCap<code>,</code>m_ipCost<code>, and</code>m_ipProcTime<code>. Note that</code>m_ipMachCap<code>,</code>m_ipCost<code>, and</code>m_ipProcTime` are pointers for which memory is not allocated.</p>
<p>Next, the constructor allocates memory for</p><ul>
<li>array <code>m_ipAssign</code> of size <code>m</code> which is intended for storing</li>
<li>array <code>m_ipNd</code> for storing an <code>(m x n)</code>-matrix <img class="formulaInl" alt="$\Gamma$" src="form_170.png"/> with two bits per matrix element;</li>
<li>arrays <code>m_dpKn</code> and <code>m_ipKn</code> (memory is allocated by the function <code>KNAPSACK::getMemForBinKnapsack()</code>) that will be later used when calling function <code>KNAPSACK::binKnapsack()</code>.</li>
</ul>
<p>As its last action the constructor calls the function <code>buildMaster()</code> to build the initial master problem.</p>
<h3><a class="anchor" id="sec_gapClone"></a>
Clone constructor</h3>
<p>The clone constructor and function <code>clone()</code> are needed only if the multithreading <b>MIPCL</b> library is used (variable __THREADS_ is set in the <code>makefile</code>). Their implementation is as follows. </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">CGenAssign::CGenAssign(<span class="keyword">const</span> CGenAssign &amp;other, <span class="keywordtype">int</span> thread): <a class="code" href="classCMIP.html">CMIP</a>(other,thread)</div><div class="line">{</div><div class="line">        m_bOK=<span class="keyword">true</span>;</div><div class="line">        m_iTskNum=other.m_iTskNum;</div><div class="line">        m_iMachNum=other.m_iMachNum;</div><div class="line">        m_ipMachCap=other.m_ipMachCap;</div><div class="line">        m_iQ=other.m_iQ;</div><div class="line">        m_ipCost=other.m_ipCost;</div><div class="line">        m_ipProcTime=other.m_ipProcTime;</div><div class="line">        m_ipAssign=other.m_ipAssign;</div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">                m_ipNd=<span class="keyword">new</span>(std::nothrow) <span class="keywordtype">int</span>[m_iSizeOfNodeData=other.m_iSizeOfNodeData];</div><div class="line">                KNAPSACK::getMemForBinKnapsack(m_iTskNum,m_iQ,m_dpKn,m_ipKn);</div><div class="line">        } <span class="keywordflow">catch</span>(std::bad_alloc* e) {</div><div class="line">                m_bOK=<span class="keyword">false</span>;</div><div class="line">                strcpy(m_sWarningMsg,<span class="stringliteral">&quot;CGenAssign::CGenAssign(: &quot;</span>);</div><div class="line">                strncat(m_sWarningMsg,e-&gt;what(),128);</div><div class="line">                <span class="keyword">delete</span> e;</div><div class="line">    }</div><div class="line">        <span class="keywordflow">if</span> (m_bOK)</div><div class="line">                memset(m_ipNd,0,m_iSizeOfNodeData*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classCMIP.html">CMIP</a>* CGenAssign::clone(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread)</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;CMIP*&gt;(<span class="keyword">new</span> CGenAssign(*static_cast&lt;CGenAssign*&gt;(const_cast&lt;CMIP*&gt;(pMip)),thread));</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The clone constructors assigns the input parameters (i.e., those that describe the problem being solved) of the newly created <code>CGenAssign</code> object with the values of corresponding parameters of the cloned object, and then allocates memory for the arrays <code>m_ipNd</code>, <code>m_ipKn</code>, and <code>m_dpKn</code>.</p>
<p>Implementation of <code>clone()</code> is standard for all <b>MIPCL</b> applications.</p>
<h2><a class="anchor" id="sec_gapMaster"></a>
Master problem</h2>
<p>For <img class="formulaInl" alt="$j=1,\dots,n,\text{ let } S_j\subseteq X_j$" src="form_172.png"/>. We introduce slack variables <img class="formulaInl" alt="$s_i\; (i=1,\dots,m)$" src="form_173.png"/> to reformulate the master problem (2) in the following way: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\sum_{j=1}^n \sum_{a\in S_j} \left(\sum_{i=1}^m c_{ij}a_i\right) \lambda^j_a - M \sum_{i=1}^m s_i &amp;\to \max,\tag{3.a}\\ \sum_{j=1}^n \sum_{a\in S_j} a \lambda^j_a + s &amp;= \mathrm{e},\tag{3.b}\\ \sum_{a\in S_j} \lambda^j_a &amp;\le 1,\quad j=1,\ldots,n,\tag{3.c}\\ \lambda^j_a \ge 0,\; a &amp;\in S_j,\quad j=1,\ldots,n,\tag{3.d}\\ s_i &amp;\ge 0,\quad i=1,\dots,m,\tag{3.e} \end{align*}" src="form_174.png"/>
</p>
<p> where <em>M</em> is a sufficiently big number, for example, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M = \sum_{i=1}^m \max_{1\le j\le n} c_{ij}. \]" src="form_175.png"/>
</p>
<p> Introducing slack variables, allows us to start with the simplest master problem when all <img class="formulaInl" alt="$S_j=\emptyset$" src="form_176.png"/>. Such a problem is build by the following procedure. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> CGenAssign::buildMaster()</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> *l{m_ipMachCap}, *c{m_ipCost};</div><div class="line">        <span class="keywordtype">int</span> bigM{0}, m{m_iTskNum}, n{m_iMachNum};</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; m; i++) {</div><div class="line">                <span class="keywordtype">int</span> q{0};</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; n; ++j) {</div><div class="line">                        <span class="keywordflow">if</span> (q &lt; c[j*m+i])</div><div class="line">                                q=c[j*m+i];</div><div class="line">                }</div><div class="line">                bigM+=q;</div><div class="line">        }</div><div class="line">    <span class="keywordtype">double</span> one{1.0};</div><div class="line">    openMatrix(m+n,m,m,<span class="keyword">false</span>,<span class="keyword">true</span>,0,5*m,5*n*m);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; m; ++i) {</div><div class="line">        addCtr(i,0,1.0,1.0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; n; ++i) {</div><div class="line">        addCtr(m+i,0,-INF,1.0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; m; ++i) {</div><div class="line">        addColumn(i,0,-bigM,0.0,1.0,1,&amp;one,&amp;i);</div><div class="line">    }</div><div class="line">    preprocOff();</div><div class="line">    setScaling(SCL_NO);</div><div class="line">    closeMatrix();</div><div class="line">} <span class="comment">// end of GenAssign::buildMaster()</span></div></div><!-- fragment --><p>Here the first <code>for</code>-loop adds to the matrix <em>m</em> rows representing the constraints (3.b), the second loop adds <em>n</em> rows representing the constraints (3.c), and the third loop adds columns for slack variables <img class="formulaInl" alt="$s_i$" src="form_177.png"/>: column <code>i</code> has only one nonzero entry of value <code>1</code> in row <code>i</code>. Before terminating, the function switches off preprocessing (this is always necessary for incomplete formulations) and scaling the matrix (the unit matrix is scaled ideally).</p>
<h2><a class="anchor" id="sec_gapBranching"></a>
Branching</h2>
<p>Branching on variables <img class="formulaInl" alt="$\lambda^j_a$" src="form_178.png"/> is not efficient due to two reasons. First, such branching results into a non-balanced search tree, since the branch <img class="formulaInl" alt="$\lambda^j_a=0$" src="form_179.png"/> excludes only one column while the branch <img class="formulaInl" alt="$\lambda^j_a=1$" src="form_180.png"/> excludes all columns that have <code>1</code> at least in one row <em>i</em> such that <img class="formulaInl" alt="$a_i=1$" src="form_181.png"/>. Second, such branching violates the structure of the pricing problem (see <a class="el" href="gap.html#sec_gapPricing">Pricing problem</a>).</p>
<p>In our branch-and-price implementation, each search tree node is characterizes by a matrix <img class="formulaInl" alt="$\Gamma=[\gamma_{ij}]_{m\times n}$" src="form_182.png"/>, where <img class="formulaInl" alt="$\gamma_{ij}$" src="form_171.png"/> is</p><ul>
<li><code>0</code> if task <em>i</em> has not been assigned to any machine so far;</li>
<li><code>1</code> if task <em>i</em> has been previously assigned to machine <em>j</em>;</li>
<li><code>2</code> if task <em>i</em> is prohibited to be assigned to machine <em>j</em>. For a subproblem being currently processed, its matrix <img class="formulaInl" alt="$\Gamma$" src="form_170.png"/> is stored in the array <code>m_ipNd</code> in the compressed form with two bits per matrix entry. We can set or get any element of this matrix by calling the following functions.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CGenAssign::setGammaEntry(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> val)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> k0{i*m_iTskNum};</div><div class="line">        <span class="keywordtype">int</span> k{k0+j};</div><div class="line">        m_ipNd[k &gt;&gt; 4]|= (val &lt;&lt; ((k &amp; 0xF)&lt;&lt;1));</div><div class="line">        <span class="keywordflow">if</span> (val == 1) {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s{0}; s &lt; m_iMachNum; ++s)</div><div class="line">                        <span class="keywordflow">if</span> (s != j) {</div><div class="line">                                k=k0+s;</div><div class="line">                                m_ipNd[k&gt;&gt;4]|= (2 &lt;&lt; ((k &amp; 0xF)&lt;&lt;1));</div><div class="line">                        }</div><div class="line">        }</div><div class="line">} <span class="comment">// end of CGenAssign::setGammaEntry()</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> CGenAssign::getGammaEntry(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> k{j*m_iMachNum+i}, s{2*((k &amp; 0xF)&lt;&lt;1)};</div><div class="line">        <span class="keywordflow">return</span> (m_ipNd[k&gt;&gt;4] &amp; (3 &lt;&lt; s)) &gt;&gt; s;</div><div class="line">} <span class="comment">// end of CGenAssign::getGammaEntry()</span></div></div><!-- fragment --><p>Implementation of both these functions is straightforward and, therefore, is not commented here. Let us only note that, setting <img class="formulaInl" alt="$\gamma_{ij}=1$" src="form_183.png"/>, we must also set to <code>2</code> all the other entries in row <em>i</em>.</p>
<p>Each time a new node is added to the search tree, the solver calls the function <code>storeNodeData()</code> to store data describing this node. Our implementation of <code>storeNodeData()</code> is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CGenAssign::storeNodeData(<span class="keywordtype">void</span>*&amp; pMem)</div><div class="line">{</div><div class="line">    pMem=m_ipNd;</div><div class="line">    <span class="keywordflow">return</span> m_iSizeOfNodeData*<span class="keyword">sizeof</span>(int);</div><div class="line">} <span class="comment">// end of CGenAssign::storeNodeData()</span></div></div><!-- fragment --><p>This function returns the length (in integer words) of the array <code>m_ipNd</code>, and also passes a pointer to the array <code>m_ipNd</code> back to the caller.</p>
<p>Conversely, when a node is chosen for processing, the solver calls the function <code>restoreNodeData()</code> which implementation is the following.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CGenAssign::restoreNodeData(<span class="keywordtype">void</span>* pMem)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> *ipColToMach{m_ipArray},</div><div class="line">        *ipCol{reinterpret_cast&lt;int*&gt;(m_dpArray)};</div><div class="line">    <span class="keywordtype">int</span> col,sz, m{m_iTskNum}, n{m_iMachNum};</div><div class="line"></div><div class="line">    memcpy(m_ipNd,pMem,m_iSizeOfNodeData*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; n; j++) {</div><div class="line">        sz=getRow(j+m,0,ipCol);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; sz; ++i)</div><div class="line">            ipColToMach[ipCol[i]]=j;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; m; ++i) {</div><div class="line">                sz=getRow(i,0,ipCol);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; sz; ++j) {</div><div class="line">                        <span class="keywordflow">if</span> ((col=ipCol[j]) &gt;= m)</div><div class="line">                                <span class="keywordflow">if</span> (getGammaEntry(i,ipColToMach[col]) == 2)</div><div class="line">                                        setVarUpBound(col,0.0);</div><div class="line">        }</div><div class="line">    }</div><div class="line">} <span class="comment">// end of CGenAssign::restoreNodeData()</span></div></div><!-- fragment --><p>Its only input parameter is a pointer to the memory with the node data previously stored by <code>storeNodeData()</code>. First, <code>restoreNodeData()</code> copies this node data into the array <code>m_ipNd</code>, and then the function sets the variable bounds in accordance with the values <img class="formulaInl" alt="$\gamma_{ij}$" src="form_171.png"/>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCMIP.html#a996f868ad1dbd766421fa6e8c7ae2c9d">CMIP::storeNodeData()</a></code> and <code><a class="el" href="classCMIP.html#aaa043fd46c50b56da7b303ed4d57da39">CMIP::restoreNodeData()</a></code>.</dd></dl>
<h3><a class="anchor" id="sec_gapBranchVar"></a>
Choosing variable for branching</h3>
<p>Given an optimal solution to the node relaxation LP, if one of the variables <img class="formulaInl" alt="$\lambda^j_a$" src="form_178.png"/> takes a fractional value, then it can be easily justified that there exists a variable </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{ij} = \sum_{a\in S_j} \lambda^j_a a_i \]" src="form_184.png"/>
</p>
<p> with fractional value. We chose a variable for branching by the following rule. First, we look for the "most fractional" family of variables <img class="formulaInl" alt="$\lambda^{\bar{j}}_a$" src="form_185.png"/>, i.e. such that corresponds to the minimum value </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta_j = \left(1-\sum_{a\in S_j} \lambda^j_a\right)^2 + \sum_{a\in S_j} \left(\lambda^j_a\right)^2. \]" src="form_186.png"/>
</p>
<p> Next, among variables <img class="formulaInl" alt="$x_{i\bar{j}}\; (i=1,\ldots,m)$" src="form_187.png"/>, we chose a variable <img class="formulaInl" alt="$x_{\bar{i}\bar{j}}$" src="form_188.png"/> which value is closest to <code>0.5</code>.</p>
<p>The computations discussed above are implemented in the procedure <code>startBranching()</code>, which overloads the procedure of the base class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> CGenAssign::startBranching(<span class="keywordtype">int</span> nodeHeight)</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> w,v,val, e{0.9999999};</div><div class="line">    <span class="keywordtype">int</span> sz, m{m_iTskNum}, n{m_iMachNum}, mach{-1},</div><div class="line">        *ipCol=m_ipArray;</div><div class="line">    m_iCurMach=m_iCurTsk=-1;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; n; j++) {</div><div class="line">        sz=getRow(j+m,0,ipCol);</div><div class="line">        v=w=0.0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; sz; i++) {</div><div class="line">            val=getVarValue(ipCol[i]);</div><div class="line">            v+=val;</div><div class="line">            w+=(val*val);</div><div class="line">        }</div><div class="line">        v=1.0-v;</div><div class="line">        w+=(v*v);</div><div class="line">        <span class="keywordflow">if</span> (e &gt; w) {</div><div class="line">            e=w;</div><div class="line">            mach=j;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (mach &gt;= 0) {</div><div class="line">        <span class="keywordtype">double</span> *dpVal{m_dpArray};</div><div class="line">        <span class="keywordtype">int</span> sz1, *ipRow{reinterpret_cast&lt;int*&gt;(dpVal+m)};</div><div class="line">        memset(dpVal,0,m*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">        sz=getRow(mach+m,0,ipCol);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; sz; ++i) {</div><div class="line">            sz1=getColumn(ipCol[i],0,ipRow);</div><div class="line">            val=getVarValue(ipCol[i]);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; sz1; ++j)</div><div class="line">                                <span class="keywordflow">if</span> (ipRow[j] &lt; m)</div><div class="line">                                        dpVal[ipRow[j]]+=val;</div><div class="line">        }</div><div class="line">        w=2.0; sz=-1;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; m; ++i) {</div><div class="line">            <span class="keywordflow">if</span> (w &gt; fabs(dpVal[i]-0.5)) {</div><div class="line">                w=fabs(dpVal[i]-0.5);</div><div class="line">                sz=i;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        m_iCurMach=mach;</div><div class="line">        m_iCurTsk=sz;       </div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> (m_iCurMach &gt;= 0 &amp;&amp; m_iCurTsk &gt;= 0)? 2: 0;</div><div class="line">} <span class="comment">// end of CGenAssign::startBranching()</span></div></div><!-- fragment --><p>The values <img class="formulaInl" alt="$\bar{i}\text{ and }\bar{j}$" src="form_189.png"/> are stored in the class members <code>m_CurTsk</code> and <code>m_CurMach</code> to be used later in the procedure <code>updateBranch()</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CGenAssign::updateBranch(<span class="keywordtype">int</span> k)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> *ipCol{m_ipArray};</div><div class="line">        <span class="keywordtype">bool</span> *bpColToMach{reinterpret_cast&lt;bool*&gt;(m_dpArray)};</div><div class="line">    <span class="keywordtype">int</span> sz, m{m_iTskNum}, n{m_iMachNum};</div><div class="line"></div><div class="line">    setGammaEntry(m_iCurTsk,m_iCurMach,k+1);</div><div class="line">        memset(bpColToMach,0,getVarNum()*<span class="keyword">sizeof</span>(<span class="keywordtype">bool</span>));</div><div class="line">    sz=getRow(m_iCurMach+m,0,ipCol);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; sz; ++j) {</div><div class="line">        bpColToMach[ipCol[j]]=<span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">        sz=getRow(m_iCurTsk,0,ipCol);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; sz; ++j) {</div><div class="line">                <span class="keywordflow">if</span> ((k &amp;&amp; !bpColToMach[ipCol[j]]) || (!k &amp;&amp; bpColToMach[ipCol[j]]))</div><div class="line">                        setVarUpBound(ipCol[j],0.0);</div><div class="line">    }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="comment">// end of CGenAssign::updateBranch()</span></div></div><!-- fragment --><p>Given a branch number, <code>0</code> or <code>1</code>, <code>updateBranch()</code> modifies the node matrix <img class="formulaInl" alt="$\Gamma$" src="form_170.png"/> and appropriately updates variable bounds. For branch <code>0</code> that corresponds to the case when <img class="formulaInl" alt="$x_{\bar{i}\bar{j}}=1$" src="form_190.png"/> , we set <img class="formulaInl" alt="$\gamma_{\bar{i}\bar{j}}=1$" src="form_191.png"/> and also set to <code>0</code> the upper bounds for all variables <img class="formulaInl" alt="$\lambda^j_a\text{ such that } j\neq \bar{j}\text{ and }a_i=1$" src="form_192.png"/>. For branch <code>1</code> that corresponds to the case when <img class="formulaInl" alt="$x_{\bar{i}\bar{j}}=0$" src="form_193.png"/>, we set <img class="formulaInl" alt="$\gamma_{\bar{i}\bar{j}}=2$" src="form_194.png"/> and also set to <code>0</code> the upper bounds for all variables <img class="formulaInl" alt="$\lambda^{\bar{j}}_a\text{ with }a_i=1$" src="form_195.png"/>.</p>
<h2><a class="anchor" id="sec_gapPricing"></a>
Pricing problem</h2>
<p>Let <img class="formulaInl" alt="$y\in\mathbb{R}^{m+n}$" src="form_196.png"/> be an optimal dual solution of the relaxation LP for the node characterized by some matrix <img class="formulaInl" alt="$\Gamma$" src="form_170.png"/>. Let </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ G_j=\{i:\; \gamma_{ij}=0\}\quad\text{and}\quad H_j =\{i:\; \gamma_{ij}=1\}. \]" src="form_197.png"/>
</p>
<p> For <img class="formulaInl" alt="$j=1,\ldots,n$" src="form_198.png"/>, the <em>pricing problem</em> is formulated as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{i\in G_j} (-c_{ij}-y_i) z_i &amp;\to \max,\\ \sum_{i\in G_j} p_{ij} z_i \le l_j &amp;- \sum_{i\in H_j} p_{ij},\tag{4}\\ z_i \in \{0,1\},\quad &amp;i\in G_j\,. \end{align*}" src="form_199.png"/>
</p>
<p> This is the 0,1-knapsack problem. If an optimal solution <img class="formulaInl" alt="$z^*\in\{0,1\}^{G_j}$" src="form_200.png"/> to problem (4) obeys the inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i\in G_j} (-c_{ij}-y_i) z^*_i + \sum_{i\in H_j} (-c_{ij}-y_i) &gt; y_{m+j}, \]" src="form_201.png"/>
</p>
<p> then <img class="formulaInl" alt="$z^*$" src="form_87.png"/> is appended to the set <img class="formulaInl" alt="$S_j$" src="form_202.png"/>. In this case, the column <img class="formulaInl" alt="$(z^*,\mathrm{e}_j)^T\in\{0,1\}^{m+n}$" src="form_203.png"/> is added to the master problem. The objective coefficient for this column is <img class="formulaInl" alt="$-\sum_{i=1}^m c_{ij} a_i$" src="form_204.png"/>.</p>
<p>The column generation algorithm described above is implemented in the following procedure that overloads <code><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">CLP::generateColumns()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CGenAssign::generateColumns(<span class="keywordtype">int</span> ctrNum, <span class="keyword">const</span> tagHANDLE* ipRowHd, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpY)</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> c0, z, tol=getRedCostTol();</div><div class="line">    <span class="keywordtype">int</span> b, num, m{m_iTskNum}, n{m_iMachNum};</div><div class="line">    <span class="keywordtype">double</span> *w{m_dpArray+(m+1)};</div><div class="line">        <span class="keywordtype">int</span> *x, *a, *ipTsk, *ipRow{m_ipArray},</div><div class="line">        *c{m_ipCost}, *p{m_ipProcTime}, *l{m_ipMachCap};</div><div class="line">   ipTsk=ipRow +(m+1); x=(a=ipTsk+m)+m;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt;= m; ++i) {</div><div class="line">        m_dpArray[i]=1.0;</div><div class="line">    }</div><div class="line"></div><div class="line">    num=0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j{0}; j &lt; n; ++j) {</div><div class="line">        <span class="keywordtype">int</span> q{0}, sz{0}, k{0};</div><div class="line">        b=l[j];</div><div class="line">        c0=0.0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e, i{0}; i &lt; m; ++i) {</div><div class="line">            <span class="keywordflow">if</span> (!(e=getGammaEntry(i,j))) {</div><div class="line">                                <span class="keywordflow">if</span> (p[i] &lt;= l[j]) {</div><div class="line">                                        z=-c[i]-dpY[i];</div><div class="line">                                        <span class="keywordflow">if</span> (z &gt; tol) {</div><div class="line">                                                ipTsk[k]=i;</div><div class="line">                                                w[k]=z;</div><div class="line">                                                a[k++]=p[i];</div><div class="line">                                        }</div><div class="line">                                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e == 1) {</div><div class="line">                q+=c[i];</div><div class="line">                ipRow[sz++]=i;</div><div class="line">                b-=p[i];</div><div class="line">                c0-=(c[i]+dpY[i]);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (k &amp;&amp; b &gt; 0) {</div><div class="line">                <span class="keywordflow">if</span> (KNAPSACK::binKnapsack(k,w,a,b,x,m_dpKn,m_ipKn) &gt; dpY[m+j]-c0+tol) {</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; k; ++i) {</div><div class="line">                        <span class="keywordflow">if</span> (x[i]) {</div><div class="line">                            q+=c[ipTsk[i]];</div><div class="line">                            ipRow[sz++]=ipTsk[i];</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                    ipRow[sz++]=m+j;</div><div class="line">                    sz=addNewColumn(-1,VAR_BIN,-q,0.0,1.0,sz,m_dpArray,m_ipArray,<span class="keyword">false</span>,<span class="keyword">false</span>,0,<span class="keyword">true</span>);</div><div class="line">                    ++num;</div><div class="line">                            w=m_dpArray+(m+1); </div><div class="line">                                x=(a=(ipTsk=(ipRow=m_ipArray)+(m+1))+m)+m;</div><div class="line">                        }</div><div class="line">        }</div><div class="line">        p+=m; c+=m;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> (num)? <span class="keyword">true</span>: <span class="keyword">false</span>;</div><div class="line">} <span class="comment">// end of CGenAssign::generateColumns()</span></div></div><!-- fragment --><p>To solve the pricing problem (4), <code>generateColumns()</code> calls the procedure </p><pre class="fragment">double binKnapsack(int n, double *c, int* a, int b, int *x, double *dpF, int *ipBt)
</pre><p>that solves the following 0,1-knapsack problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \max\left\{\sum_{j=1}^n c_j x_j:\; \sum_{j=1}^n a_j x_j \le b,\; x\in \{0,1\}^n\right\} \]" src="form_205.png"/>
</p>
<p> by a dynamic programming algorithm. The first five parameters of <code>binKnapsack()</code> are in one to one correspondence with the parameters of the mathematical formulation. The last two parameters must point to the arrays previosly allocated by <code>KNAPSACK::getMemForBinKnapsack()</code>. Here, we do not describe <code>binKnapsack()</code> and use it as a black box.</p>
<h2><a class="anchor" id="sec_gapStoring"></a>
Storing solutions</h2>
<p>Another function of the base class <b><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></b> that must be overloaded is <code><a class="el" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">CMIP::changeRecord()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CGenAssign::changeRecord(<span class="keywordtype">double</span> objVal,</div><div class="line">                        <span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipHd)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> *ipRow{m_ipArray};</div><div class="line">    <span class="keywordtype">int</span> m{m_iTskNum}, m0{m_iTskNum+m_iMachNum};</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k,sz, j{m}; j &lt; varNum; ++j) {</div><div class="line">        <span class="keywordflow">if</span> (dpX[j] &gt; 0.5) {</div><div class="line">            sz=getColumn(j,0,ipRow);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; sz; ++i) {</div><div class="line">                                <span class="keywordflow">if</span> (ipRow[i] &lt; m0 &amp;&amp; ipRow[i] &gt;= m) {</div><div class="line">                                        k=ipRow[i]-m;</div><div class="line">                                        <span class="keywordflow">break</span>;</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i{0}; i &lt; sz; ++i) {</div><div class="line">                                <span class="keywordflow">if</span> (ipRow[i] &lt; m)</div><div class="line">                                        m_ipAssign[ipRow[i]]=k;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">} <span class="comment">// end of CGenAssign::changeRecord()</span></div></div><!-- fragment --><p>The solver calls this function each time a new best (record) solution is found. If we had not overloaded <code>changeRecord()</code>, then each time, when a new best solution is found, the solver would call the base version of this function to store the variables <img class="formulaInl" alt="$\lambda$" src="form_35.png"/>. But having the values of these variables, we cannot restore assignments of the tasks to the machines without knowing the columns corresponding to these variables.</p>
<p>For each variable <code>j</code> of value <code>1</code>, we call the function <code><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">CLP::getColumn()</a></code> to get an array <code>ipRow</code> (of size <code>sz</code>) of row indices of nonzero entries in column <code>j</code>. We look over the array <code>ipRow</code> twice: first time to determine the index, <code>k</code>, of the machine that corresponds to this column, and second time to write into the array <code>m_ipAssign</code> the list of tasks assigned to machine <code>k</code>. When <code>changeRecord()</code> terminates, <code>m_ipAssign</code> stores all assignments: task <code>i</code> is assigned to machine <code>m_ipAssign[i]</code>.</p>
<p>An attentive reader could observe that, in <code>changeRecord()</code>, we might allow different threads to simultaneously access the array <code>m_ipAs\-sign</code> which is shared by the threads. But this cannot happen since <b>MIPCL</b> do not allow two threads to call <code>changeRecord()</code> simultaneously. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:33 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
