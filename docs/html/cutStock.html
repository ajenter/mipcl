<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: Cutting-stock problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cutting-stock problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_mipclCutStock"></a>
Cutting-stock problem</h1>
<p>Materials such as paper, textiles, cellophane, and metallic foil are manufactured in rolls of large length. Later, these rolls are cut into smaller pieces, called <em>finals</em>. For example, we can cut a roll of length 1000cm (10m) into five finals of length 165cm and two finals of length 72cm, with 33cm going to waste. When many types of finals are to be cut off in different quantities, then the task of finding the most economical way of cutting rolls to get required quantities of finals is far from being trivial.</p>
<p>The problem of finding the most economical way of cutting is known as the <em>cutting stock problem</em>. In its simplest form the problem is to use the minimum number of rolls with length <em>L</em> to cut off <img class="formulaInl" alt="$q_1,\dots,q_m$" src="form_65.png"/> finals of length <img class="formulaInl" alt="$l_1,\dots,l_m$" src="form_66.png"/>. A vector <img class="formulaInl" alt="$a=(a_1,\dots,a_m)^T$" src="form_67.png"/> of non-negative integers is called a <em>pattern</em> if <img class="formulaInl" alt="$\sum_{i=1}^m a_i l_i \le L$" src="form_68.png"/>, i.e., from a roll of length <em>L</em>, we can cut off <img class="formulaInl" alt="$a_1$" src="form_69.png"/> finals of length <img class="formulaInl" alt="$l_1$" src="form_70.png"/>, <img class="formulaInl" alt="$a_2$" src="form_71.png"/> finals of length <img class="formulaInl" alt="$l_2$" src="form_72.png"/>, and so on <img class="formulaInl" alt="$a_m$" src="form_73.png"/> finals of length <img class="formulaInl" alt="$l_m$" src="form_74.png"/>. Let <img class="formulaInl" alt="$a^j=(a_{1j},\dots,a_{mj})^T$" src="form_75.png"/>, <img class="formulaInl" alt="$j=1,\dots,n$" src="form_76.png"/>, be the set of all patterns, and let <img class="formulaInl" alt="$x_j$" src="form_77.png"/> denote the number of rolls that are cut in accordance with pattern <img class="formulaInl" alt="$a^j$" src="form_78.png"/>. Now the cutting stock problem is the following IP: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{j=1}^n x_j &amp;\to \min,\\ \sum_{j=1}^n a_{ij} x_j &amp;\ge q_i,\quad i=1,\ldots,m,\tag{1}\\ x_j &amp;\in \mathbb{Z}_+,\quad j=1,\ldots,n. \end{align*}" src="form_79.png"/>
</p>
<p><em>Remark</em>. This base model can be easily modified for the case when there are rolls of unequal length. When cutting rolls of expensive materials, such as silk, a more appropriate criterion is to minimize the cost of leftovers <img class="formulaInl" alt="$\sum_{j=1}^n c_j x_j$" src="form_80.png"/>, where <img class="formulaInl" alt="$c_j$" src="form_81.png"/> is the waste cost for pattern <img class="formulaInl" alt="$a^j$" src="form_78.png"/>.</p>
<h2><a class="anchor" id="sec_mipclCutStockColumnGen"></a>
Column generation</h2>
<p>It should be noted that the number of variables, <em>n</em>, in IP (1) may be astronomically big. Therefore, even the relaxation LP cannot be solved in the usual way. But such LPs with exponentially many columns can be solved using the <em>column-generation</em> technique which, in its essence, consists in the following. At the beginning, a relatively small family of patterns, <img class="formulaInl" alt="$a^1,\dots,a^k$" src="form_82.png"/>, is build so that the following <em>truncated LP</em></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{j=1}^k x_j &amp;\to \min,\\ \sum_{j=1}^k a_{ij} x_j &amp;\ge q_i,\quad i=1,\dots,m,\tag{2}\\ x_j &amp;\ge 0,\quad j=1,\dots,k, *\end{align*}" src="form_83.png"/>
</p>
<p>had a feasible solution. Let <img class="formulaInl" alt="$y^*$" src="form_84.png"/> be an optimal dual solution to (2). Nonzero components $x_j^*$ of an optimal prime solution to the truncated LP&#160;(2) are nonzero components of a solution to the relaxation LP for IP~(1), if the inequalities </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=1}^m a_{ij} y^*_i \le 1,\quad j=1,\dots,n,\tag{3} \]" src="form_85.png"/>
</p>
<p> hold.</p>
<p>To verify the validity of (3), it is enough to solve the following <em>pricing problem</em>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \sum_{i=1}^m y^*_i z_i &amp;\to \max,\notag\\ \sum_{i=1}^m l_i z_i &amp;\le L,\tag{4}\\ z_i &amp;\in \mathbb{Z}_+,\quad i=1,\dots,m.\notag \end{align}" src="form_86.png"/>
</p>
<p>This is an <em>integer-knapsack problem</em>. It can be solved relatively easily by dynamic programming. Let <img class="formulaInl" alt="$z^*$" src="form_87.png"/> be an optimal solution to (4). If <img class="formulaInl" alt="$\sum_{i=0}^m y^*_i z^*_i \le 1$" src="form_88.png"/>, then all inequalities in (3) are satisfied by <img class="formulaInl" alt="$z^*$" src="form_87.png"/>. Otherwise, since <img class="formulaInl" alt="$z^*$" src="form_87.png"/> is a pattern, we add to the truncated LP (2) a new column <img class="formulaInl" alt="$a^{k+1}=z^*$" src="form_89.png"/> with corresponding variable <img class="formulaInl" alt="$x_{k+1}$" src="form_90.png"/>, increase <em>k</em> by 1, and solve this extended LP. We continue adding (generating) new columns until the optimality condition (3) is satisfied.</p>
<p>A commonly accepted approach for solving the cutting-stock problem (1) is to solve the relaxation LP and then round up the components of its optimal solution. For problems with narrow spectra of finals that are to be cut in big quantities, this approach usually gives a near optimum solution. Alternatively, after solving the relaxation LP, we can continue solving the problem by a branch-and-cut algorithm without generating columns.</p>
<h2><a class="anchor" id="sec_mipclCutStockInit"></a>
Finding a good initial solution</h2>
<p>When applying a column generation algorithm, it is highly desirable to start with a such truncated LP (1) which objective value is close to the optimal objective value of the full LP. Here we present a heuristic that builds a reasonably good set of patterns. This heuristic is based on the assumption that long finals are cut off first, and short finals are cut off from leftovers.</p>
<p><em>Initialization</em>.</p><ul>
<li>List finals in decreasing order of their lengths: <img class="formulaInl" alt="$l_{\pi(1)} &gt; l_{\pi(2)} &gt;\dots &gt; l_{\pi(m)}$" src="form_91.png"/>.</li>
<li>Set <img class="formulaInl" alt="$b=q,\; I=(\pi(1),\dots,\pi(m)),\; k=0$" src="form_92.png"/>.</li>
</ul>
<p><em>General step</em>. </p><ul>
<li>
While <img class="formulaInl" alt="$I\neq\emptyset$" src="form_93.png"/> carry out the next steps. <ul>
<li>
Set <img class="formulaInl" alt="$k:=k+1,\; W=L,\; x_k=\infty$" src="form_94.png"/>. </li>
<li>
For all <img class="formulaInl" alt="$i\not\in I,\text{ set } a^k_i=0$" src="form_95.png"/>. </li>
<li>
For <img class="formulaInl" alt="$i=1,\dots,|I|$" src="form_96.png"/>, <ul>
<li>
set <img class="formulaInl" alt="$a^k_{I[i]}=\left\lfloor\frac{W}{l_{I[i]}}\right\rfloor,\; W:=W-a^k_{I[i]}\cdot l_{I[i]}$" src="form_97.png"/>; </li>
<li>
if <img class="formulaInl" alt="$x_k a^k_{I[i]} &gt; b_{I[i]},\text{ set } x_k=\left\lceil\frac{b_{I[i]}}{a^k_{I[i]}}\right\rceil$" src="form_98.png"/>. </li>
</ul>
</li>
<li>
Set <img class="formulaInl" alt="$b:=b-x_k a^k$" src="form_99.png"/> and remove from the list <em>I</em> all elements <em>s</em> such that <img class="formulaInl" alt="$b_s\le 0$" src="form_100.png"/>, preserving the order of the elements that are left.  </li>
</ul>
</li>
</ul>
<p>For illustration, let us apply this heuristic to the cutting-stock example with the following numeric parameters: <em>L</em>=100, <img class="formulaInl" alt="$l_1=45,\; l_2=36,\; l_3=31,\; l_4=14$" src="form_101.png"/>, <img class="formulaInl" alt="$q_1=97,\; q_2=610,\; q_3=395,\; q_4=211$" src="form_102.png"/>.</p>
<p><em>Initialization</em>. Set <img class="formulaInl" alt="$b=(97,610,395,211),\; I=(1,2,3,4),\; k=0$" src="form_103.png"/>.</p>
<p><em>Step</em> 1. Set <img class="formulaInl" alt="$W=100,\; x_1=\infty$" src="form_104.png"/>. Compute in sequence </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a^1_1 &amp;=&amp; \left\lfloor\frac{100}{45}\right\rfloor =2,\quad W = 100 -2\cdot 45 = 10,\quad x_1=\left\lceil\frac{97}{2}\right\rceil=49;\\ a^1_2 &amp;=&amp; \left\lfloor\frac{10}{36}\right\rfloor=0;\quad a^1_3 = \left\lfloor\frac{10}{31}\right\rfloor=0;\quad a^1_4 = \left\lfloor\frac{10}{14}\right\rfloor=0. \end{eqnarray*}" src="form_105.png"/>
</p>
<p> Set <img class="formulaInl" alt="$b=(97,610,395,211)-49(2,0,0,0)=(-1,610,395,211),\quad I=(2,3,4)$" src="form_106.png"/>.</p>
<p><em>Step</em> 2. Set <img class="formulaInl" alt="$W=100,\; x_2=\infty$" src="form_107.png"/>. Compute in sequence </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a^2_1 &amp;=&amp; 0;\\ a^2_2 &amp;=&amp; \left\lfloor\frac{100}{36}\right\rfloor=2;\quad W = 100 -2\cdot 36 = 28,\quad x_2=\left\lceil\frac{610}{2}\right\rceil=305;\\ a^2_3 &amp;=&amp; \left\lfloor\frac{28}{31}\right\rfloor=0;\\ a^2_4 &amp;=&amp; \left\lfloor\frac{28}{14}\right\rfloor=2,\quad W = 28 -2\cdot 14 = 0,\quad x_2=\left\lceil\frac{211}{2}\right\rceil=106. \end{eqnarray*}" src="form_108.png"/>
</p>
<p> Set <img class="formulaInl" alt="$b=(-1,610,395,211)-106(0,2,0,2)=(-1,398,395,-1),\quad I=(2,3)$" src="form_109.png"/>.</p>
<p><em>Step</em> 3. Set <img class="formulaInl" alt="$W=100,\; x_3=\infty$" src="form_110.png"/>. Compute in sequence </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a^3_1 &amp;=&amp; 0;\\ a^3_2 &amp;=&amp; \left\lfloor\frac{100}{36}\right\rfloor=2;\quad W = 100 -2\cdot 36 = 28,\quad x_3=\left\lceil\frac{398}{2}\right\rceil=199;\\ a^3_3 &amp;=&amp; \left\lfloor\frac{28}{31}\right\rfloor=0;\quad a^3_4 = 0. *\end{eqnarray*}" src="form_111.png"/>
</p>
<p> Set <img class="formulaInl" alt="$b=(-1,398,395,-1)-199(0,2,0,0)=(-1,0,395,-1),\quad I=(3)$" src="form_112.png"/>.</p>
<p><em>Step</em> 4. Set <img class="formulaInl" alt="$W=100,\; x_4=\infty$" src="form_113.png"/>. Compute in sequence </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} a^4_1 &amp;=&amp; 0;\quad a^4_2 = 0;\\ a^4_3 &amp;=&amp; \left\lfloor\frac{100}{31}\right\rfloor=3;\quad W = 100 -3\cdot 31 = 7,\quad x_4=\left\lceil\frac{395}{3}\right\rceil=132;\\ a^4_4 = 0. \end{eqnarray*}" src="form_114.png"/>
</p>
<p> Set <img class="formulaInl" alt="$b=(-1,0,395,-1)-132(0,0,3,0)=(-1,0,-1,-1),\quad I=\emptyset$" src="form_115.png"/>.</p>
<h2><a class="anchor" id="sec_mipclCutStockImpl"></a>
MIPCL implementation</h2>
<p>To implement a <b>MIPCL</b> application that generates columns, one has to extend one of the base classes, <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> or <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>. Since we are going to elaborate a simplified branch-and-price algorithm that generates column only at the root node, our class, named <code>CCutStock</code>, extends <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. Its definition is as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cmip_8h.html">cmip.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>CCutStock: <span class="keyword">public</span> <a class="code" href="classCMIP.html">CMIP</a></div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> *m_dpF;</div><div class="line">        <span class="keywordtype">int</span>     *m_ipFinalLength;</div><div class="line">        <span class="keywordtype">int</span> *m_ipFinalNum;</div><div class="line">        <span class="keywordtype">int</span> m_iRawLength;</div><div class="line">        <span class="keywordtype">int</span> m_iFinalTypeNum;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">        CCutStock(<span class="keyword">const</span> <span class="keywordtype">char</span>* name);</div><div class="line">        <span class="keyword">virtual</span> ~CCutStock();</div><div class="line"></div><div class="line"><span class="preprocessor">        #ifndef __ONE_THREAD_</span></div><div class="line">        CCutStock(<span class="keyword">const</span> CCutStock &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">        <a class="code" href="classCMIP.html">CMIP</a>* <a class="code" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a>(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> init(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> *l, <span class="keywordtype">int</span> *q, <span class="keywordtype">int</span> L);</div><div class="line">        <span class="keywordtype">void</span> newColumn(<span class="keywordtype">int</span> &amp;k, <span class="keywordtype">int</span> *S, <span class="keywordtype">int</span> *b, <span class="keywordtype">int</span> &amp;sz);</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns</a>(<span class="keywordtype">int</span> m, <span class="keyword">const</span> tagHANDLE *ipRowHd, <span class="keyword">const</span> <span class="keywordtype">double</span> *dpY) <span class="keyword">final</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">double</span> intKnapsack(<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> *c, <span class="keywordtype">int</span> *a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span>*x, <span class="keywordtype">double</span> *dpMem=0);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a91249febf036dd979f7584bc0962137a">printSolution</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* name=0);</div><div class="line">};</div></div><!-- fragment --><p><code>CCutStock</code> has the following members:</p><ul>
<li><code>m_iRawWidth</code>: length of roll;</li>
<li><code>m_iFinalTypeNum</code>: number of finals;</li>
<li><code>m_ipFinalLength</code>: pointer (memory is not allocated) to array of size <code>m_iFinalTypeNu</code>, <code>m_ipFinalLength[i]</code> is length of final <code>i</code>;</li>
<li><code>m_ipFinalNum</code>: pointer (memory is not allocated) to array of size <code>miFinalTypeNum</code>, <code>m_ipFinalNum[i]</code> is demand for finals of type <code>i</code>;</li>
<li><code>m_dpF</code>: array of size <code>m_iRawWidth+1</code> that is used in function <code>intKnapsack()</code>.</li>
</ul>
<p>The <code>CCutStock</code> constructor set the value of pointer <code>m_ipF</code> to <code>0</code> (to mark that it does not point to any piece of memory) and calls the constructor <code><a class="el" href="classCMIP.html#a0565b27e1966ceb19380a4d3d7bcec5a">CMIP::CMIP(const char *name)</a></code> of the base class.</p>
 </p><div class="fragment"><div class="line">CCutStock::CCutStock(<span class="keyword">const</span> <span class="keywordtype">char</span>* name): m_dpF(0), <a class="code" href="classCMIP.html">CMIP</a>(name)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p>Since <code>CCutStock</code> does not modify the matrix (internal <b>MIPCL</b> structures used to represent node LPs), except for the root node, our implementation of the clone constructor is standard. </p><div class="fragment"></div><!-- fragment --><p>The <code>init()</code> function, given a description of a cutting stock instance, builds a <b>MIPCL</b> representation of some truncated LP (2).</p>
<div class="fragment"></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">CLP::openMatrix()</a></code>, <code><a class="el" href="classCLP.html#a27e86b274e43b78732ff9f51b9249f33">CLP::closeMatrix()</a></code>, <code><a class="el" href="classCLP.html#a0d5b435146fc416d5bc296f0acbbf029">CLP::addCtr()</a></code>, <code><a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">CLP::addColumn()</a></code>, <code><a class="el" href="classCLP.html#ad1cc3d96268be208d0e9a730b067f1f1">CLP::setObjSense()</a></code>, <code><a class="el" href="classCLP.html#a7f638d505d663c8782b2935e8410b3be">CLP::preprocOff()</a></code>, and <code><a class="el" href="namespaceSORT.html#afd437a8ff18ca90afc1e92232bb91841" title="lists indices ipInd[i] in non-increasing order of values ipVal[ipInd[i]].">SORT::decSortInt()</a></code>.</dd></dl>
<p>Input parameters of <code>init()</code> are</p><ul>
<li><code>m</code>: number of finals;</li>
<li><code>l</code>: array of size <code>m</code>, <code>l[i]</code> is length of final <code>i</code>;</li>
<li><code>q</code>: array of size <code>m</code>, <code>q[i]</code> is demand for finals <code>i</code>;</li>
<li><code>L</code>: roll length.</li>
</ul>
<p>First, <code>init()</code> stores the values of all input parameters in the corresponding <code>CCutStock</code> members. Next, memory is allocated for the auxiliary array <code>m_ipF</code> used when solving integer knapsack problems. Then the matrix is opened with <code>m</code> rows, minimum <code>m</code> and maximum <code>3*m</code> columns, and minimum <code>m*m</code> and maximum <code>3*m*m</code> non-zero entries; it will be possible to generate columns (parameter&#160;5 is set to <code>true</code>), but rows cannot be generate (parameter&#160;4 is set to <code>false</code>).</p>
<p>Next, we add <code>m</code> empty (without entries) rows to the matrix; the left hand side of row &#160;<code>i</code> equals <code>q[i]</code>, while the right hand side is set to <img class="formulaInl" alt="$\infty$" src="form_116.png"/>. Simultaneously, the array <code>S</code> is initialized to store the values form <code>0</code> to <code>m-1</code>.</p>
<p>Two lines </p><pre class="fragment">memcpy(b=S+m,q,m*sizeof(int));
SORT::decSortInt(m,S,l);
</pre><p>implement the initialization step of the heuristic presented in <a class="el" href="cutStock.html#sec_mipclCutStockInit">Finding a good initial solution</a>. Each iterate of the loop that follows these two lines calls <code>newColumn()</code> to compute and then add to the matrix one column of the initial truncated LP. Since we allocated enough memory for storing columns and row, we do not expect memory reallocations, and therefore, we use <code>addColumn()</code> instead of <code>safeAddColumn()</code> which is usually applied when internal <b>MIPCL</b> arrays are used for storing row or column entries.</p>
<p>At the very end, <code>init()</code> switches off preprocessing, which is usual for incomplete formulations, sets the objective sence to "minimize", and closes the matrix.</p>
<p>The procedure <code>newColumn()</code>, presented below, carries out one iterate of the general step of the heuristic presented in <a class="el" href="cutStock.html#sec_mipclCutStockInit">Finding a good initial solution</a>.</p>
<div class="fragment"></div><!-- fragment --><p><code>newColumn()</code> parameters:</p><ul>
<li><code>k</code> (in): size of list;</li>
<li><code>S</code> (in): array (list) of size <code>k</code>;</li>
<li><code>b</code> (in): array of size <code>m_iFinalTypeNum</code>, <code>b[i]</code> is number of finales of type <code>i=S[j]</code> to be cut off, <code>j=1,...,k</code>;</li>
<li><code>S</code> (out): altered list of size <code>k</code>;</li>
<li><code>sz</code> (out): number of non-zeroes in column, <code>m_dpArray[i]</code> is nonzero entry in row <code>m_ipArray[i]</code>, <code>i=0,...,sz-1</code>.</li>
</ul>
<p>The function <code>generateColumns()</code> the function <code><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">CMIP::generateColumns()</a></code>.</p>
<div class="fragment"></div><!-- fragment --><p>Let us note that we agreed to generate columns only at the root node (of depth <code>0</code>) of the search tree. Therefore, if <code>getCurrentNodeHeight()</code> returns a nonzero value, <code>generateColumns()</code> terminates with the return value <code>false</code>. In LPs with the objective to be maximized, dual variables for constraints of type "greater or equal" are non-positive. That is why, when defining objective coefficients, we negate the values of all dual variables.</p>
<p><code>generateColumns()</code> calls <code>intKnapsack()</code> to solve pricing problem (4). In general, <code>intKnapsack()</code> solves the <em>integer knapsack problem</em></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\displaystyle \max\left\{\sum_{j=1}^n c_j x_j:\: \sum_{j=1}^n c_j x_j\le b,\; x\in \mathbb{Z}^n\right\}\]" src="form_117.png"/>
</p>
<p>by dynamic programming. Here we do not give its implementation. The parameters of <code>intKnapsack()</code> are the following:</p><ul>
<li><code>n</code> (in): number of variables;</li>
<li><code>c</code> (in): array (of size <code>n</code>) of objective coefficients;</li>
<li><code>a</code> (in): array (of size <code>n</code>) of constraint coefficients;</li>
<li><code>b</code> (in): right hand side of constraint;</li>
<li><code>x</code> (out): array (of size <code>n</code>) of solution components.</li>
</ul>
<p><code>intKnapsack()</code> returns the optimal objective value.</p>
<p>So far, we have not mentioned only one <code>CCutStock</code> function, <code>printSolution()</code>.</p>
<div class="fragment"></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCLP.html#a7ca5b92a36189f315f43067727cf510a">CLP::getProblemName()</a></code> and <code><a class="el" href="classCMIP.html#a536ace1560abb8de5c9b7941720df9b4">CMIP::getSolution()</a></code>.</dd></dl>
<p><code>printSolution()</code> is an auxiliary function that writes in a readable format the solution found to the file which name is passed as its only argument <code>name</code>. To get the pointers to the array representing the solution, we call the function <code>getSolution()</code>, which returns two pointers <code>x</code> and <code>ipHd</code>, where <code>x[i]</code> is the value of the variable with handle <code>ipHd[i]</code>. Usually, <b>MIPCL</b> does not preserve the order in which the variables were added to the matrix. But when preprocessing is switched off, the <code>x[j]</code> is the value of variable indexed by <code>j</code>.</p>
<h3><a class="anchor" id="sec_mipclCutStockMain"></a>
Program that solves cutting stock problem</h3>
<p>Now we present a small program that reads a cutting stock instance from a text file, and then solves that instance using functionality of <code>CCutStock</code>.</p>
 </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Enter file name!\n&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line">        <span class="keywordtype">int</span> m,L, *l,*q;</div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">                readData(argv[1],m,L,l,q);</div><div class="line">                CCutStock prob(<span class="stringliteral">&quot;CutStock&quot;</span>);</div><div class="line">                prob.init(m,l,q,L);</div><div class="line">                prob.optimize();</div><div class="line">                <span class="keywordtype">char</span> sol[256];</div><div class="line">                strcpy(sol,argv[1]);</div><div class="line">                strcat(sol,<span class="stringliteral">&quot;.sol&quot;</span>);</div><div class="line">                prob.printSolution(sol);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span>(<a class="code" href="classCException.html">CException</a>* pe) {</div><div class="line">                std::cerr &lt;&lt; pe-&gt;<a class="code" href="classCException.html#af66e5406dda297fa8b253e89b6e00973">what</a>() &lt;&lt; std::endl;</div><div class="line">                <span class="keyword">delete</span> pe;</div><div class="line">                <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">} <span class="comment">// end of main()</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">CMIP::optimize()</a>.</dd></dl>
<p>The main procedure of our application first calls <code>readData()</code> to read a a cutting stock instance from a text file, then creates a <code>CCutStock</code> object, <code>prob</code>, and calls its functions <code>init()</code> and <code>optimize()</code> (member of <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>) to solve that instance.</p>
 </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> readData(<span class="keywordtype">char</span> *fileName, <span class="keywordtype">int</span> &amp;m, <span class="keywordtype">int</span> &amp;L, <span class="keywordtype">int</span>* &amp;l, <span class="keywordtype">int</span>* &amp;q)</div><div class="line">{</div><div class="line">        std::ifstream fin(fileName);</div><div class="line">        <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">                <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="code" href="classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;readData&quot;</span>,fileName);</div><div class="line">        }</div><div class="line">        fin &gt;&gt; m &gt;&gt; L;</div><div class="line">        <span class="keywordflow">if</span> (m &lt;= 0 || m &gt; 100000 || L &lt;= 0 || L &gt; 100000) {</div><div class="line">                <span class="keywordtype">char</span> msg[256];</div><div class="line">                sprintf(msg,<span class="stringliteral">&quot;Parameters m=%d and L=%d are out of range!&quot;</span>,m,L);</div><div class="line">                <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="code" href="classCDataException.html">CDataException</a>(msg);</div><div class="line">        }</div><div class="line">        l = <span class="keyword">new</span>(std::nothrow) <span class="keywordtype">int</span>[m];</div><div class="line">        q = <span class="keyword">new</span>(std::nothrow) <span class="keywordtype">int</span>[m];</div><div class="line">        <span class="keywordflow">if</span> (!l || !q)</div><div class="line">                <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="code" href="classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;readData()&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; m; i++) {</div><div class="line">                fin &gt;&gt; l[i] &gt;&gt; q[i];</div><div class="line">        }</div><div class="line">        fin.close();</div><div class="line">} <span class="comment">// end of readData()</span></div></div><!-- fragment --><p>Parameters of <code>readData()</code>:</p><ul>
<li><code>fileName</code> (in): name of text file;</li>
<li><code>m</code> (out): number of finals;</li>
<li><code>L</code> (out): roll length;</li>
<li><code>l</code> (out): array of size <code>m</code>, where <code>w[i]</code> is length of final <code>i</code>;</li>
<li><code>q</code> (out): array of size <code>m</code>, where <code>q[i]</code> is required quantity of final <code>i</code>;</li>
</ul>
<p>To compile our program, enter the following commands </p><pre class="fragment"> cd $MIPCLDIR/examples/cutStock/release
 make all
</pre><p>To solve our illustrative example, enter the following commands </p><pre class="fragment">cd $MIPCLDIR/examples/cutStock/tests
$MIPCLDIR/examples/bin/cutstock test1.txt
</pre><p>to find the result written to the text file <code>test1.txt.sol</code>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:33 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
