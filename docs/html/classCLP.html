<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: CLP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">CLP Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class has been designed for solving Linear Programs (LPs)  
 <a href="classCLP.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lp_8h_source.html">lp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CLP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classCLP.png" usemap="#CLP_map" alt=""/>
  <map id="CLP_map" name="CLP_map">
<area href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)" alt="CMIP" shape="rect" coords="0,56,43,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ace10a11a6c69fa8274ad8bc2c0930adb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">enAlign</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba34241e0294a551922cb9654241c0264e">ALIGN_NONE</a> = 0x00000000, 
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba5b32d4c1a0a5ac7c241c11a6163c91e3">ALIGN_COLUMN_APPR</a> = 0x00000001, 
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba7120d50531f63f160b00ee40e0890dee">ALIGN_COLUMN</a> = 0x00000011, 
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adbabaed747e2cb0b5a487629baf13187eff">ALIGN_ROW_APPR</a> = 0x00000100, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adba11b7111fe3445164fabe75cf968797b7">ALIGN_ROW</a> = 0x00001100
<br />
 }</td></tr>
<tr class="memdesc:ace10a11a6c69fa8274ad8bc2c0930adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix alignment.  <a href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">More...</a><br /></td></tr>
<tr class="separator:ace10a11a6c69fa8274ad8bc2c0930adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac886bb1c9454ba327bc52b46b72f7ac5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5">enCtrType</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a17870c44aecd572149dda0acb4e4a4e1">CTR_ATTACHED</a> = 0x00000001, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a4ee63b4bd702d2ace98cbed25c6cbad3">CTR_LEFT</a> = 0x00000002, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a71ef23a0ef46d3a746342572433e4005">CTR_RIGHT</a> = 0x00000004, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a7cc6aa09c75f6c23bd366a2db73be4d3">CTR_EQ</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a8590663fa4e694651fdb18d53692f8b0">CTR_REF</a> = 0x00000010, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5a7baf38b91fd84aef5a2a1427a29d85e1">CTR_NOT_STABLE</a> = 0x00000020, 
<a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5aa8a12a75b7a358499e47f39d2f95a09e">CTR_STRONG_CUT</a> = 0x80000000
<br />
 }</td></tr>
<tr class="memdesc:ac886bb1c9454ba327bc52b46b72f7ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP types of constraints.  <a href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5">More...</a><br /></td></tr>
<tr class="separator:ac886bb1c9454ba327bc52b46b72f7ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89292c62c83b834a8b451bde23c67627"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627">enVarType</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a5d331e9cfab0f7598da11cd0ea9ebc03">VAR_LEFT</a> = 0x10000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627ad51df68c924dac7c246f9c30cc587b2e">VAR_RIGHT</a> = 0x20000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627ab75d53368c617fc8c888e93c0d03d491">VAR_FX</a> = 0x40000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a9df0f737a50b3d4bd2072c3c15b468fb">VAR_REF</a> = 0x80000000, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a0600f7f3589a4726507c1ea72fd81cdc">VAR_NOT_MOD</a> = 0x04000000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a2f778e20d4c99ef9739681b2bc811b0d">VAR_INT</a> = 0x00001000, 
<a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627a4c836f1a6ffec0f890beb0768c6e3cdd">VAR_BIN</a> = 0x00002000
<br />
 }</td></tr>
<tr class="memdesc:a89292c62c83b834a8b451bde23c67627"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP types of variables.  <a href="classCLP.html#a89292c62c83b834a8b451bde23c67627">More...</a><br /></td></tr>
<tr class="separator:a89292c62c83b834a8b451bde23c67627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69612f747174f3c3e3a19f17cc290877"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">enScaling</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a9532f46e77b8de78728d81810061351b">SCL_MINMAX</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a2b3dcc735540c010ca52f111da1c3dc3">SCL_IDEAL</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a631c5045eeaeb601216f6656771dbbce">SCL_NO</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ada2e041936a7a640550da4030530efdc">SCL_GM_ROWS</a>, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a3cfbdf746ead117eef50c65af47ee2b7">SCL_GM_COLUMNS</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac0fb16c8f4cdc516084e20388b16b3a8">SCL_MAX_ROWS</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a787bfbff974c356dd7176911fbb4b75e">SCL_MAX_COLUMNS</a>, 
<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a> =127, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877a745b552b1fe7fdce8d141b0e2871dfd7">SCL_MIN_EXP</a> =-19
<br />
 }</td></tr>
<tr class="memdesc:a69612f747174f3c3e3a19f17cc290877"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the list of all possible ways to scale matrix.  <a href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">More...</a><br /></td></tr>
<tr class="separator:a69612f747174f3c3e3a19f17cc290877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7aedeedf26a9bcab5d5e32c528131e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a> { <a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131ea697958327067d98ba307d62f67481c0e">AUTO_DETECT</a>, 
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131ea35f36965643458a225f51afbb5397d7a">PRIME_SIMPLEX</a>, 
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131eaeed16c0d496a65145f7141620c5672d0">DUAL_SIMPLEX</a>
 }</td></tr>
<tr class="memdesc:a2a7aedeedf26a9bcab5d5e32c528131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP methods.  <a href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">More...</a><br /></td></tr>
<tr class="separator:a2a7aedeedf26a9bcab5d5e32c528131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7826c555555d1888a96efa8572f584"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a> { <a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584a3d90bed8af607e02248519ef975a5fd2">SEP_MOST_VIOLATED</a>, 
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584aca8dfbedb02a31e924028a8654748398">SEP_ONLY_EQUATIONS</a>, 
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584a93f0269d58431e5756c7f60d41e04cf9">SEP_STEEPEST_EDGE</a>
 }</td></tr>
<tr class="memdesc:abd7826c555555d1888a96efa8572f584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separation rules.  <a href="classCLP.html#abd7826c555555d1888a96efa8572f584">More...</a><br /></td></tr>
<tr class="separator:abd7826c555555d1888a96efa8572f584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c02821b739c221b8e3672a46bc4ea5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a> { <a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5ae48c44231bbfa3ac7fe3fe5da097ff07">PRC_MOST_NEGATIVE</a>, 
<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5aa4e9e8e12c37d6c438d381a83548a716">PRC_STEEPEST_EDGE</a>
 }</td></tr>
<tr class="memdesc:ad5c02821b739c221b8e3672a46bc4ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pricing rules.  <a href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">More...</a><br /></td></tr>
<tr class="separator:ad5c02821b739c221b8e3672a46bc4ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e51337d2a33971e7a2264f67ca2da7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7c">enProbState</a> { <br />
&#160;&#160;<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca300af909e7e8cc4050337ef393e3b621">PROB_IN_MEMORY</a> = 0x00000001, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca4260338e83d735350ac2666fd3f6961c">PROB_PREPARED</a> = 0x00000002, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7cadb019ad240e07281feac40268900ed8c">PROB_SOLVED</a> = 0x00000004, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca8a28cfac879be4fe1d8b1a8a730c31db">PROB_SOLUTION</a> = 0x00000008, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca765cf6c45c6287f4455c63caa5fcf124">PROB_OPTIMAL</a> = 0x00000010, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca753e10e160501d94a4d8323eca7bd122">PROB_INFEASIBLE</a> = 0x00000020, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca344a364e11ae7dac9083dfdf55350730">PROB_UNBOUNDED</a> = 0x00000040, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca66f16d92983df6d6c7ab69d86cad91dc">PROB_TIME_LIMIT</a> = 0x00000080, 
<br />
&#160;&#160;<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca3b27f003075cc320ebfd74e650faf954">PROB_IT_LIMIT</a> = 0x00000100, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7cab13b9d0a37f3789e994cf1f80a37b313">PROB_GAP_LIMIT</a> = 0x00000200, 
<a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7ca0e5044d101dabb9568bb3e9daa858a88">PROB_SOLVER_FLAGS</a> = PROB_SOLVED|PROB_SOLUTION|PROB_OPTIMAL|PROB_INFEASIBLE|PROB_UNBOUNDED|PROB_TIME_LIMIT|PROB_GAP_LIMIT
<br />
 }</td></tr>
<tr class="memdesc:a5e51337d2a33971e7a2264f67ca2da7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem states.  <a href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7c">More...</a><br /></td></tr>
<tr class="separator:a5e51337d2a33971e7a2264f67ca2da7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8a9c8d5a775156d30aecba3bf74511"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511">enRowColGenRule1</a> { <a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511ac4fc40898634e36cad90e2bcd27f99fa">ROW_GEN</a> = 0x1, 
<a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511aacfac1c0a7476a3f064a96e49be704e5">COL_GEN</a> = 0x2, 
<a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511a004c24655361633c62bdf2ac91754b21">SEP_PROC</a> = 0x4
 }</td></tr>
<tr class="separator:add8a9c8d5a775156d30aecba3bf74511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbd20f2d40a5aec4e06474a7bef2b2d"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a></td></tr>
<tr class="memdesc:accbd20f2d40a5aec4e06474a7bef2b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">program type for handles of variables and constraints  <a href="#accbd20f2d40a5aec4e06474a7bef2b2d">More...</a><br /></td></tr>
<tr class="separator:accbd20f2d40a5aec4e06474a7bef2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae15b567a7fcdf060320225b107e5a7c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae15b567a7fcdf060320225b107e5a7c2">getStartTime</a> () const</td></tr>
<tr class="separator:ae15b567a7fcdf060320225b107e5a7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c239f18033b08ccc18a711d953765b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a96c239f18033b08ccc18a711d953765b">getSolTime</a> () const</td></tr>
<tr class="separator:a96c239f18033b08ccc18a711d953765b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb64ae5e18034796c87fd473f889a5fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adb64ae5e18034796c87fd473f889a5fd">isCLP</a> ()</td></tr>
<tr class="separator:adb64ae5e18034796c87fd473f889a5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0040e9c15a3ed866edc35a5b1cd6896b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0040e9c15a3ed866edc35a5b1cd6896b">openLogStream</a> (const char *name=0)</td></tr>
<tr class="separator:a0040e9c15a3ed866edc35a5b1cd6896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58522cc43d5bc30264c9fed54e3f8a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad58522cc43d5bc30264c9fed54e3f8a4">setVarInf</a> (double inf)</td></tr>
<tr class="separator:ad58522cc43d5bc30264c9fed54e3f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfd0f57b4fea770d264857d149c2c51"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3bfd0f57b4fea770d264857d149c2c51">getVarInf</a> () const</td></tr>
<tr class="separator:a3bfd0f57b4fea770d264857d149c2c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3fdda6619175bb60893ed01f97648d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7a3fdda6619175bb60893ed01f97648d">writeStrToLogStream</a> (const char *str)</td></tr>
<tr class="separator:a7a3fdda6619175bb60893ed01f97648d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9cc1618db03af0e431b1404b392af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5d9cc1618db03af0e431b1404b392af6">setProblemName</a> (const char *name)</td></tr>
<tr class="separator:a5d9cc1618db03af0e431b1404b392af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca5b92a36189f315f43067727cf510a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7ca5b92a36189f315f43067727cf510a">getProblemName</a> (char *name) const</td></tr>
<tr class="separator:a7ca5b92a36189f315f43067727cf510a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c00ecaf1e40dc3077988b1a75190e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1c00ecaf1e40dc3077988b1a75190e2c">setZero</a> (double zero)</td></tr>
<tr class="separator:a1c00ecaf1e40dc3077988b1a75190e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993a49b26e7fcda789a74d055b2d9d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4993a49b26e7fcda789a74d055b2d9d7">getZero</a> () const</td></tr>
<tr class="separator:a4993a49b26e7fcda789a74d055b2d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378a97cf0e8477e6f81c2ea40b760897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol</a> (double tolPiv, double relTolPiv, double goodPiv, double tolPivErr, double relTolPivErr)</td></tr>
<tr class="separator:a378a97cf0e8477e6f81c2ea40b760897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac816fe1f356205b0fef57c3cdb500ca0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac816fe1f356205b0fef57c3cdb500ca0">getPivTol</a> () const</td></tr>
<tr class="separator:ac816fe1f356205b0fef57c3cdb500ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e52370b1b816c402867dd27aeb0c64f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1e52370b1b816c402867dd27aeb0c64f">getGoodPiv</a> () const</td></tr>
<tr class="separator:a1e52370b1b816c402867dd27aeb0c64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd3feb9f48d6a206cef0e7c74dceebe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1fd3feb9f48d6a206cef0e7c74dceebe">getRelPivTol</a> () const</td></tr>
<tr class="separator:a1fd3feb9f48d6a206cef0e7c74dceebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f1b1273fc526e772a8bc17f7df93e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60f1b1273fc526e772a8bc17f7df93e5">getPivErrTol</a> () const</td></tr>
<tr class="separator:a60f1b1273fc526e772a8bc17f7df93e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f7fcadce90f9e2f0200641e389839"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af24f7fcadce90f9e2f0200641e389839">getRelPivErrTol</a> () const</td></tr>
<tr class="separator:af24f7fcadce90f9e2f0200641e389839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576593762fc04542102b77b183fe1b5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a576593762fc04542102b77b183fe1b5a">setVarTol</a> (double tol)</td></tr>
<tr class="separator:a576593762fc04542102b77b183fe1b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08c3dd8c2a520eab4122a2789609810"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac08c3dd8c2a520eab4122a2789609810">getVarTol</a> () const</td></tr>
<tr class="separator:ac08c3dd8c2a520eab4122a2789609810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eda3b06a9294104d19ad3fce885b007"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8eda3b06a9294104d19ad3fce885b007">setCtrTol</a> (double tol)</td></tr>
<tr class="separator:a8eda3b06a9294104d19ad3fce885b007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeddcd066d467d08fb8328f7ccae88f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aaeddcd066d467d08fb8328f7ccae88f8">getCtrTol</a> () const</td></tr>
<tr class="separator:aaeddcd066d467d08fb8328f7ccae88f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac888a61e64a5f4a3a52bbfd2cbc3cac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac888a61e64a5f4a3a52bbfd2cbc3cac3">setShadowPriceTol</a> (double tol)</td></tr>
<tr class="separator:ac888a61e64a5f4a3a52bbfd2cbc3cac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccd228f5834359466cff18b0f6f05f0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9ccd228f5834359466cff18b0f6f05f0">getShadowPriceTol</a> () const</td></tr>
<tr class="separator:a9ccd228f5834359466cff18b0f6f05f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7feb77a91a7839b570a69e712da2a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad7feb77a91a7839b570a69e712da2a83">setRedCostTol</a> (double tol)</td></tr>
<tr class="separator:ad7feb77a91a7839b570a69e712da2a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a0519468aae3f041641948cf59aea2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a14a0519468aae3f041641948cf59aea2">getRedCostTol</a> () const</td></tr>
<tr class="separator:a14a0519468aae3f041641948cf59aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eb4ddddfc54fd90df48a07e89c555b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa6eb4ddddfc54fd90df48a07e89c555b">setDegenTol</a> (double primeDegTol, double dualDegTol)</td></tr>
<tr class="separator:aa6eb4ddddfc54fd90df48a07e89c555b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a48a82310b64fbfd5db845cf6fe11"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae39a48a82310b64fbfd5db845cf6fe11">getPrimeDegTol</a> () const</td></tr>
<tr class="separator:ae39a48a82310b64fbfd5db845cf6fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0af3765cf29ebec0e93462b47958408"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa0af3765cf29ebec0e93462b47958408">getDualDegTol</a> () const</td></tr>
<tr class="separator:aa0af3765cf29ebec0e93462b47958408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e92e08af8ffe926643a4bf18b8c4c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af9e92e08af8ffe926643a4bf18b8c4c9">setVarViolatThreshold</a> (double th)</td></tr>
<tr class="separator:af9e92e08af8ffe926643a4bf18b8c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529998af95e064af12df5e28790958b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a529998af95e064af12df5e28790958b5">getVarViolatThreshold</a> () const</td></tr>
<tr class="separator:a529998af95e064af12df5e28790958b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb50173d4aa205755b0808ab32912992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adb50173d4aa205755b0808ab32912992">setShadowPriceToleranceThreshold</a> (double th)</td></tr>
<tr class="separator:adb50173d4aa205755b0808ab32912992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91942427d24c7c88a0a3feda3bd92b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a91942427d24c7c88a0a3feda3bd92b1a">setScaling</a> (<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">enScaling</a> scalingMethod)</td></tr>
<tr class="separator:a91942427d24c7c88a0a3feda3bd92b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f638d505d663c8782b2935e8410b3be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7f638d505d663c8782b2935e8410b3be">preprocOff</a> ()</td></tr>
<tr class="separator:a7f638d505d663c8782b2935e8410b3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9704ad0e87c595e671ed0d45e72eaa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab9704ad0e87c595e671ed0d45e72eaa0">lpInfoMsg</a> () const</td></tr>
<tr class="separator:ab9704ad0e87c595e671ed0d45e72eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6759b414050614829e2e5570e8d03fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6759b414050614829e2e5570e8d03fb6">switchLpInfoMsg</a> (bool flag)</td></tr>
<tr class="separator:a6759b414050614829e2e5570e8d03fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704eb701bea22a2008f3bd02f1c561cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a704eb701bea22a2008f3bd02f1c561cc">beSilent</a> (bool flag=true)</td></tr>
<tr class="separator:a704eb701bea22a2008f3bd02f1c561cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e6dfc38f4087fb3e106663c8da2639"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae1e6dfc38f4087fb3e106663c8da2639">isSilent</a> () const</td></tr>
<tr class="separator:ae1e6dfc38f4087fb3e106663c8da2639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74448bf0bb4ddd874f517399e8789fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad74448bf0bb4ddd874f517399e8789fd">setFrequencyForInfoMsg</a> (int fr)</td></tr>
<tr class="separator:ad74448bf0bb4ddd874f517399e8789fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77d02d81b5e5a3899d084d4e421059e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae77d02d81b5e5a3899d084d4e421059e">setOptFlags</a> (bool primeFeasible, bool dualFeasible)</td></tr>
<tr class="separator:ae77d02d81b5e5a3899d084d4e421059e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c2920755af35791f7244dbe1ccdf4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a16c2920755af35791f7244dbe1ccdf4f">setObjective</a> (const double *dpC, bool sense=true, bool scale=true)</td></tr>
<tr class="separator:a16c2920755af35791f7244dbe1ccdf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c4a43ce27925dc2b132d89475ccc0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a80c4a43ce27925dc2b132d89475ccc0a">setObjective</a> (int i, bool sense=true)</td></tr>
<tr class="separator:a80c4a43ce27925dc2b132d89475ccc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cc3d96268be208d0e9a730b067f1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad1cc3d96268be208d0e9a730b067f1f1">setObjSense</a> (bool sense)</td></tr>
<tr class="separator:ad1cc3d96268be208d0e9a730b067f1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75327ce571f101fe443033506f7423d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a75327ce571f101fe443033506f7423d2">getObjSense</a> () const</td></tr>
<tr class="separator:a75327ce571f101fe443033506f7423d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7842343e7840db5a2284c66428a4b70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad7842343e7840db5a2284c66428a4b70">getVarNum</a> () const</td></tr>
<tr class="separator:ad7842343e7840db5a2284c66428a4b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4080308e4f21d6f55514ac92fc3fb1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af4080308e4f21d6f55514ac92fc3fb1f">getCtrNum</a> () const</td></tr>
<tr class="separator:af4080308e4f21d6f55514ac92fc3fb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368038ca0f767d2aa0deee9e68e070a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af368038ca0f767d2aa0deee9e68e070a">getNonZerosNum</a> () const</td></tr>
<tr class="separator:af368038ca0f767d2aa0deee9e68e070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f623b653c23c1585978f1cbbccab34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a28f623b653c23c1585978f1cbbccab34">isRowGen</a> () const</td></tr>
<tr class="separator:a28f623b653c23c1585978f1cbbccab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e7c2012c4b3bc852a7a2c19e5863a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad90e7c2012c4b3bc852a7a2c19e5863a">isColGen</a> ()</td></tr>
<tr class="separator:ad90e7c2012c4b3bc852a7a2c19e5863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd">CLP</a> (const char *name)</td></tr>
<tr class="separator:a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4fd54e671d455d0c012dc5c768f1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a49d4fd54e671d455d0c012dc5c768f1b">CLP</a> (const <a class="el" href="classCLP.html">CLP</a> &amp;other, int thread)</td></tr>
<tr class="memdesc:a49d4fd54e671d455d0c012dc5c768f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone constructor.  <a href="#a49d4fd54e671d455d0c012dc5c768f1b">More...</a><br /></td></tr>
<tr class="separator:a49d4fd54e671d455d0c012dc5c768f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a01cdc1056b917d6a97fc1787ba26e"><td class="memItemLeft" align="right" valign="top"><a id="a42a01cdc1056b917d6a97fc1787ba26e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a42a01cdc1056b917d6a97fc1787ba26e">~CLP</a> ()</td></tr>
<tr class="memdesc:a42a01cdc1056b917d6a97fc1787ba26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br /></td></tr>
<tr class="separator:a42a01cdc1056b917d6a97fc1787ba26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2170c41aaba9fd1dcd4db56ed7a408"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">openMatrix</a> (int m, int n, int nz, bool bRowGen=true, bool bColGen=false, int mMax=0, int nMax=0, int nzMax=0)</td></tr>
<tr class="separator:acd2170c41aaba9fd1dcd4db56ed7a408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e86b274e43b78732ff9f51b9249f33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a27e86b274e43b78732ff9f51b9249f33">closeMatrix</a> ()</td></tr>
<tr class="separator:a27e86b274e43b78732ff9f51b9249f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b435146fc416d5bc296f0acbbf029"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0d5b435146fc416d5bc296f0acbbf029">addCtr</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double lhs, double rhs)</td></tr>
<tr class="separator:a0d5b435146fc416d5bc296f0acbbf029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7861b5b2e692f6043dfe1d7bd77e21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double lhs, double rhs, int sz, double *dpVal, int *ipCol, bool bSort=true)</td></tr>
<tr class="separator:aee7861b5b2e692f6043dfe1d7bd77e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cfc7443dff945bc5a424fb161e5d5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac7cfc7443dff945bc5a424fb161e5d5c">safeAddRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double lhs, double rhs, int sz, double *&amp;dpVal, int *&amp;ipCol, bool bSort=true)</td></tr>
<tr class="separator:ac7cfc7443dff945bc5a424fb161e5d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e6abd8eca3cbf22a958dbddbfe9069"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a41e6abd8eca3cbf22a958dbddbfe9069">addVar</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u)</td></tr>
<tr class="separator:a41e6abd8eca3cbf22a958dbddbfe9069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1903c28e39c136ec8fcbe9cb65a8bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">addColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u, int sz, double *dpVal, int *ipRow, bool bSort=true)</td></tr>
<tr class="separator:aae1903c28e39c136ec8fcbe9cb65a8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62386390656150763472f05e4419e82d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a62386390656150763472f05e4419e82d">safeAddColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u, int sz, double *&amp;dpVal, int *&amp;ipRow, bool bSort=true)</td></tr>
<tr class="separator:a62386390656150763472f05e4419e82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574534be9bfcd5d37b8cd209cf2e2535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a574534be9bfcd5d37b8cd209cf2e2535">addEntry</a> (double val, int i, int j)</td></tr>
<tr class="separator:a574534be9bfcd5d37b8cd209cf2e2535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd55a5bdee0bded239e5d2d772cbea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aafd55a5bdee0bded239e5d2d772cbea5">changeEntry</a> (double val, int i, int j)</td></tr>
<tr class="separator:aafd55a5bdee0bded239e5d2d772cbea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b1aab13d38650f5c441d2fa986c550"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a63b1aab13d38650f5c441d2fa986c550">getRowSize</a> (int i) const</td></tr>
<tr class="separator:a63b1aab13d38650f5c441d2fa986c550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e320a943d314b9407a03f45e6711a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a747e320a943d314b9407a03f45e6711a">getColumnSize</a> (int j) const</td></tr>
<tr class="separator:a747e320a943d314b9407a03f45e6711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61adc020de168f43627a0d1e3e1a78dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a61adc020de168f43627a0d1e3e1a78dd">getLHS</a> (int i) const</td></tr>
<tr class="separator:a61adc020de168f43627a0d1e3e1a78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4295d11a43be2e37beb19366b97c16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acc4295d11a43be2e37beb19366b97c16">getRHS</a> (int i) const</td></tr>
<tr class="separator:acc4295d11a43be2e37beb19366b97c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07712842e5a79726863b4a08f3e1410a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a07712842e5a79726863b4a08f3e1410a">getVarLoBound</a> (int j) const</td></tr>
<tr class="separator:a07712842e5a79726863b4a08f3e1410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68264a2571e3f720bddb4afb2be3e8a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a68264a2571e3f720bddb4afb2be3e8a5">getVarUpBound</a> (int j) const</td></tr>
<tr class="separator:a68264a2571e3f720bddb4afb2be3e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b76fdfaaea16e1d251688a596e4ad01"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1b76fdfaaea16e1d251688a596e4ad01">getObjCoeff</a> (int j) const</td></tr>
<tr class="separator:a1b76fdfaaea16e1d251688a596e4ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb97ed82d53f698715069ce966a1dd0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeb97ed82d53f698715069ce966a1dd0e">setObjCoeff</a> (int j, double val)</td></tr>
<tr class="separator:aeb97ed82d53f698715069ce966a1dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09cc6122bc3b2f960723b9e6daabfe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac09cc6122bc3b2f960723b9e6daabfe7">setLpPricingRule</a> (<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a> pricingRule)</td></tr>
<tr class="separator:ac09cc6122bc3b2f960723b9e6daabfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885168355b7d81cfa3cb7872ec5ec0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a885168355b7d81cfa3cb7872ec5ec0a4">getPricingRule</a> () const</td></tr>
<tr class="separator:a885168355b7d81cfa3cb7872ec5ec0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb08fe1a8a4075dc382d6df66638061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8bb08fe1a8a4075dc382d6df66638061">setLpSepRule</a> (<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a> sepRule)</td></tr>
<tr class="separator:a8bb08fe1a8a4075dc382d6df66638061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec30b96087c0a237e468907de24c75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acec30b96087c0a237e468907de24c75e">getSepRule</a> () const</td></tr>
<tr class="separator:acec30b96087c0a237e468907de24c75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7f26d09a5c395b7abe013ce5b4b571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7c7f26d09a5c395b7abe013ce5b4b571">setMaxLuUpdateNum</a> (int maxUpdateNum)</td></tr>
<tr class="separator:a7c7f26d09a5c395b7abe013ce5b4b571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58670ea03d928f8310d1974409daba4a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a58670ea03d928f8310d1974409daba4a">getRowValue</a> (int i, double *dpX) const</td></tr>
<tr class="separator:a58670ea03d928f8310d1974409daba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a12c913e4ddbdb194d7b75b11d0500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a30a12c913e4ddbdb194d7b75b11d0500">setLPmethod</a> (<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a> method)</td></tr>
<tr class="separator:a30a12c913e4ddbdb194d7b75b11d0500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19188e63c2b129617b4397812cf7b811"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a19188e63c2b129617b4397812cf7b811">getCurrentLPmethod</a> () const</td></tr>
<tr class="separator:a19188e63c2b129617b4397812cf7b811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cdbbfacf5e68b29ac174c97a392e47"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a06cdbbfacf5e68b29ac174c97a392e47">prepare</a> ()</td></tr>
<tr class="separator:a06cdbbfacf5e68b29ac174c97a392e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62425ce4381d5cb0fa084815590eeb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeToStop=0l, double upperBound=INF, int maxItNum=1000000000, int degCheckInterval=250, int maxDegPrc=90)</td></tr>
<tr class="separator:ac62425ce4381d5cb0fa084815590eeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f4a451dece7eb131a6c63bdcc7189d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeToStop=0l, double lowerBound=-INF, int maxItNum=1000000000, bool needSol=true, bool inconsistSertificate=false, int degCheckInterval=250, int maxDegPrc=90)</td></tr>
<tr class="separator:ae6f4a451dece7eb131a6c63bdcc7189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133727d823c6536163212af7e98ca50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af133727d823c6536163212af7e98ca50">switchOffRowGen</a> ()</td></tr>
<tr class="separator:af133727d823c6536163212af7e98ca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc59423144491763ebe6a328b9678f"><td class="memItemLeft" align="right" valign="top"><a id="a50fc59423144491763ebe6a328b9678f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a50fc59423144491763ebe6a328b9678f">switchOnColGen</a> ()</td></tr>
<tr class="memdesc:a50fc59423144491763ebe6a328b9678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to allow generation of new columns. <br /></td></tr>
<tr class="separator:a50fc59423144491763ebe6a328b9678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0fb59442b39d19e5bfc77b92a935f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a06d0fb59442b39d19e5bfc77b92a935f">setVarBounds</a> (int j, double l, double u)</td></tr>
<tr class="separator:a06d0fb59442b39d19e5bfc77b92a935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164c589a3f2bce353f2585f37ab5109c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a164c589a3f2bce353f2585f37ab5109c">setVarLoBound</a> (int j, double l)</td></tr>
<tr class="separator:a164c589a3f2bce353f2585f37ab5109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4910c689baa5522fc29d77599affc2cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4910c689baa5522fc29d77599affc2cb">setVarUpBound</a> (int j, double u)</td></tr>
<tr class="separator:a4910c689baa5522fc29d77599affc2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31b76176f5ffbcaf2898eaa2d1a2e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab31b76176f5ffbcaf2898eaa2d1a2e24">setVarFree</a> (int j)</td></tr>
<tr class="separator:ab31b76176f5ffbcaf2898eaa2d1a2e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde48f5ce2e42ac3feee72da0cf74ff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#afde48f5ce2e42ac3feee72da0cf74ff8">setCtrBounds</a> (int i, double lhs, double rhs)</td></tr>
<tr class="separator:afde48f5ce2e42ac3feee72da0cf74ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260179a2e457f650376e7a92b8136549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a260179a2e457f650376e7a92b8136549">setLHS</a> (int i, double lhs)</td></tr>
<tr class="separator:a260179a2e457f650376e7a92b8136549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b45b189fcc1114a6dd99afb68709c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad8b45b189fcc1114a6dd99afb68709c2">setRHS</a> (int i, double rhs)</td></tr>
<tr class="separator:ad8b45b189fcc1114a6dd99afb68709c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b06d08bbbe459d890cb206b4c03328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a53b06d08bbbe459d890cb206b4c03328">setCtrFree</a> (int i)</td></tr>
<tr class="separator:a53b06d08bbbe459d890cb206b4c03328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f6b96b5f6164fda355bfeb10d5ed4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af2f6b96b5f6164fda355bfeb10d5ed4a">reset</a> ()</td></tr>
<tr class="separator:af2f6b96b5f6164fda355bfeb10d5ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac38ce07ce257c0a7ee44dfc12e59b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acac38ce07ce257c0a7ee44dfc12e59b4">optimize</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeLimit=1000000l, double gap=0.0, const char *solFileName=0)</td></tr>
<tr class="separator:acac38ce07ce257c0a7ee44dfc12e59b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b6916019aae383786af2635687f359"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af3b6916019aae383786af2635687f359">isPrepared</a> () const</td></tr>
<tr class="separator:af3b6916019aae383786af2635687f359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277afd563c5fd0849a6480a80f486fee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a277afd563c5fd0849a6480a80f486fee">isSolved</a> () const</td></tr>
<tr class="separator:a277afd563c5fd0849a6480a80f486fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af1978cf8a498333938e780412f33e9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8af1978cf8a498333938e780412f33e9">isSolution</a> () const</td></tr>
<tr class="separator:a8af1978cf8a498333938e780412f33e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f4551e040248b83ced4d34c0ab017"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a497f4551e040248b83ced4d34c0ab017">isLpInfeasible</a> () const</td></tr>
<tr class="separator:a497f4551e040248b83ced4d34c0ab017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50da983157733dd19de4d91dfec2aabf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a50da983157733dd19de4d91dfec2aabf">isInfeasible</a> () const</td></tr>
<tr class="separator:a50da983157733dd19de4d91dfec2aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ec9a7bc4bd6a249a0c73de69f1b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a297ec9a7bc4bd6a249a0c73de69f1b17">isLpUnbounded</a> () const</td></tr>
<tr class="separator:a297ec9a7bc4bd6a249a0c73de69f1b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b51623f53e3da259dfac58d65d0d3dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7b51623f53e3da259dfac58d65d0d3dd">getObjVal</a> () const</td></tr>
<tr class="separator:a7b51623f53e3da259dfac58d65d0d3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1636d6070c91135f68892056e59b33b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1636d6070c91135f68892056e59b33b4">getSolution</a> (double *&amp;dpX, int *&amp;ipHd)</td></tr>
<tr class="separator:a1636d6070c91135f68892056e59b33b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a68321fefd80cacbb77c3076703cc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a90a68321fefd80cacbb77c3076703cc6">getReducedCosts</a> (double *&amp;dpC, int *&amp;ipHd)</td></tr>
<tr class="separator:a90a68321fefd80cacbb77c3076703cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45de9d5f0eea44f06a733026b9a99fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae45de9d5f0eea44f06a733026b9a99fd">getShadowPrices</a> (double *&amp;dpP, int *&amp;ipHd)</td></tr>
<tr class="separator:ae45de9d5f0eea44f06a733026b9a99fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f43361e3880af54ce8ff86d806d4ded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible</a> (int &amp;m, int *&amp;ipRowHd, double *&amp;dpYctr, int &amp;n, int *&amp;ipColHd, double *&amp;dpYbd)</td></tr>
<tr class="separator:a4f43361e3880af54ce8ff86d806d4ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc8c6445cbc093409f21ee338f0924c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:afdc8c6445cbc093409f21ee338f0924c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0ea08d73d4bcbcbdb38176627aa52f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aab0ea08d73d4bcbcbdb38176627aa52f">showWhyLpInfeasible</a> (const char *fileName)</td></tr>
<tr class="separator:aab0ea08d73d4bcbcbdb38176627aa52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d11405730a32a3917518bd97f06d6ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7d11405730a32a3917518bd97f06d6ae">whyLpUnbounded</a> (int &amp;n, double *&amp;dpX, double *&amp;dpRay, int *&amp;ipColHd)</td></tr>
<tr class="separator:a7d11405730a32a3917518bd97f06d6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5f5d38fd9d40af6e38eba360bc48e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6d5f5d38fd9d40af6e38eba360bc48e2">showWhyLpUnbounded</a> (const char *fileName)</td></tr>
<tr class="separator:a6d5f5d38fd9d40af6e38eba360bc48e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b66733b6e5eea018d638c4f9538ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1f2b66733b6e5eea018d638c4f9538ef">printSolution</a> (const char *fileName=0)</td></tr>
<tr class="separator:a1f2b66733b6e5eea018d638c4f9538ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf63388547e9d3523c70699094314cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2bf63388547e9d3523c70699094314cb">printRow</a> (int i, bool scaled=true, bool varValues=false)</td></tr>
<tr class="separator:a2bf63388547e9d3523c70699094314cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1562920480fa37e7107b59a80a9be3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad1562920480fa37e7107b59a80a9be3e">printCtr</a> (int sz, double *dpVal, int *ipCol, double b, bool side=true)</td></tr>
<tr class="separator:ad1562920480fa37e7107b59a80a9be3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff57f622722c92212ebc47b54e2441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0cff57f622722c92212ebc47b54e2441">printColumn</a> (int j)</td></tr>
<tr class="separator:a0cff57f622722c92212ebc47b54e2441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcd371acb757fe0683f639cf1cf7646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1dcd371acb757fe0683f639cf1cf7646">printMatrix</a> (const char *fileName, bool scaled=false)</td></tr>
<tr class="separator:a1dcd371acb757fe0683f639cf1cf7646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3621d8732a32eab9a5314e75a6068c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5d3621d8732a32eab9a5314e75a6068c">allowNormCtrs</a> (int maxCtrNum, int avCtrSize)</td></tr>
<tr class="separator:a5d3621d8732a32eab9a5314e75a6068c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f07b72b28d7ca0a26423c6a822dd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a098f07b72b28d7ca0a26423c6a822dd6">addNormCtr</a> (int t, int sz, int *ipVars, double tol=0.0001)</td></tr>
<tr class="separator:a098f07b72b28d7ca0a26423c6a822dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a5a6d9c16c926728d109d9fc34fbd4245"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5a6d9c16c926728d109d9fc34fbd4245">m_sWarningMsg</a> [256]</td></tr>
<tr class="memdesc:a5a6d9c16c926728d109d9fc34fbd4245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character array for using as message strings.  <a href="#a5a6d9c16c926728d109d9fc34fbd4245">More...</a><br /></td></tr>
<tr class="separator:a5a6d9c16c926728d109d9fc34fbd4245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5aaf8a2deb3a8c6380dd8b2794bc0"><td class="memItemLeft" align="right" valign="top"><a id="a27f5aaf8a2deb3a8c6380dd8b2794bc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a27f5aaf8a2deb3a8c6380dd8b2794bc0">m_bPrimeFeasible</a></td></tr>
<tr class="memdesc:a27f5aaf8a2deb3a8c6380dd8b2794bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, the current basic solution is prime feasible. <br /></td></tr>
<tr class="separator:a27f5aaf8a2deb3a8c6380dd8b2794bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c1f5196e7d2d16acffe6f27ed63ff8"><td class="memItemLeft" align="right" valign="top"><a id="a36c1f5196e7d2d16acffe6f27ed63ff8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a36c1f5196e7d2d16acffe6f27ed63ff8">m_bDualFeasible</a></td></tr>
<tr class="memdesc:a36c1f5196e7d2d16acffe6f27ed63ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, the current basic solution is dual feasible. <br /></td></tr>
<tr class="separator:a36c1f5196e7d2d16acffe6f27ed63ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef37bdd66600918cc1bb08ea500660a5"><td class="memItemLeft" align="right" valign="top"><a id="aef37bdd66600918cc1bb08ea500660a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aef37bdd66600918cc1bb08ea500660a5">m_bRowNorm</a></td></tr>
<tr class="memdesc:aef37bdd66600918cc1bb08ea500660a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, <code>m_dpNorm[i]</code> is the norm of <code>m_ipBasicRow[i]</code> in the current basis <br /></td></tr>
<tr class="separator:aef37bdd66600918cc1bb08ea500660a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e15dd25a2c5580df88289f4e3b89a8"><td class="memItemLeft" align="right" valign="top"><a id="a17e15dd25a2c5580df88289f4e3b89a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a17e15dd25a2c5580df88289f4e3b89a8">m_bColNorm</a></td></tr>
<tr class="memdesc:a17e15dd25a2c5580df88289f4e3b89a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, <code>m_dpNorm[i]</code> is the norm of <code>i</code>-th non-basic row. <br /></td></tr>
<tr class="separator:a17e15dd25a2c5580df88289f4e3b89a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acbcd9ecf00ad8658d570dd803b0aabe3"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acbcd9ecf00ad8658d570dd803b0aabe3">INF</a> =1.0e+20</td></tr>
<tr class="memdesc:acbcd9ecf00ad8658d570dd803b0aabe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">default value of infinity.  <a href="#acbcd9ecf00ad8658d570dd803b0aabe3">More...</a><br /></td></tr>
<tr class="separator:acbcd9ecf00ad8658d570dd803b0aabe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921256fa400b2cdb6c5008bf189aa7a8"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a921256fa400b2cdb6c5008bf189aa7a8">VAR_INF</a> =1.0e+12</td></tr>
<tr class="memdesc:a921256fa400b2cdb6c5008bf189aa7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">default value of infinity for variables.  <a href="#a921256fa400b2cdb6c5008bf189aa7a8">More...</a><br /></td></tr>
<tr class="separator:a921256fa400b2cdb6c5008bf189aa7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f1d2167504fa29b777f6b88259803d"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa9f1d2167504fa29b777f6b88259803d">MAX_BIG_M</a> =1.0e+20</td></tr>
<tr class="memdesc:aa9f1d2167504fa29b777f6b88259803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">default value for big <code>M</code> used in the one phase implementation of the prime simplex algorithm.  <a href="#aa9f1d2167504fa29b777f6b88259803d">More...</a><br /></td></tr>
<tr class="separator:aa9f1d2167504fa29b777f6b88259803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc0df6ea9e3d6ede8c252b9d67b0d4a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8bc0df6ea9e3d6ede8c252b9d67b0d4a">SHIFT</a> =0x40000000</td></tr>
<tr class="memdesc:a8bc0df6ea9e3d6ede8c252b9d67b0d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals to (std::numeric_limits&lt;int&gt;::max() &gt;&gt; 1).  <a href="#a8bc0df6ea9e3d6ede8c252b9d67b0d4a">More...</a><br /></td></tr>
<tr class="separator:a8bc0df6ea9e3d6ede8c252b9d67b0d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa854c8728a5654b1844419dd2cb5b7c8"><td class="memItemLeft" align="right" valign="top"><a id="aa854c8728a5654b1844419dd2cb5b7c8"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa854c8728a5654b1844419dd2cb5b7c8">msgNoSolution</a> []</td></tr>
<tr class="memdesc:aa854c8728a5654b1844419dd2cb5b7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant string for no-solution message. <br /></td></tr>
<tr class="separator:aa854c8728a5654b1844419dd2cb5b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7e990d15247758a448cedb3391c42013"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7e990d15247758a448cedb3391c42013">getThisCtrTol</a> (int) const</td></tr>
<tr class="separator:a7e990d15247758a448cedb3391c42013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5042f6464f736fffb5321693464b8339"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5042f6464f736fffb5321693464b8339">isPureLP</a> () const</td></tr>
<tr class="separator:a5042f6464f736fffb5321693464b8339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da8fa240b6d69974fb73c0ee942de52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2da8fa240b6d69974fb73c0ee942de52">multiplyCtr</a> (int i, double factor)</td></tr>
<tr class="separator:a2da8fa240b6d69974fb73c0ee942de52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90bf133c46fe102d2b10805f8bfdec3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae90bf133c46fe102d2b10805f8bfdec3">extendVarType</a> (int j, unsigned type)</td></tr>
<tr class="separator:ae90bf133c46fe102d2b10805f8bfdec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6433f319b666c6c42389875c232f920e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6433f319b666c6c42389875c232f920e">extendCtrType</a> (int i, unsigned type)</td></tr>
<tr class="separator:a6433f319b666c6c42389875c232f920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a388179951a58ff108cb9aeffc48aba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5a388179951a58ff108cb9aeffc48aba">isVarIntegral</a> (int j) const</td></tr>
<tr class="separator:a5a388179951a58ff108cb9aeffc48aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce3965a0ec3cd2275ce18a2045f594f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0ce3965a0ec3cd2275ce18a2045f594f">isVarUsedForBranching</a> (int j) const</td></tr>
<tr class="separator:a0ce3965a0ec3cd2275ce18a2045f594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d0a21407f597a92d9f5924cef1714c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af5d0a21407f597a92d9f5924cef1714c">isVarStrongIntegral</a> (int j) const</td></tr>
<tr class="separator:af5d0a21407f597a92d9f5924cef1714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a42d3bb1f3cd41bf5454106080139d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a72a42d3bb1f3cd41bf5454106080139d">isVarBinary</a> (int j) const</td></tr>
<tr class="separator:a72a42d3bb1f3cd41bf5454106080139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e84d3f6fbde33cc62795e5176f2eb3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae0e84d3f6fbde33cc62795e5176f2eb3">isVarScalable</a> (int j) const</td></tr>
<tr class="separator:ae0e84d3f6fbde33cc62795e5176f2eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf2304fcf592f3684a293514a4e0e11"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3cf2304fcf592f3684a293514a4e0e11">isVarDeletable</a> (int j) const</td></tr>
<tr class="separator:a3cf2304fcf592f3684a293514a4e0e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d731369346a8563306d9f370d1f11db"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7d731369346a8563306d9f370d1f11db">isCtrModifyable</a> (int) const</td></tr>
<tr class="separator:a7d731369346a8563306d9f370d1f11db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed51f6357c2a1a7a9e3cd434296a41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow</a> (int row, double *dpVal, int *ipCol, bool bScaled=false)</td></tr>
<tr class="separator:a16ed51f6357c2a1a7a9e3cd434296a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75754fed56e5caa1755a72a8adab225e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn</a> (int col, double *dpVal, int *ipRow, bool bScaled=false)</td></tr>
<tr class="separator:a75754fed56e5caa1755a72a8adab225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5309eca95342409d93fec05a7375d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9d5309eca95342409d93fec05a7375d7">computeObjValue</a> (bool recomputeBasicVarsCost=false)</td></tr>
<tr class="separator:a9d5309eca95342409d93fec05a7375d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d5e85eed5683918536072019f7bda5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a10d5e85eed5683918536072019f7bda5">shiftBounds</a> ()</td></tr>
<tr class="separator:a10d5e85eed5683918536072019f7bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca55b1b4117eb73f8c1ef49ba3dec07d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aca55b1b4117eb73f8c1ef49ba3dec07d">preprocessInit</a> ()</td></tr>
<tr class="separator:aca55b1b4117eb73f8c1ef49ba3dec07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d8a1df14e4e090338de0fa9a95e097"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a00d8a1df14e4e090338de0fa9a95e097">preprocessPlus</a> ()</td></tr>
<tr class="separator:a00d8a1df14e4e090338de0fa9a95e097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aead89f9f0ae4100f6639678a8ff98b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9aead89f9f0ae4100f6639678a8ff98b">basicPreprocess</a> (bool bDominant=true)</td></tr>
<tr class="separator:a9aead89f9f0ae4100f6639678a8ff98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d3efb7db52940403ab6d32bfe45fb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af1d3efb7db52940403ab6d32bfe45fb6">preprocess</a> ()</td></tr>
<tr class="separator:af1d3efb7db52940403ab6d32bfe45fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad29cf287728182fa3baf93fd121732"><td class="memItemLeft" align="right" valign="top"><a id="a6ad29cf287728182fa3baf93fd121732"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6ad29cf287728182fa3baf93fd121732">scaleObj</a> ()</td></tr>
<tr class="memdesc:a6ad29cf287728182fa3baf93fd121732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales objective with previously computed column scale factors. <br /></td></tr>
<tr class="separator:a6ad29cf287728182fa3baf93fd121732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e23e02b2d3fa31cd46fce8405db0509"><td class="memItemLeft" align="right" valign="top"><a id="a7e23e02b2d3fa31cd46fce8405db0509"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7e23e02b2d3fa31cd46fce8405db0509">SCL_scaleMatrix</a> ()</td></tr>
<tr class="memdesc:a7e23e02b2d3fa31cd46fce8405db0509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales matrix with previously computed scale factors. <br /></td></tr>
<tr class="separator:a7e23e02b2d3fa31cd46fce8405db0509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa07941b540e729bca314a31369373e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5fa07941b540e729bca314a31369373e">scaleMatrix</a> ()</td></tr>
<tr class="memdesc:a5fa07941b540e729bca314a31369373e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute factors and then scales matrix.  <a href="#a5fa07941b540e729bca314a31369373e">More...</a><br /></td></tr>
<tr class="separator:a5fa07941b540e729bca314a31369373e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74596843baa7984e3407a7d4016928e"><td class="memItemLeft" align="right" valign="top"><a id="ab74596843baa7984e3407a7d4016928e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab74596843baa7984e3407a7d4016928e">unscaleMatrix</a> ()</td></tr>
<tr class="memdesc:ab74596843baa7984e3407a7d4016928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers matrix to initial state. <br /></td></tr>
<tr class="separator:ab74596843baa7984e3407a7d4016928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95f90e4d8c3668245e5cac467cfba21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad95f90e4d8c3668245e5cac467cfba21">deleteVariable</a> (int j, int hd, double b, int sz, int *ipCol, double *dpVal)</td></tr>
<tr class="separator:ad95f90e4d8c3668245e5cac467cfba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c15331979ed725b3175a0547b8885a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1c15331979ed725b3175a0547b8885a7">compressMatrix</a> (int m0=0, int n0=0, bool prepFlag=true, bool bEntry=true)</td></tr>
<tr class="separator:a1c15331979ed725b3175a0547b8885a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2294953950b9fd61ca9b1e9d9d9893be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2294953950b9fd61ca9b1e9d9d9893be">setCtrsInactive</a> (int, int *)</td></tr>
<tr class="separator:a2294953950b9fd61ca9b1e9d9d9893be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7c374f8854c9e143e645737bfa981f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2d7c374f8854c9e143e645737bfa981f">setColumnsInactive</a> (int, int *)</td></tr>
<tr class="separator:a2d7c374f8854c9e143e645737bfa981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28902beb78bacc0501a0991a87621655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a28902beb78bacc0501a0991a87621655">deleteNonBasicLines</a> (int m, int n, bool bFull, double tight)</td></tr>
<tr class="separator:a28902beb78bacc0501a0991a87621655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f06d58c9f995bbbf5942c5c812eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a369f06d58c9f995bbbf5942c5c812eb2">scaleRow</a> (int sz, double *dpVal, int *ipCol)</td></tr>
<tr class="separator:a369f06d58c9f995bbbf5942c5c812eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ddbe21b8a232349765cfc3017d726b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a47ddbe21b8a232349765cfc3017d726b">scaleCtr</a> (double &amp;lhs, double &amp;rhs, int sz, double *dpVal, int *ipCol)</td></tr>
<tr class="separator:a47ddbe21b8a232349765cfc3017d726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fbf7efb944d49efcca01a0f9c083d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af9fbf7efb944d49efcca01a0f9c083d7">scaleColumn</a> (double &amp;cost, int sz, double *dpVal, int *ipCol)</td></tr>
<tr class="separator:af9fbf7efb944d49efcca01a0f9c083d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaddeb4967c9c44cca3505f3e8c4a99d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adaddeb4967c9c44cca3505f3e8c4a99d">scaleVar</a> (double &amp;cost, double &amp;l, double &amp;u, int sz, double *dpVal, int *ipRow)</td></tr>
<tr class="separator:adaddeb4967c9c44cca3505f3e8c4a99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe129407333ac743e0c4da6dd2ae5128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#afe129407333ac743e0c4da6dd2ae5128">allocMemForSimplex</a> ()</td></tr>
<tr class="separator:afe129407333ac743e0c4da6dd2ae5128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099efa5c25b4be3361d2764584f4fb81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a099efa5c25b4be3361d2764584f4fb81">buildRowColLists</a> ()</td></tr>
<tr class="separator:a099efa5c25b4be3361d2764584f4fb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1efa53f4deb2fc8bc02f5027af7416"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aca1efa53f4deb2fc8bc02f5027af7416">reallocMemForEntries</a> (int nz)</td></tr>
<tr class="separator:aca1efa53f4deb2fc8bc02f5027af7416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c4c39286e5c005fc8474d27ac631bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac2c4c39286e5c005fc8474d27ac631bc">incMaxRowNumber</a> ()</td></tr>
<tr class="separator:ac2c4c39286e5c005fc8474d27ac631bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd97c12ae3986296c8d581c41f5848"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5ecd97c12ae3986296c8d581c41f5848">incMaxColumnNumber</a> ()</td></tr>
<tr class="separator:a5ecd97c12ae3986296c8d581c41f5848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343e6b0b673160229a69b80fc8e08f7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a343e6b0b673160229a69b80fc8e08f7a">allocMemForAuxArrays</a> ()</td></tr>
<tr class="separator:a343e6b0b673160229a69b80fc8e08f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893045084c9180cec0420d0c1b0a6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa893045084c9180cec0420d0c1b0a6ad">reallocMemForAuxArrays</a> (bool rowMem, bool colMem)</td></tr>
<tr class="separator:aa893045084c9180cec0420d0c1b0a6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab223b0873095d4b64a958e83c79438e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab223b0873095d4b64a958e83c79438e4">saveBasis</a> (int *mem)</td></tr>
<tr class="separator:ab223b0873095d4b64a958e83c79438e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8da82ce47808a11b30e749fbb568b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae8da82ce47808a11b30e749fbb568b37">restoreBasis</a> (int *mem)</td></tr>
<tr class="separator:ae8da82ce47808a11b30e749fbb568b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384498ec70e9fbc955e2cffc935c20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2384498ec70e9fbc955e2cffc935c20d">restoreBasis</a> (int *ipRowMap, int *ipColMap)</td></tr>
<tr class="separator:a2384498ec70e9fbc955e2cffc935c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9136db891a9e87dc6e2e2726feb0ab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5a9136db891a9e87dc6e2e2726feb0ab">getCtrRightSlack</a> (const int i, bool scaled=true) const</td></tr>
<tr class="separator:a5a9136db891a9e87dc6e2e2726feb0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3298cc487c5408a38b6f55262d7ad6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6c3298cc487c5408a38b6f55262d7ad6">getCtrLeftSlack</a> (const int i, bool scaled=true) const</td></tr>
<tr class="separator:a6c3298cc487c5408a38b6f55262d7ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4da1233ad71119bd3b1aabb79d0073"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aff4da1233ad71119bd3b1aabb79d0073">getPrimeSolution</a> (double *dpBasicX, double *dpX)</td></tr>
<tr class="separator:aff4da1233ad71119bd3b1aabb79d0073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0562bb322f77d142d666ed8152b7f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6d0562bb322f77d142d666ed8152b7f1">getVarValue</a> (int j) const</td></tr>
<tr class="separator:a6d0562bb322f77d142d666ed8152b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857670786cb53f3ea8479db7cc3a154"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab857670786cb53f3ea8479db7cc3a154">getRowValue</a> (int i) const</td></tr>
<tr class="separator:ab857670786cb53f3ea8479db7cc3a154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f4f473f360001301df583f052d3b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a99f4f473f360001301df583f052d3b53">computeX</a> (double *x=0, int col=-1)</td></tr>
<tr class="separator:a99f4f473f360001301df583f052d3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e3d3e14993182d12867c6c23c2107e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a59e3d3e14993182d12867c6c23c2107e">computeY</a> (double *y=0, bool withFixedVars=false)</td></tr>
<tr class="separator:a59e3d3e14993182d12867c6c23c2107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d2b59626190b5c3c03f3f01544255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a029d2b59626190b5c3c03f3f01544255">updateSolution</a> ()</td></tr>
<tr class="separator:a029d2b59626190b5c3c03f3f01544255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440356b6889cf285de7eb2a2c852a42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3440356b6889cf285de7eb2a2c852a42">computeBasicColumnSum</a> ()</td></tr>
<tr class="separator:a3440356b6889cf285de7eb2a2c852a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdf654da45516869b3d507ed7a03be7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#abbdf654da45516869b3d507ed7a03be7">incColumnSum</a> (int col, double delta)</td></tr>
<tr class="separator:abbdf654da45516869b3d507ed7a03be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582069e20a64bafa43df0e1d6f30c36b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a582069e20a64bafa43df0e1d6f30c36b">solveLP</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> timeLimit=0, bool genFlag=true)</td></tr>
<tr class="separator:a582069e20a64bafa43df0e1d6f30c36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b16107bf05adff72406dbb0869d682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a40b16107bf05adff72406dbb0869d682">addNewRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double b1, double b2, int sz, double *&amp;dpVal, int *&amp;ipCol, bool bVarScaled=true, int factor=<a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a>, int n=0, bool toBasis=true)</td></tr>
<tr class="separator:a40b16107bf05adff72406dbb0869d682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad894bdbde67dd19464df9e48ebd2c7bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad894bdbde67dd19464df9e48ebd2c7bb">dublicateRow</a> (int row)</td></tr>
<tr class="memdesc:ad894bdbde67dd19464df9e48ebd2c7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to the matrix another copy of row <code>row</code>.  <a href="#ad894bdbde67dd19464df9e48ebd2c7bb">More...</a><br /></td></tr>
<tr class="separator:ad894bdbde67dd19464df9e48ebd2c7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad040a1690b496a9f62cf0908b953360a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad040a1690b496a9f62cf0908b953360a">addNewColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, unsigned type, double cost, double l, double u, int sz, double *&amp;dpVal, int *&amp;ipRow, bool side, bool scaled=false, int factor=0, bool flag=false)</td></tr>
<tr class="separator:ad040a1690b496a9f62cf0908b953360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33872ba1f311ba9cd26d9e8cc0a938d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a33872ba1f311ba9cd26d9e8cc0a938d0">estimateCol</a> (int sz, double *dpVal, int *ipRow)</td></tr>
<tr class="separator:a33872ba1f311ba9cd26d9e8cc0a938d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0849fc963749a56b07560abaa6ad8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate</a> (int n, const double *dpX, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipColHd, bool genFlag)</td></tr>
<tr class="separator:a06d0849fc963749a56b07560abaa6ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0e85fa6ec0116b6b3c1ed7563071a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a87c0e85fa6ec0116b6b3c1ed7563071a">getDualRowVars</a> (double *y, double *z, bool bScaled)</td></tr>
<tr class="separator:a87c0e85fa6ec0116b6b3c1ed7563071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2fde24973288a44a64fa017337364"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5ff2fde24973288a44a64fa017337364">getColumn</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, int m, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipHd, unsigned &amp;type, double &amp;cost, double &amp;l, double &amp;u, int &amp;sz, double *dpVal, int *ipRow)</td></tr>
<tr class="separator:a5ff2fde24973288a44a64fa017337364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc545048ac0bee2405278c5394f5a72"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6dc545048ac0bee2405278c5394f5a72">getRow</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, int n, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipHd, unsigned &amp;type, double &amp;lhs, double &amp;rhs, int &amp;sz, double *dpVal, int *ipCol, bool &amp;scaled)</td></tr>
<tr class="separator:a6dc545048ac0bee2405278c5394f5a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a22364cac6b727f5b4e8416b753e3cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns</a> (int m, const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *ipRowHd, const double *dpY)</td></tr>
<tr class="separator:a7a22364cac6b727f5b4e8416b753e3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf707db6eafaf6fe2248dda596475c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#abf707db6eafaf6fe2248dda596475c61">getVarHandle</a> (int j) const</td></tr>
<tr class="separator:abf707db6eafaf6fe2248dda596475c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b035339093737c069e2f6e58ffab494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4b035339093737c069e2f6e58ffab494">getCtrHandle</a> (int i) const</td></tr>
<tr class="separator:a4b035339093737c069e2f6e58ffab494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564de7d70495c8124d685908c64a05b4"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a564de7d70495c8124d685908c64a05b4">getCtrName</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, char *name) const</td></tr>
<tr class="separator:a564de7d70495c8124d685908c64a05b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a9d61baa772136537322854f15b6ed"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a24a9d61baa772136537322854f15b6ed">getVarName</a> (<a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> hd, char *name) const</td></tr>
<tr class="separator:a24a9d61baa772136537322854f15b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa885958373244ebe82c17796bf17dd29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa885958373244ebe82c17796bf17dd29">isVarFixed</a> (int j) const</td></tr>
<tr class="separator:aa885958373244ebe82c17796bf17dd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e92ccb47a2381fdc335faec89bfc84d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8e92ccb47a2381fdc335faec89bfc84d">isVarFree</a> (int j) const</td></tr>
<tr class="separator:a8e92ccb47a2381fdc335faec89bfc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a9d2aaa65e01f1f08113fcae7b8a8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad8a9d2aaa65e01f1f08113fcae7b8a8c">isVarBounded</a> (int j) const</td></tr>
<tr class="separator:ad8a9d2aaa65e01f1f08113fcae7b8a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e297bc60583f0a97604e536364ff803"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3e297bc60583f0a97604e536364ff803">isVarLoBounded</a> (int j) const</td></tr>
<tr class="separator:a3e297bc60583f0a97604e536364ff803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9166442b72ec9b457b643150e198cafa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9166442b72ec9b457b643150e198cafa">isVarUpBounded</a> (int j) const</td></tr>
<tr class="separator:a9166442b72ec9b457b643150e198cafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2d9a525711f3ea84041d576e81a2ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4b2d9a525711f3ea84041d576e81a2ae">isCtrEq</a> (int i) const</td></tr>
<tr class="separator:a4b2d9a525711f3ea84041d576e81a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2c0fafb334e3f569d3e425ad66b431"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adf2c0fafb334e3f569d3e425ad66b431">isCtrFree</a> (int i) const</td></tr>
<tr class="separator:adf2c0fafb334e3f569d3e425ad66b431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2f383c7cc7adc1f0b9aec343fd7d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa6d2f383c7cc7adc1f0b9aec343fd7d5">isCtrBounded</a> (int i) const</td></tr>
<tr class="separator:aa6d2f383c7cc7adc1f0b9aec343fd7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58999f5b5a8426cdb355c2a7432f658a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a58999f5b5a8426cdb355c2a7432f658a">isCtrLoBounded</a> (int i) const</td></tr>
<tr class="separator:a58999f5b5a8426cdb355c2a7432f658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a6c79534131e46e17853f4b7d4ee8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a883a6c79534131e46e17853f4b7d4ee8">isCtrUpBounded</a> (int i) const</td></tr>
<tr class="separator:a883a6c79534131e46e17853f4b7d4ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8380195e69c672761c60a954e028f89"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac8380195e69c672761c60a954e028f89">getLastLowerBound</a> ()</td></tr>
<tr class="separator:ac8380195e69c672761c60a954e028f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b924d5bbf633e2f350e5051aa4a8d2b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3b924d5bbf633e2f350e5051aa4a8d2b">getScaledObjVal</a> (double val) const</td></tr>
<tr class="separator:a3b924d5bbf633e2f350e5051aa4a8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5be852e69e8ce4f885d59825b425214"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab5be852e69e8ce4f885d59825b425214">getNotScaledObjVal</a> (double val) const</td></tr>
<tr class="separator:ab5be852e69e8ce4f885d59825b425214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad291b60e0912a053f08bd0981244502d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad291b60e0912a053f08bd0981244502d">getPartitionNum</a> () const</td></tr>
<tr class="separator:ad291b60e0912a053f08bd0981244502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf78b8f2562769fda19237d42f8c0da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2bf78b8f2562769fda19237d42f8c0da">serialize</a> (std::fstream &amp;ar, bool is_storing)</td></tr>
<tr class="separator:a2bf78b8f2562769fda19237d42f8c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cad4021fc1fb67c4dd0290b51f099d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1cad4021fc1fb67c4dd0290b51f099d6">getLPItNum</a> () const</td></tr>
<tr class="separator:a1cad4021fc1fb67c4dd0290b51f099d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811a70fe6c1839a2378815f19468cc08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a811a70fe6c1839a2378815f19468cc08">getDegItNum</a> () const</td></tr>
<tr class="separator:a811a70fe6c1839a2378815f19468cc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5efb7a119d591a4c575ee0b464f8bd"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5f5efb7a119d591a4c575ee0b464f8bd">getProbStatStr</a> (char *str=0)</td></tr>
<tr class="separator:a5f5efb7a119d591a4c575ee0b464f8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aee610537e542da711336710937131e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3aee610537e542da711336710937131e">infoMessage</a> (const char *msg, int level=0)</td></tr>
<tr class="separator:a3aee610537e542da711336710937131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f873f131cfe55c8e9df25eca7b43b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a633f873f131cfe55c8e9df25eca7b43b">lpInfo</a> (const char *method, const char *time, int itNum, int degItNum, double objVal)</td></tr>
<tr class="separator:a633f873f131cfe55c8e9df25eca7b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d8af63bdc483cc78628d591ff5f90e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac1d8af63bdc483cc78628d591ff5f90e">STRBR_estimateObjDecrease</a> (double lowerBound, int maxItNum)</td></tr>
<tr class="separator:ac1d8af63bdc483cc78628d591ff5f90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a75b5306fe2f902f31ce3d368aa1ba14f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a75b5306fe2f902f31ce3d368aa1ba14f">GCD</a> (double a, double b)</td></tr>
<tr class="separator:a75b5306fe2f902f31ce3d368aa1ba14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1fe3f4410af3413f07297d2930c142"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aee1fe3f4410af3413f07297d2930c142">modInv</a> (<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> a, <a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> m)</td></tr>
<tr class="separator:aee1fe3f4410af3413f07297d2930c142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8b5f7c2e56e6ff229d6768c960107792"><td class="memItemLeft" align="right" valign="top"><a id="a8b5f7c2e56e6ff229d6768c960107792"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8b5f7c2e56e6ff229d6768c960107792">m_iThread</a></td></tr>
<tr class="memdesc:a8b5f7c2e56e6ff229d6768c960107792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a thread in a multi-threaded MIP-application. <br /></td></tr>
<tr class="separator:a8b5f7c2e56e6ff229d6768c960107792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60763e772c634000fd63fdab5b77942d"><td class="memItemLeft" align="right" valign="top"><a id="a60763e772c634000fd63fdab5b77942d"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60763e772c634000fd63fdab5b77942d">m_strProblemName</a> [32]</td></tr>
<tr class="memdesc:a60763e772c634000fd63fdab5b77942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores problem name. <br /></td></tr>
<tr class="separator:a60763e772c634000fd63fdab5b77942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b5998c291b14964f472f569da4d59c"><td class="memItemLeft" align="right" valign="top"><a id="ac4b5998c291b14964f472f569da4d59c"></a>
std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac4b5998c291b14964f472f569da4d59c">m_pLogStream</a></td></tr>
<tr class="memdesc:ac4b5998c291b14964f472f569da4d59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOG file. <br /></td></tr>
<tr class="separator:ac4b5998c291b14964f472f569da4d59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f7d6e938f1b4a1dc51b386bfe6457f"><td class="memItemLeft" align="right" valign="top"><a id="a72f7d6e938f1b4a1dc51b386bfe6457f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a72f7d6e938f1b4a1dc51b386bfe6457f">m_bSense</a></td></tr>
<tr class="memdesc:a72f7d6e938f1b4a1dc51b386bfe6457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objective sense: if <code>true</code> - maximize, if <code>false</code> - minimize. <br /></td></tr>
<tr class="separator:a72f7d6e938f1b4a1dc51b386bfe6457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7953644c5b1f45524141bce781d0a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aaf7953644c5b1f45524141bce781d0a6">m_iState</a></td></tr>
<tr class="separator:aaf7953644c5b1f45524141bce781d0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6a5c813dbf43e1d52c91fe53b595ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aaa6a5c813dbf43e1d52c91fe53b595ab">m_iS</a></td></tr>
<tr class="memdesc:aaa6a5c813dbf43e1d52c91fe53b595ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a state of the last LP solved.  <a href="#aaa6a5c813dbf43e1d52c91fe53b595ab">More...</a><br /></td></tr>
<tr class="separator:aaa6a5c813dbf43e1d52c91fe53b595ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25af32c327f27ddc37b545b684b1648c"><td class="memItemLeft" align="right" valign="top"><a id="a25af32c327f27ddc37b545b684b1648c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a25af32c327f27ddc37b545b684b1648c">m_iN</a></td></tr>
<tr class="memdesc:a25af32c327f27ddc37b545b684b1648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of variables in the currently processed LP. <br /></td></tr>
<tr class="separator:a25af32c327f27ddc37b545b684b1648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fd87707ca8fee20e2bcfa16bc8a472"><td class="memItemLeft" align="right" valign="top"><a id="a60fd87707ca8fee20e2bcfa16bc8a472"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60fd87707ca8fee20e2bcfa16bc8a472">m_iN0</a></td></tr>
<tr class="memdesc:a60fd87707ca8fee20e2bcfa16bc8a472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of variables in the root LP; if columns are generated, <code>m_iN0 &lt;= m_iN</code>. <br /></td></tr>
<tr class="separator:a60fd87707ca8fee20e2bcfa16bc8a472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63be14e1c20432ed14e6eef4a05c3ab5"><td class="memItemLeft" align="right" valign="top"><a id="a63be14e1c20432ed14e6eef4a05c3ab5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a63be14e1c20432ed14e6eef4a05c3ab5">m_iNmax</a></td></tr>
<tr class="memdesc:a63be14e1c20432ed14e6eef4a05c3ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of variables. <br /></td></tr>
<tr class="separator:a63be14e1c20432ed14e6eef4a05c3ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f06b19b6118f2fe4d6738378e0d9d"><td class="memItemLeft" align="right" valign="top"><a id="ab80f06b19b6118f2fe4d6738378e0d9d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab80f06b19b6118f2fe4d6738378e0d9d">m_iM</a></td></tr>
<tr class="memdesc:ab80f06b19b6118f2fe4d6738378e0d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of constraints in the currently processed LP. <br /></td></tr>
<tr class="separator:ab80f06b19b6118f2fe4d6738378e0d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814cf77a7bc8afa14067072039c57d74"><td class="memItemLeft" align="right" valign="top"><a id="a814cf77a7bc8afa14067072039c57d74"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a814cf77a7bc8afa14067072039c57d74">m_iM0</a></td></tr>
<tr class="memdesc:a814cf77a7bc8afa14067072039c57d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of constraints in the root LP; if rows (cuts) are generated, <code>m_iM0 &lt;= m_iM</code>. <br /></td></tr>
<tr class="separator:a814cf77a7bc8afa14067072039c57d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63a7c7ed4a5ca7f2101addf51d340f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad63a7c7ed4a5ca7f2101addf51d340f9">m_iMmax</a></td></tr>
<tr class="memdesc:ad63a7c7ed4a5ca7f2101addf51d340f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of constraints.  <a href="#ad63a7c7ed4a5ca7f2101addf51d340f9">More...</a><br /></td></tr>
<tr class="separator:ad63a7c7ed4a5ca7f2101addf51d340f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cbde24ca42fcc1037d85f07f33b19e"><td class="memItemLeft" align="right" valign="top"><a id="a76cbde24ca42fcc1037d85f07f33b19e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a76cbde24ca42fcc1037d85f07f33b19e">m_iNZ</a></td></tr>
<tr class="memdesc:a76cbde24ca42fcc1037d85f07f33b19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzero entries in the currently processed matrix. <br /></td></tr>
<tr class="separator:a76cbde24ca42fcc1037d85f07f33b19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac294d872173aa963637137e49fb10bf2"><td class="memItemLeft" align="right" valign="top"><a id="ac294d872173aa963637137e49fb10bf2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac294d872173aa963637137e49fb10bf2">m_iNZ0</a></td></tr>
<tr class="memdesc:ac294d872173aa963637137e49fb10bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzero entries in the root LP matrix. <br /></td></tr>
<tr class="separator:ac294d872173aa963637137e49fb10bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60913419a10a2601b7f070aed76015b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a60913419a10a2601b7f070aed76015b1">m_iNZmax</a></td></tr>
<tr class="memdesc:a60913419a10a2601b7f070aed76015b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of entries.  <a href="#a60913419a10a2601b7f070aed76015b1">More...</a><br /></td></tr>
<tr class="separator:a60913419a10a2601b7f070aed76015b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd5da42d59717f1534c3f2a6ce6d8ed"><td class="memItemLeft" align="right" valign="top"><a id="a3dd5da42d59717f1534c3f2a6ce6d8ed"></a>
<a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">enAlign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a3dd5da42d59717f1534c3f2a6ce6d8ed">m_iAlign</a></td></tr>
<tr class="memdesc:a3dd5da42d59717f1534c3f2a6ce6d8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how matrix entries are listed. <br /></td></tr>
<tr class="separator:a3dd5da42d59717f1534c3f2a6ce6d8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af090a53877a7aeeb727300ccfcc6d94e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af090a53877a7aeeb727300ccfcc6d94e">m_iObjScaleExp</a></td></tr>
<tr class="memdesc:af090a53877a7aeeb727300ccfcc6d94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">objective scaling factor.  <a href="#af090a53877a7aeeb727300ccfcc6d94e">More...</a><br /></td></tr>
<tr class="separator:af090a53877a7aeeb727300ccfcc6d94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93c3fc14884e838e6328920c7f6448e"><td class="memItemLeft" align="right" valign="top"><a id="ae93c3fc14884e838e6328920c7f6448e"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae93c3fc14884e838e6328920c7f6448e">m_dpC</a></td></tr>
<tr class="memdesc:ae93c3fc14884e838e6328920c7f6448e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost vector, array of size <code>m_iNmax</code>. <br /></td></tr>
<tr class="separator:ae93c3fc14884e838e6328920c7f6448e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120dd7b29e4a02f0edf3eea60af6a2e1"><td class="memItemLeft" align="right" valign="top"><a id="a120dd7b29e4a02f0edf3eea60af6a2e1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a120dd7b29e4a02f0edf3eea60af6a2e1">m_dpC0</a></td></tr>
<tr class="memdesc:a120dd7b29e4a02f0edf3eea60af6a2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to stored objective vector. To prevent cycling, <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code> perturbs the objective; <code>m_dpC0</code> is used to restore the original objective. <br /></td></tr>
<tr class="separator:a120dd7b29e4a02f0edf3eea60af6a2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a933977c2361e2360df3bb9d448db37"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4a933977c2361e2360df3bb9d448db37">m_dpB</a></td></tr>
<tr class="memdesc:a4a933977c2361e2360df3bb9d448db37"><td class="mdescLeft">&#160;</td><td class="mdescRight">left and right hand sides of constraints.  <a href="#a4a933977c2361e2360df3bb9d448db37">More...</a><br /></td></tr>
<tr class="separator:a4a933977c2361e2360df3bb9d448db37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8735dcf46c1ca6e4f37d0634c78342"><td class="memItemLeft" align="right" valign="top"><a id="ace8735dcf46c1ca6e4f37d0634c78342"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ace8735dcf46c1ca6e4f37d0634c78342">m_dpD</a></td></tr>
<tr class="memdesc:ace8735dcf46c1ca6e4f37d0634c78342"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower and upper bounds of variables. <br /></td></tr>
<tr class="separator:ace8735dcf46c1ca6e4f37d0634c78342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0784e3d47802aad24840672c9a4cd7"><td class="memItemLeft" align="right" valign="top"><a id="aac0784e3d47802aad24840672c9a4cd7"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aac0784e3d47802aad24840672c9a4cd7">m_ipPrevColEntry</a></td></tr>
<tr class="memdesc:aac0784e3d47802aad24840672c9a4cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipPrevColEntry[j]</code> is the entry in column <code>m_ipCol[j]</code> preceding entry <code>j</code>. <br /></td></tr>
<tr class="separator:aac0784e3d47802aad24840672c9a4cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d075c2be48dc6b0aa64967d54583220"><td class="memItemLeft" align="right" valign="top"><a id="a0d075c2be48dc6b0aa64967d54583220"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0d075c2be48dc6b0aa64967d54583220">m_ipPrevRowEntry</a></td></tr>
<tr class="memdesc:a0d075c2be48dc6b0aa64967d54583220"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipPrevRowEntry[j]</code> is the entry in row <code>m_ipRow[j]</code> preceding entry <code>j</code>. <br /></td></tr>
<tr class="separator:a0d075c2be48dc6b0aa64967d54583220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1e71b44043192cf3e74c3ec9f9e06"><td class="memItemLeft" align="right" valign="top"><a id="aa2d1e71b44043192cf3e74c3ec9f9e06"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa2d1e71b44043192cf3e74c3ec9f9e06">m_ipRow</a></td></tr>
<tr class="memdesc:aa2d1e71b44043192cf3e74c3ec9f9e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipRow[j]</code> is row index of entry <code>j</code>. <br /></td></tr>
<tr class="separator:aa2d1e71b44043192cf3e74c3ec9f9e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af517ac42acc4c149076aab9765759210"><td class="memItemLeft" align="right" valign="top"><a id="af517ac42acc4c149076aab9765759210"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af517ac42acc4c149076aab9765759210">m_ipCol</a></td></tr>
<tr class="memdesc:af517ac42acc4c149076aab9765759210"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipCol[j]</code> is column index of entry <code>j</code>. <br /></td></tr>
<tr class="separator:af517ac42acc4c149076aab9765759210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4618967508a06f46e5bfe2e2221f5dd9"><td class="memItemLeft" align="right" valign="top"><a id="a4618967508a06f46e5bfe2e2221f5dd9"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a4618967508a06f46e5bfe2e2221f5dd9">m_dpVal</a></td></tr>
<tr class="memdesc:a4618967508a06f46e5bfe2e2221f5dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_dpVal[j]</code> is coefficient for entry <code>j</code>. <br /></td></tr>
<tr class="separator:a4618967508a06f46e5bfe2e2221f5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36958ccba70e68da5c1e73a8bc8aad25"><td class="memItemLeft" align="right" valign="top"><a id="a36958ccba70e68da5c1e73a8bc8aad25"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a36958ccba70e68da5c1e73a8bc8aad25">m_ipLastRowEntry</a></td></tr>
<tr class="memdesc:a36958ccba70e68da5c1e73a8bc8aad25"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iMmax</code>, <code>m_ipLastRowEntry[i]</code> starts the linked list of entries in row <code>i</code>. <br /></td></tr>
<tr class="separator:a36958ccba70e68da5c1e73a8bc8aad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89405f9b533ac5f20f21a7c47bce336"><td class="memItemLeft" align="right" valign="top"><a id="ac89405f9b533ac5f20f21a7c47bce336"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac89405f9b533ac5f20f21a7c47bce336">m_ipRowSize</a></td></tr>
<tr class="memdesc:ac89405f9b533ac5f20f21a7c47bce336"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iMmax</code>, <code>m_ipRowSize[i]</code> is number of entries in row <code>i</code>. <br /></td></tr>
<tr class="separator:ac89405f9b533ac5f20f21a7c47bce336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11832a0463a436f527cc319597198e1"><td class="memItemLeft" align="right" valign="top"><a id="af11832a0463a436f527cc319597198e1"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af11832a0463a436f527cc319597198e1">m_ipLastColEntry</a></td></tr>
<tr class="memdesc:af11832a0463a436f527cc319597198e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNmax</code>, <code>m_ipLastColEntry[i]</code> starts the linked list of entries in column <code>i</code>. <br /></td></tr>
<tr class="separator:af11832a0463a436f527cc319597198e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6f14513019232c1c65cd0ae6e51e1"><td class="memItemLeft" align="right" valign="top"><a id="ad3d6f14513019232c1c65cd0ae6e51e1"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad3d6f14513019232c1c65cd0ae6e51e1">m_ipColSize</a></td></tr>
<tr class="memdesc:ad3d6f14513019232c1c65cd0ae6e51e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of size <code>m_iNZmax</code>, <code>m_ipColSize[i]</code> is number of entries in column <code>i</code>. <br /></td></tr>
<tr class="separator:ad3d6f14513019232c1c65cd0ae6e51e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b73524e19624b92f012306cc7dafcb"><td class="memItemLeft" align="right" valign="top">signed char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a70b73524e19624b92f012306cc7dafcb">m_cpRowScale</a></td></tr>
<tr class="memdesc:a70b73524e19624b92f012306cc7dafcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">row factors.  <a href="#a70b73524e19624b92f012306cc7dafcb">More...</a><br /></td></tr>
<tr class="separator:a70b73524e19624b92f012306cc7dafcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14d891f81497d3a31f6f1f9b734c134"><td class="memItemLeft" align="right" valign="top">signed char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac14d891f81497d3a31f6f1f9b734c134">m_cpColScale</a></td></tr>
<tr class="memdesc:ac14d891f81497d3a31f6f1f9b734c134"><td class="mdescLeft">&#160;</td><td class="mdescRight">column factors.  <a href="#ac14d891f81497d3a31f6f1f9b734c134">More...</a><br /></td></tr>
<tr class="separator:ac14d891f81497d3a31f6f1f9b734c134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb7d1b7e39c81ac444918c5fc0881f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a81eb7d1b7e39c81ac444918c5fc0881f">m_ipRowHd</a></td></tr>
<tr class="memdesc:a81eb7d1b7e39c81ac444918c5fc0881f"><td class="mdescLeft">&#160;</td><td class="mdescRight">row handles.  <a href="#a81eb7d1b7e39c81ac444918c5fc0881f">More...</a><br /></td></tr>
<tr class="separator:a81eb7d1b7e39c81ac444918c5fc0881f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0a7058459b5d9e59394e5620ebcdda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#acd0a7058459b5d9e59394e5620ebcdda">m_ipColHd</a></td></tr>
<tr class="memdesc:acd0a7058459b5d9e59394e5620ebcdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">column handles.  <a href="#acd0a7058459b5d9e59394e5620ebcdda">More...</a><br /></td></tr>
<tr class="separator:acd0a7058459b5d9e59394e5620ebcdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0505305247f3bc5762990010d0645c58"><td class="memItemLeft" align="right" valign="top">unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0505305247f3bc5762990010d0645c58">m_ipVarType</a></td></tr>
<tr class="memdesc:a0505305247f3bc5762990010d0645c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">types of variables.  <a href="#a0505305247f3bc5762990010d0645c58">More...</a><br /></td></tr>
<tr class="separator:a0505305247f3bc5762990010d0645c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ad613a157f4931a769199ea1ccba9c"><td class="memItemLeft" align="right" valign="top">unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac3ad613a157f4931a769199ea1ccba9c">m_ipCtrType</a></td></tr>
<tr class="memdesc:ac3ad613a157f4931a769199ea1ccba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constraint types.  <a href="#ac3ad613a157f4931a769199ea1ccba9c">More...</a><br /></td></tr>
<tr class="separator:ac3ad613a157f4931a769199ea1ccba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21df2d76f49c7588ac116b9a79d0d71"><td class="memItemLeft" align="right" valign="top"><a id="ab21df2d76f49c7588ac116b9a79d0d71"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab21df2d76f49c7588ac116b9a79d0d71">m_dZeroEntry</a></td></tr>
<tr class="memdesc:ab21df2d76f49c7588ac116b9a79d0d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">all numbers that are less than <code>m_dZeroEntry</code> are treated as zeroes. <br /></td></tr>
<tr class="separator:ab21df2d76f49c7588ac116b9a79d0d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fd13cbc419c481c38f09a9a8b234db"><td class="memItemLeft" align="right" valign="top"><a id="a52fd13cbc419c481c38f09a9a8b234db"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a52fd13cbc419c481c38f09a9a8b234db">m_dVarInf</a></td></tr>
<tr class="memdesc:a52fd13cbc419c481c38f09a9a8b234db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>-m_dVarInf &lt;= x[j] &lt;= m_dVarInf</code>, default value is <code><a class="el" href="classCLP.html#a921256fa400b2cdb6c5008bf189aa7a8" title="default value of infinity for variables.">CLP::VAR_INF</a>=1.0e+12</code>. <br /></td></tr>
<tr class="separator:a52fd13cbc419c481c38f09a9a8b234db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb103b64297bd6cf28ee7fa50d32fa48"><td class="memItemLeft" align="right" valign="top"><a id="aeb103b64297bd6cf28ee7fa50d32fa48"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeb103b64297bd6cf28ee7fa50d32fa48">m_dCtrTol</a></td></tr>
<tr class="memdesc:aeb103b64297bd6cf28ee7fa50d32fa48"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for constraints. <br /></td></tr>
<tr class="separator:aeb103b64297bd6cf28ee7fa50d32fa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c000d1bd8bc51c7872e33ca11fa7686"><td class="memItemLeft" align="right" valign="top"><a id="a0c000d1bd8bc51c7872e33ca11fa7686"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a0c000d1bd8bc51c7872e33ca11fa7686">m_dVarTol</a></td></tr>
<tr class="memdesc:a0c000d1bd8bc51c7872e33ca11fa7686"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for variables. <br /></td></tr>
<tr class="separator:a0c000d1bd8bc51c7872e33ca11fa7686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d431fa624d05fde00e75d793e74dd9"><td class="memItemLeft" align="right" valign="top"><a id="ab6d431fa624d05fde00e75d793e74dd9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab6d431fa624d05fde00e75d793e74dd9">m_dShadowPriceTol</a></td></tr>
<tr class="memdesc:ab6d431fa624d05fde00e75d793e74dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for shadow prices (dual variables). <br /></td></tr>
<tr class="separator:ab6d431fa624d05fde00e75d793e74dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13b134629f365286becda3397120a15"><td class="memItemLeft" align="right" valign="top"><a id="af13b134629f365286becda3397120a15"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af13b134629f365286becda3397120a15">m_dRedCostTol</a></td></tr>
<tr class="memdesc:af13b134629f365286becda3397120a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum violation allowed for reduced costs. <br /></td></tr>
<tr class="separator:af13b134629f365286becda3397120a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21faebf3aca5e76c26162dcc6f7af10"><td class="memItemLeft" align="right" valign="top"><a id="af21faebf3aca5e76c26162dcc6f7af10"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af21faebf3aca5e76c26162dcc6f7af10">m_dFixedCost</a></td></tr>
<tr class="memdesc:af21faebf3aca5e76c26162dcc6f7af10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total cost of all variables fixed during preprocessing. <br /></td></tr>
<tr class="separator:af21faebf3aca5e76c26162dcc6f7af10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a4c907971c3140868db8a99830bafc"><td class="memItemLeft" align="right" valign="top"><a id="ad6a4c907971c3140868db8a99830bafc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ad6a4c907971c3140868db8a99830bafc">m_dObjFactor</a></td></tr>
<tr class="memdesc:ad6a4c907971c3140868db8a99830bafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original objective was divided by m_dObjFactor;. <br /></td></tr>
<tr class="separator:ad6a4c907971c3140868db8a99830bafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4ede14bcdeb44ff803c44cc2e37ef"><td class="memItemLeft" align="right" valign="top"><a id="aa6d4ede14bcdeb44ff803c44cc2e37ef"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa6d4ede14bcdeb44ff803c44cc2e37ef">m_dBasicVarCost</a></td></tr>
<tr class="memdesc:aa6d4ede14bcdeb44ff803c44cc2e37ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total cost of basic variables. <br /></td></tr>
<tr class="separator:aa6d4ede14bcdeb44ff803c44cc2e37ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c79e4dd452b61c4d80fc05d29c9c69"><td class="memItemLeft" align="right" valign="top"><a id="a49c79e4dd452b61c4d80fc05d29c9c69"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a49c79e4dd452b61c4d80fc05d29c9c69">m_dObjVal</a></td></tr>
<tr class="memdesc:a49c79e4dd452b61c4d80fc05d29c9c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current value of the objective. <br /></td></tr>
<tr class="separator:a49c79e4dd452b61c4d80fc05d29c9c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16e5422603adf31dcc8fe6e946b3735"><td class="memItemLeft" align="right" valign="top"><a id="ae16e5422603adf31dcc8fe6e946b3735"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae16e5422603adf31dcc8fe6e946b3735">m_dpX</a></td></tr>
<tr class="memdesc:ae16e5422603adf31dcc8fe6e946b3735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime solution; array of size <code>m_iMmax</code>. <br /></td></tr>
<tr class="separator:ae16e5422603adf31dcc8fe6e946b3735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedabe5376d21b4b511bdcd03a980e3fe"><td class="memItemLeft" align="right" valign="top"><a id="aedabe5376d21b4b511bdcd03a980e3fe"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aedabe5376d21b4b511bdcd03a980e3fe">m_dpPi</a></td></tr>
<tr class="memdesc:aedabe5376d21b4b511bdcd03a980e3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual solution (potentials), array of size <code>m_iNmax</code>. <br /></td></tr>
<tr class="separator:aedabe5376d21b4b511bdcd03a980e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54abac0d68019e329bd6cc684ebcd05"><td class="memItemLeft" align="right" valign="top"><a id="af54abac0d68019e329bd6cc684ebcd05"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#af54abac0d68019e329bd6cc684ebcd05">m_dpUd</a></td></tr>
<tr class="memdesc:af54abac0d68019e329bd6cc684ebcd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>m_iNmax</code>. <br /></td></tr>
<tr class="separator:af54abac0d68019e329bd6cc684ebcd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95b1ea11a1eb67618d7439f7aa0022"><td class="memItemLeft" align="right" valign="top"><a id="adf95b1ea11a1eb67618d7439f7aa0022"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adf95b1ea11a1eb67618d7439f7aa0022">m_dpUb</a></td></tr>
<tr class="memdesc:adf95b1ea11a1eb67618d7439f7aa0022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>m_iMmax</code>. <br /></td></tr>
<tr class="separator:adf95b1ea11a1eb67618d7439f7aa0022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb819eb1c693514af99250dc539dddde"><td class="memItemLeft" align="right" valign="top"><a id="aeb819eb1c693514af99250dc539dddde"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeb819eb1c693514af99250dc539dddde">m_ipArray</a></td></tr>
<tr class="memdesc:aeb819eb1c693514af99250dc539dddde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size max{<code>m_iNmax,m_iMmax</code>}. <br /></td></tr>
<tr class="separator:aeb819eb1c693514af99250dc539dddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18035b5a7afb286429309ac7bf5e891"><td class="memItemLeft" align="right" valign="top"><a id="ac18035b5a7afb286429309ac7bf5e891"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac18035b5a7afb286429309ac7bf5e891">m_dpArray</a></td></tr>
<tr class="memdesc:ac18035b5a7afb286429309ac7bf5e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>m_iMmax+m_iNmax</code> <br /></td></tr>
<tr class="separator:ac18035b5a7afb286429309ac7bf5e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda3beaf46e6502f563596b9b18e0b5c"><td class="memItemLeft" align="right" valign="top"><a id="aeda3beaf46e6502f563596b9b18e0b5c"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aeda3beaf46e6502f563596b9b18e0b5c">m_dpW</a></td></tr>
<tr class="memdesc:aeda3beaf46e6502f563596b9b18e0b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>2*m_iMmax</code> <br /></td></tr>
<tr class="separator:aeda3beaf46e6502f563596b9b18e0b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b96d180aada982ac9509c6cb50f114"><td class="memItemLeft" align="right" valign="top"><a id="a29b96d180aada982ac9509c6cb50f114"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a29b96d180aada982ac9509c6cb50f114">m_dpFd</a></td></tr>
<tr class="memdesc:a29b96d180aada982ac9509c6cb50f114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size max{<code>2*m_iNmax</code>}, this array may be freely used in user defined cut or column generating procedures. <br /></td></tr>
<tr class="separator:a29b96d180aada982ac9509c6cb50f114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71711b97d43dd4803e2c75033905fb30"><td class="memItemLeft" align="right" valign="top"><a id="a71711b97d43dd4803e2c75033905fb30"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a71711b97d43dd4803e2c75033905fb30">m_ipFd</a></td></tr>
<tr class="memdesc:a71711b97d43dd4803e2c75033905fb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array that shares memory with &lsquo;m_dpFd&rsquo;. <br /></td></tr>
<tr class="separator:a71711b97d43dd4803e2c75033905fb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e68dbc786c90e43be5fcad0154274"><td class="memItemLeft" align="right" valign="top"><a id="ae38e68dbc786c90e43be5fcad0154274"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae38e68dbc786c90e43be5fcad0154274">m_dpFb</a></td></tr>
<tr class="memdesc:ae38e68dbc786c90e43be5fcad0154274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary array of size <code>max{2*m_iMax,m_iNmax}</code>, this array may be freely used in user defined cut or column generating procedures. <br /></td></tr>
<tr class="separator:ae38e68dbc786c90e43be5fcad0154274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f23a7edca7c9542be3158f05d59cfd"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa9f23a7edca7c9542be3158f05d59cfd">m_dpNorm</a></td></tr>
<tr class="memdesc:aa9f23a7edca7c9542be3158f05d59cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">row or column norms in the current basis.  <a href="#aa9f23a7edca7c9542be3158f05d59cfd">More...</a><br /></td></tr>
<tr class="separator:aa9f23a7edca7c9542be3158f05d59cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683b03d53603fec9f8bb3e0800f697f0"><td class="memItemLeft" align="right" valign="top"><a id="a683b03d53603fec9f8bb3e0800f697f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a683b03d53603fec9f8bb3e0800f697f0">m_iBasisSize</a></td></tr>
<tr class="memdesc:a683b03d53603fec9f8bb3e0800f697f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nontrivial (b1 &lt;= Ax &lt;= b2) inequalities in the basis. <br /></td></tr>
<tr class="separator:a683b03d53603fec9f8bb3e0800f697f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23ed97c6887b059d2066950213df2e5"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae23ed97c6887b059d2066950213df2e5">m_ipBasicRow</a></td></tr>
<tr class="memdesc:ae23ed97c6887b059d2066950213df2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of basic rows.  <a href="#ae23ed97c6887b059d2066950213df2e5">More...</a><br /></td></tr>
<tr class="separator:ae23ed97c6887b059d2066950213df2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac6fb5c88b7e46c5df16aff64fe75c7"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2ac6fb5c88b7e46c5df16aff64fe75c7">m_ipRowMap</a></td></tr>
<tr class="separator:a2ac6fb5c88b7e46c5df16aff64fe75c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e4edaf1625342659a98a2ba97514c2"><td class="memItemLeft" align="right" valign="top"><a id="aa0e4edaf1625342659a98a2ba97514c2"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#aa0e4edaf1625342659a98a2ba97514c2">m_ipBasicColumn</a></td></tr>
<tr class="memdesc:aa0e4edaf1625342659a98a2ba97514c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of basic columns. <br /></td></tr>
<tr class="separator:aa0e4edaf1625342659a98a2ba97514c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40da01358a5856facd1f09ae37a30b3e"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a40da01358a5856facd1f09ae37a30b3e">m_ipColMap</a></td></tr>
<tr class="separator:a40da01358a5856facd1f09ae37a30b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fcbe1d95a832210b0f0e5d86df78bb"><td class="memItemLeft" align="right" valign="top"><a id="a24fcbe1d95a832210b0f0e5d86df78bb"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a24fcbe1d95a832210b0f0e5d86df78bb">m_dpBeta</a></td></tr>
<tr class="memdesc:a24fcbe1d95a832210b0f0e5d86df78bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">values of non-basic rows, the value of row <code>i</code> is A_ix. <br /></td></tr>
<tr class="separator:a24fcbe1d95a832210b0f0e5d86df78bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae6a79711fc48cbf193ded2444bb381"><td class="memItemLeft" align="right" valign="top"><a id="a6ae6a79711fc48cbf193ded2444bb381"></a>
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a6ae6a79711fc48cbf193ded2444bb381">m_eDefLPmethod</a></td></tr>
<tr class="memdesc:a6ae6a79711fc48cbf193ded2444bb381"><td class="mdescLeft">&#160;</td><td class="mdescRight">LP method to solve the root LP. <br /></td></tr>
<tr class="separator:a6ae6a79711fc48cbf193ded2444bb381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5320d1ef11c1b15e977377e21c2b4f8f"><td class="memItemLeft" align="right" valign="top"><a id="a5320d1ef11c1b15e977377e21c2b4f8f"></a>
<a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a5320d1ef11c1b15e977377e21c2b4f8f">m_eLPmethod</a></td></tr>
<tr class="memdesc:a5320d1ef11c1b15e977377e21c2b4f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">currently used LP method. <br /></td></tr>
<tr class="separator:a5320d1ef11c1b15e977377e21c2b4f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec180e2e7d3217a7e10de6bbdc3a1d9"><td class="memItemLeft" align="right" valign="top"><a id="a8ec180e2e7d3217a7e10de6bbdc3a1d9"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a8ec180e2e7d3217a7e10de6bbdc3a1d9">m_uRowColGenRule</a></td></tr>
<tr class="memdesc:a8ec180e2e7d3217a7e10de6bbdc3a1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitwise OR of the members of <code>enRowColGenRule</code>; by default, all flags are set to <code>1</code>. <br /></td></tr>
<tr class="separator:a8ec180e2e7d3217a7e10de6bbdc3a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0091e586c5494aaf315cd888a272d69"><td class="memItemLeft" align="right" valign="top"><a id="ae0091e586c5494aaf315cd888a272d69"></a>
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ae0091e586c5494aaf315cd888a272d69">m_eSepRule</a></td></tr>
<tr class="memdesc:ae0091e586c5494aaf315cd888a272d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">currently used separation rule. <br /></td></tr>
<tr class="separator:ae0091e586c5494aaf315cd888a272d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956dade3f7dc89a9eac2dc4e78839fb"><td class="memItemLeft" align="right" valign="top"><a id="a9956dade3f7dc89a9eac2dc4e78839fb"></a>
<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a9956dade3f7dc89a9eac2dc4e78839fb">m_ePricingRule</a></td></tr>
<tr class="memdesc:a9956dade3f7dc89a9eac2dc4e78839fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">currently used pricing rule. <br /></td></tr>
<tr class="separator:a9956dade3f7dc89a9eac2dc4e78839fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaa7b865b5dd74040a394fc75bf82c2"><td class="memItemLeft" align="right" valign="top"><a id="a2eaa7b865b5dd74040a394fc75bf82c2"></a>
<a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a2eaa7b865b5dd74040a394fc75bf82c2">m_eLpSepRule</a></td></tr>
<tr class="memdesc:a2eaa7b865b5dd74040a394fc75bf82c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">separation rule used for solving pure LPs as well as root LPs when solving MIPs. <br /></td></tr>
<tr class="separator:a2eaa7b865b5dd74040a394fc75bf82c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2e7d8f12feb9b9733c39a85ccbd5b"><td class="memItemLeft" align="right" valign="top"><a id="a17e2e7d8f12feb9b9733c39a85ccbd5b"></a>
<a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a17e2e7d8f12feb9b9733c39a85ccbd5b">m_eLpPricingRule</a></td></tr>
<tr class="memdesc:a17e2e7d8f12feb9b9733c39a85ccbd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">pricing rule used for solving pure LPs as well as root LPs when solving MIPs. <br /></td></tr>
<tr class="separator:a17e2e7d8f12feb9b9733c39a85ccbd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cd21a6ec2235b331ec6028d4fc0796"><td class="memItemLeft" align="right" valign="top"><a id="a78cd21a6ec2235b331ec6028d4fc0796"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a78cd21a6ec2235b331ec6028d4fc0796">m_iPreproc</a></td></tr>
<tr class="memdesc:a78cd21a6ec2235b331ec6028d4fc0796"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code> preprocessing is on; default value is <code>true</code>. <br /></td></tr>
<tr class="separator:a78cd21a6ec2235b331ec6028d4fc0796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab88d3ae9edeb713cf10c5e902b3d8b"><td class="memItemLeft" align="right" valign="top"><a id="a1ab88d3ae9edeb713cf10c5e902b3d8b"></a>
CPrepStack *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a1ab88d3ae9edeb713cf10c5e902b3d8b">m_pPrepStack</a></td></tr>
<tr class="memdesc:a1ab88d3ae9edeb713cf10c5e902b3d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the preprocessing stack. <br /></td></tr>
<tr class="separator:a1ab88d3ae9edeb713cf10c5e902b3d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02c276e8722797060de6ce60c584603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ac02c276e8722797060de6ce60c584603">m_iUpdatePrimeSol</a></td></tr>
<tr class="memdesc:ac02c276e8722797060de6ce60c584603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of modified bounds of non-basic variables.  <a href="#ac02c276e8722797060de6ce60c584603">More...</a><br /></td></tr>
<tr class="separator:ac02c276e8722797060de6ce60c584603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0c15b9fea34f0c6b2c35daf355e6e"><td class="memItemLeft" align="right" valign="top"><a id="ab1c0c15b9fea34f0c6b2c35daf355e6e"></a>
CLU *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#ab1c0c15b9fea34f0c6b2c35daf355e6e">m_pLU</a></td></tr>
<tr class="memdesc:ab1c0c15b9fea34f0c6b2c35daf355e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to an object of class CLU, that solves linear systems. <br /></td></tr>
<tr class="separator:ab1c0c15b9fea34f0c6b2c35daf355e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15c88aa7b438465151ddf272299b81"><td class="memItemLeft" align="right" valign="top"><a id="adc15c88aa7b438465151ddf272299b81"></a>
<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#adc15c88aa7b438465151ddf272299b81">m_lStartTime</a></td></tr>
<tr class="memdesc:adc15c88aa7b438465151ddf272299b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start time of solving problem. <br /></td></tr>
<tr class="separator:adc15c88aa7b438465151ddf272299b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a280474af48da416e332e4b3b12aa"><td class="memItemLeft" align="right" valign="top"><a id="a323a280474af48da416e332e4b3b12aa"></a>
<a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLP.html#a323a280474af48da416e332e4b3b12aa">m_lSolTime</a></td></tr>
<tr class="memdesc:a323a280474af48da416e332e4b3b12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution time. <br /></td></tr>
<tr class="separator:a323a280474af48da416e332e4b3b12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab403485392b07dbdc11fcfd2faf8d89e"><td class="memItemLeft" align="right" valign="top"><a id="ab403485392b07dbdc11fcfd2faf8d89e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CLU</b></td></tr>
<tr class="separator:ab403485392b07dbdc11fcfd2faf8d89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfa7ea2d9e38843e05d178ce682c7a2"><td class="memItemLeft" align="right" valign="top"><a id="a7cfa7ea2d9e38843e05d178ce682c7a2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CMIP</b></td></tr>
<tr class="separator:a7cfa7ea2d9e38843e05d178ce682c7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b895b191f6f31edfad184050c8c4f1a"><td class="memItemLeft" align="right" valign="top"><a id="a6b895b191f6f31edfad184050c8c4f1a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CNormCone</b></td></tr>
<tr class="separator:a6b895b191f6f31edfad184050c8c4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class has been designed for solving Linear Programs (LPs) </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} &amp; c^Tx \to \max,\\ &amp; b_1 \le Ax \le b_2,\\ &amp; l \le x \le u, \end{align*}" src="form_335.png"/>
</p>
<p> by both, prime and dual, simplex methods. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="accbd20f2d40a5aec4e06474a7bef2b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbd20f2d40a5aec4e06474a7bef2b2d">&#9670;&nbsp;</a></span>tagHANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">CLP::tagHANDLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>program type for handles of variables and constraints </p>
<p>If preprocessing is switched on (default option) or columns are generated, the solver do not preserve the order in which the variables were added to the matrix. The handles are primarily used for mapping the variables in the solver memory onto user's variables. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ace10a11a6c69fa8274ad8bc2c0930adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace10a11a6c69fa8274ad8bc2c0930adb">&#9670;&nbsp;</a></span>enAlign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#ace10a11a6c69fa8274ad8bc2c0930adb">CLP::enAlign</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix alignment. </p>
<p>The non-zero matrix entries may be listed either <em>column-wise</em> or <em>row-wise</em>. It is also possible that the entries are not ordered at all. Furthermore, even if the non-zero entries are ordered before the solution procedure starts, after adding to the matrix new rows and/or columns, the previous alignment will be lost. In the latter case, we say that the matrix is <em>approximately aligned</em> either column-wise or row-wise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ace10a11a6c69fa8274ad8bc2c0930adba34241e0294a551922cb9654241c0264e"></a>ALIGN_NONE&#160;</td><td class="fielddoc"><p>no alignment </p>
</td></tr>
<tr><td class="fieldname"><a id="ace10a11a6c69fa8274ad8bc2c0930adba5b32d4c1a0a5ac7c241c11a6163c91e3"></a>ALIGN_COLUMN_APPR&#160;</td><td class="fielddoc"><p>mainly by columns </p>
</td></tr>
<tr><td class="fieldname"><a id="ace10a11a6c69fa8274ad8bc2c0930adba7120d50531f63f160b00ee40e0890dee"></a>ALIGN_COLUMN&#160;</td><td class="fielddoc"><p>by columns </p>
</td></tr>
<tr><td class="fieldname"><a id="ace10a11a6c69fa8274ad8bc2c0930adbabaed747e2cb0b5a487629baf13187eff"></a>ALIGN_ROW_APPR&#160;</td><td class="fielddoc"><p>mainly by rows </p>
</td></tr>
<tr><td class="fieldname"><a id="ace10a11a6c69fa8274ad8bc2c0930adba11b7111fe3445164fabe75cf968797b7"></a>ALIGN_ROW&#160;</td><td class="fielddoc"><p>by rows </p>
</td></tr>
</table>

</div>
</div>
<a id="ac886bb1c9454ba327bc52b46b72f7ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac886bb1c9454ba327bc52b46b72f7ac5">&#9670;&nbsp;</a></span>enCtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5">CLP::enCtrType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LP types of constraints. </p>
<p>The type of a constraint is the bitwise OR of the members of <code>enCtrType</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5a17870c44aecd572149dda0acb4e4a4e1"></a>CTR_ATTACHED&#160;</td><td class="fielddoc"><p>constrains of this type cannot be removed from matrix </p>
</td></tr>
<tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5a4ee63b4bd702d2ace98cbed25c6cbad3"></a>CTR_LEFT&#160;</td><td class="fielddoc"><p>constraints is <em>left bounded</em> (its left hand side is finite) </p>
</td></tr>
<tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5a71ef23a0ef46d3a746342572433e4005"></a>CTR_RIGHT&#160;</td><td class="fielddoc"><p>constraints is <em>right bounded</em> (its right hand side is finite) </p>
</td></tr>
<tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5a7cc6aa09c75f6c23bd366a2db73be4d3"></a>CTR_EQ&#160;</td><td class="fielddoc"><p>constraint is equation </p>
</td></tr>
<tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5a8590663fa4e694651fdb18d53692f8b0"></a>CTR_REF&#160;</td><td class="fielddoc"><p>flag is <em>privately</em> used in <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> </p>
</td></tr>
<tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5a7baf38b91fd84aef5a2a1427a29d85e1"></a>CTR_NOT_STABLE&#160;</td><td class="fielddoc"><p>With too big or too small coefficients, or has been derived from non-stable constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac886bb1c9454ba327bc52b46b72f7ac5aa8a12a75b7a358499e47f39d2f95a09e"></a>CTR_STRONG_CUT&#160;</td><td class="fielddoc"><p>cutting planes (cuts) with this flag are treated as ordinary inequalities </p>
</td></tr>
</table>

</div>
</div>
<a id="a2a7aedeedf26a9bcab5d5e32c528131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7aedeedf26a9bcab5d5e32c528131e">&#9670;&nbsp;</a></span>enLPmethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">CLP::enLPmethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LP methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a7aedeedf26a9bcab5d5e32c528131ea697958327067d98ba307d62f67481c0e"></a>AUTO_DETECT&#160;</td><td class="fielddoc"><p>It is left to the solver to decide what method to use for solving LPs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a7aedeedf26a9bcab5d5e32c528131ea35f36965643458a225f51afbb5397d7a"></a>PRIME_SIMPLEX&#160;</td><td class="fielddoc"><p>Prime simplex is used for solving LPs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a7aedeedf26a9bcab5d5e32c528131eaeed16c0d496a65145f7141620c5672d0"></a>DUAL_SIMPLEX&#160;</td><td class="fielddoc"><p>Dual simplex is used for solving LPs. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad5c02821b739c221b8e3672a46bc4ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c02821b739c221b8e3672a46bc4ea5">&#9670;&nbsp;</a></span>enPricingRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">CLP::enPricingRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pricing rules. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad5c02821b739c221b8e3672a46bc4ea5ae48c44231bbfa3ac7fe3fe5da097ff07"></a>PRC_MOST_NEGATIVE&#160;</td><td class="fielddoc"><p>Variable with most negative reduced cost is chosen. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad5c02821b739c221b8e3672a46bc4ea5aa4e9e8e12c37d6c438d381a83548a716"></a>PRC_STEEPEST_EDGE&#160;</td><td class="fielddoc"><p>Reduced cost of each variable is divided by the norm of corresponding column, and then variable with minimum ratio is chosen. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5e51337d2a33971e7a2264f67ca2da7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e51337d2a33971e7a2264f67ca2da7c">&#9670;&nbsp;</a></span>enProbState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#a5e51337d2a33971e7a2264f67ca2da7c">CLP::enProbState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Problem states. </p>
<p>Any current state of the problem being solved is composed as the bitwise OR of the members of <code>enProbState</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca300af909e7e8cc4050337ef393e3b621"></a>PROB_IN_MEMORY&#160;</td><td class="fielddoc"><p>Memory necessary to solve problem has been allocated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca4260338e83d735350ac2666fd3f6961c"></a>PROB_PREPARED&#160;</td><td class="fielddoc"><p>Ready (memory allocated, matrix preprocessed and scaled) for optimizing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7cadb019ad240e07281feac40268900ed8c"></a>PROB_SOLVED&#160;</td><td class="fielddoc"><p>Problem has been solved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca8a28cfac879be4fe1d8b1a8a730c31db"></a>PROB_SOLUTION&#160;</td><td class="fielddoc"><p>Solution has been found. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca765cf6c45c6287f4455c63caa5fcf124"></a>PROB_OPTIMAL&#160;</td><td class="fielddoc"><p>Optimality has been proven. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca753e10e160501d94a4d8323eca7bd122"></a>PROB_INFEASIBLE&#160;</td><td class="fielddoc"><p>Constraint inconsistency has been proven. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca344a364e11ae7dac9083dfdf55350730"></a>PROB_UNBOUNDED&#160;</td><td class="fielddoc"><p>Objective function is not bounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca66f16d92983df6d6c7ab69d86cad91dc"></a>PROB_TIME_LIMIT&#160;</td><td class="fielddoc"><p>Time limit exceeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca3b27f003075cc320ebfd74e650faf954"></a>PROB_IT_LIMIT&#160;</td><td class="fielddoc"><p>Limit on number of iterates exceeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7cab13b9d0a37f3789e994cf1f80a37b313"></a>PROB_GAP_LIMIT&#160;</td><td class="fielddoc"><p>Required integrality gap attained. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e51337d2a33971e7a2264f67ca2da7ca0e5044d101dabb9568bb3e9daa858a88"></a>PROB_SOLVER_FLAGS&#160;</td><td class="fielddoc"><p>Bitwise OR of all <code>enProbState</code> masks. </p>
</td></tr>
</table>

</div>
</div>
<a id="add8a9c8d5a775156d30aecba3bf74511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8a9c8d5a775156d30aecba3bf74511">&#9670;&nbsp;</a></span>enRowColGenRule1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#add8a9c8d5a775156d30aecba3bf74511">CLP::enRowColGenRule1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A bitwise ORing of the members of <code>enRowColGenRule1</code> stored in <code>m_uRowColGenRule</code> determines whether rows and/or columns are generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add8a9c8d5a775156d30aecba3bf74511ac4fc40898634e36cad90e2bcd27f99fa"></a>ROW_GEN&#160;</td><td class="fielddoc"><p>Rows/cuts can be generated by overloading <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code>, <code>genCut1()</code>, or cut generating procedures implemented in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="add8a9c8d5a775156d30aecba3bf74511aacfac1c0a7476a3f064a96e49be704e5"></a>COL_GEN&#160;</td><td class="fielddoc"><p>Columns can be generated by overloading <code><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns()</a></code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="add8a9c8d5a775156d30aecba3bf74511a004c24655361633c62bdf2ac91754b21"></a>SEP_PROC&#160;</td><td class="fielddoc"><p>If <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a></code> has been overloaded. </p>
</td></tr>
</table>

</div>
</div>
<a id="a69612f747174f3c3e3a19f17cc290877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69612f747174f3c3e3a19f17cc290877">&#9670;&nbsp;</a></span>enScaling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">CLP::enScaling</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the list of all possible ways to scale matrix. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877a9532f46e77b8de78728d81810061351b"></a>SCL_MINMAX&#160;</td><td class="fielddoc"><p>Min-max scaling. </p>
<p>A row (resp., column) scaling factor is the power of 2 that is closest to the average value of the minimum and maximum absolute values of coefficients in that row (resp., column). The min-max scaling procedure 10 times, in turn, first computes row scaling factors and multiplies all rows by their factors, and then computes column scaling factors and multiplies all the columns by their factors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877a2b3dcc735540c010ca52f111da1c3dc3"></a>SCL_IDEAL&#160;</td><td class="fielddoc"><p>Ideal scaling. </p>
<p>The <em>ideal scaling</em> procedure applies a complex algorithm to compute scaling factors such that, after scaling, the difference between the maximum and minimum of the absolute values of matrix coefficients is minimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877a631c5045eeaeb601216f6656771dbbce"></a>SCL_NO&#160;</td><td class="fielddoc"><p>Switches off scaling. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877ada2e041936a7a640550da4030530efdc"></a>SCL_GM_ROWS&#160;</td><td class="fielddoc"><p>Geometric-mean scaling, rows are scaled after columns. </p>
<p>A row (resp., column) scaling factor is the power of 2 that is closest to the geometric mean value of the absolute values of coefficients in that row (resp., column). The <em>geometric-mean scaling</em> procedure 10 times, in turn, first computes column scaling factors and multiplies all columns by their factors, and then computes rows scaling factors and multiplies all rows by their factors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877a3cfbdf746ead117eef50c65af47ee2b7"></a>SCL_GM_COLUMNS&#160;</td><td class="fielddoc"><p>Geometric-mean scaling, rows are scaled before columns (for details, see <code>SCL_GM_ROWS</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877ac0fb16c8f4cdc516084e20388b16b3a8"></a>SCL_MAX_ROWS&#160;</td><td class="fielddoc"><p>Max-value scaling, rows are scaled after columns. </p>
<p>A row (resp., column) scaling factor is the power of 2 that is closest to the maximum absolute values of coefficients in that row (resp., column). The _ max-value scaling_ procedure 10 times, in turn, first computes column scaling factors and multiplies all columns by their factors, and then computes rows scaling factors and multiplies all rows by their factors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877a787bfbff974c356dd7176911fbb4b75e"></a>SCL_MAX_COLUMNS&#160;</td><td class="fielddoc"><p>Max-value scaling, rows are scaled before columns (for details, see <code>SCL_MAX_ROWS</code>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1"></a>NOT_SCALED&#160;</td><td class="fielddoc"><p>When adding to the matrix a new constraint (or column), the value of scaling factor set to <code>NOT_SCALED</code> means that this constraint (or column) is to be scaled by the solver. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69612f747174f3c3e3a19f17cc290877a745b552b1fe7fdce8d141b0e2871dfd7"></a>SCL_MIN_EXP&#160;</td><td class="fielddoc"><p>When scaling, entries with exponents less than <code>SCL_MIN_EXP</code> are treated as zeroes. </p>
</td></tr>
</table>

</div>
</div>
<a id="abd7826c555555d1888a96efa8572f584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7826c555555d1888a96efa8572f584">&#9670;&nbsp;</a></span>enSepRule</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">CLP::enSepRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separation rules. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd7826c555555d1888a96efa8572f584a3d90bed8af607e02248519ef975a5fd2"></a>SEP_MOST_VIOLATED&#160;</td><td class="fielddoc"><p>Most violated constraint is chosen. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd7826c555555d1888a96efa8572f584aca8dfbedb02a31e924028a8654748398"></a>SEP_ONLY_EQUATIONS&#160;</td><td class="fielddoc"><p>Violated constraint is chosen only among equations. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd7826c555555d1888a96efa8572f584a93f0269d58431e5756c7f60d41e04cf9"></a>SEP_STEEPEST_EDGE&#160;</td><td class="fielddoc"><pre class="fragment">    Steepest edge rule, i.e.,
    violation of each constraint is divided by the norm of corresponding row,
</pre><p> and then constraint with minimum ratio is chosen. </p>
</td></tr>
</table>

</div>
</div>
<a id="a89292c62c83b834a8b451bde23c67627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89292c62c83b834a8b451bde23c67627">&#9670;&nbsp;</a></span>enVarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627">CLP::enVarType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LP types of variables. </p>
<p>The type of a variable is the bitwise OR of the members of <code>enVarType</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627a5d331e9cfab0f7598da11cd0ea9ebc03"></a>VAR_LEFT&#160;</td><td class="fielddoc"><p>variable is <em>lower bounded</em> (its lower bound is finite) </p>
</td></tr>
<tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627ad51df68c924dac7c246f9c30cc587b2e"></a>VAR_RIGHT&#160;</td><td class="fielddoc"><p>variable is <em>upper bounded</em> (its upper bound is finite) </p>
</td></tr>
<tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627ab75d53368c617fc8c888e93c0d03d491"></a>VAR_FX&#160;</td><td class="fielddoc"><p>variable is <em>fixed</em> </p>
</td></tr>
<tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627a9df0f737a50b3d4bd2072c3c15b468fb"></a>VAR_REF&#160;</td><td class="fielddoc"><p>is <em>privately</em> used in <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627a0600f7f3589a4726507c1ea72fd81cdc"></a>VAR_NOT_MOD&#160;</td><td class="fielddoc"><p>a variable with this flag set cannot be modified in any way (deleted or scaled) </p>
</td></tr>
<tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627a2f778e20d4c99ef9739681b2bc811b0d"></a>VAR_INT&#160;</td><td class="fielddoc"><p>integral variable, meaningless in <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a89292c62c83b834a8b451bde23c67627a4c836f1a6ffec0f890beb0768c6e3cdd"></a>VAR_BIN&#160;</td><td class="fielddoc"><p>Binary variable. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0e0ce3e6c4b9beb30c8a1f2b8cb8fd">&#9670;&nbsp;</a></span>CLP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLP::CLP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor initializes an "empty" <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> object and sets the problem name to <code>name</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>problem name of no more than '30' characters; if <code>name==0</code>, problem name will be a featureless "LP". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d4fd54e671d455d0c012dc5c768f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d4fd54e671d455d0c012dc5c768f1b">&#9670;&nbsp;</a></span>CLP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLP::CLP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCLP.html">CLP</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone constructor. </p>
<p>This constructor is used in multithreaded MIP applications. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> object to be cloned; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>thread index (positive integer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The clone constructors in any derived class first must call the clone constructor of the base class. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCMIP.html#aa30befe3b11b8199abae19c7d9824d85" title="Clone constructor.">CMIP::CMIP(const CMIP &amp;other, int thread)</a></code>, <code><a class="el" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013" title="The clone constructor.">CMIP::clone()</a></code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aae1903c28e39c136ec8fcbe9cb65a8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1903c28e39c136ec8fcbe9cb65a8bd">&#9670;&nbsp;</a></span>addColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function adds a column to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of the variable; if hd &gt;= 0, then you must overload <code><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn()</a></code> (version with 11 parameters); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cost</td><td>objective coefficient; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l,u</td><td>lower and upper bounds of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of nonzero entries; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipRow</td><td>arrays of size <code>sz</code>; <code>dpVal[i]</code> is coefficient in row <code>ipRow[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bSort</td><td>if <code>true</code>, column entries are sorted in increasing order of their row indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of added column (variable). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d5b435146fc416d5bc296f0acbbf029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5b435146fc416d5bc296f0acbbf029">&#9670;&nbsp;</a></span>addCtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addCtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function adds a constraint (empty row) to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of the constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of the constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs,rhs</td><td>respectively, left (LHS) and right (RHS) hand sides of constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constraint index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow()</a>, <a class="el" href="classCLP.html#ac7cfc7443dff945bc5a424fb161e5d5c">safeAddRow()</a>. </dd></dl>

</div>
</div>
<a id="a574534be9bfcd5d37b8cd209cf2e2535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574534be9bfcd5d37b8cd209cf2e2535">&#9670;&nbsp;</a></span>addEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::addEntry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The functions adds to the matrix the entry of value <code>val</code> into row <code>i</code> and column <code>j</code>; if <code>i &lt; 0</code>, the function sets the cost of variable <code>j</code>, <code>m_dpC[j]=val</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>entry value; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad040a1690b496a9f62cf0908b953360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad040a1690b496a9f62cf0908b953360a">&#9670;&nbsp;</a></span>addNewColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addNewColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of the variable; if <code>hd &gt;= 0</code>, then you must overload <code><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn()</a></code> (version with 11 parameters); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cost</td><td>objective coefficient; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l,u</td><td>lower and upper bounds of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of nonzero entries; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipRow</td><td>arrays of size <code>sz</code>; <code>dpVal[i]</code> is coefficient in row <code>ipRow[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>if <code>true</code>, then in current basis variable takes value of <code>u</code>; otherwise, variable takes value of <code>l</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaled</td><td>if <code>true</code>, column is given in scaled variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>- scale factor, set <code>factor=NOT_SCALED</code> if column must be scaled; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>set it to <code>true</code>, only if <code><a class="el" href="classCLP.html#ad040a1690b496a9f62cf0908b953360a">addNewColumn()</a></code> is called within <code><a class="el" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns()</a></code>; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of newly created column (variable). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40b16107bf05adff72406dbb0869d682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b16107bf05adff72406dbb0869d682">&#9670;&nbsp;</a></span>addNewRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addNewRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVarScaled</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877ac1c76e08ff8249d919f9d37201baffc1">NOT_SCALED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toBasis</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to add new constraints to the closed matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b1,b2</td><td>respectively, left (LHS) and right (RHS) hand sides of constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of non-zero entries; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipCol</td><td>references to arrays of size <code>sz</code>, <code>dpVal[i]</code> is coefficient at variable <code>ipCol[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bVarScaled</td><td>if <code>true</code>, constraint is expressed in scaled variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>scale factor; <code>NOT_SCALED</code> value means that constraint is to be scaled by <b>MIPCL</b> itself; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>if non-zero, number of columns in original (non-preprocessed) problem; in such a case the expressions in the preprocessing stack are used to substitute the variables <code>m_iN,...,n-1</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toBasis</td><td>if <code>true</code>, data structures representing basis are slightly modified; in rare cases when the matrix has been closed already, but optimization has not been started yet, <code>toBasis</code> must be set to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of newly created constraint. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The procedure adds the constraint to the matrix but not to the MIP pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow()</a>, <a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow()</a>, <a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">CMIP::genCut1()</a>, <a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">CMIP::genCut2()</a>. </dd></dl>

</div>
</div>
<a id="a098f07b72b28d7ca0a26423c6a822dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098f07b72b28d7ca0a26423c6a822dd6">&#9670;&nbsp;</a></span>addNormCtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addNormCtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds a norm constraint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>right-hand-side variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of variables involved in left-hand-side vector; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipVars</td><td>list (of size <code>sz</code>) of variables involved in left-hand-side vector; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a5d3621d8732a32eab9a5314e75a6068c">allowNormCtrs()</a>, <a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate()</a> </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>do not call <code><a class="el" href="classCLP.html#a098f07b72b28d7ca0a26423c6a822dd6">addNormCtr()</a></code> without calling <code><a class="el" href="classCLP.html#a5d3621d8732a32eab9a5314e75a6068c">allowNormCtrs()</a></code>. </dd></dl>

</div>
</div>
<a id="aee7861b5b2e692f6043dfe1d7bd77e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7861b5b2e692f6043dfe1d7bd77e21">&#9670;&nbsp;</a></span>addRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to add a row (constraint) to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of row (constraint); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs,rhs</td><td>respectively, left (LHS) and right (RHS) hand sides of constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of non-zero entries; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipCol</td><td>references to arrays of size <code>sz</code>, <code>dpVal[i]</code> is the coefficient at variable <code>ipCol[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bSort</td><td>if <code>true</code>, row entries are sorted in increasing order of their column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constraint index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a0d5b435146fc416d5bc296f0acbbf029">addCtr()</a>, <a class="el" href="classCLP.html#ac7cfc7443dff945bc5a424fb161e5d5c">safeAddRow()</a>, <a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow()</a>. </dd></dl>

</div>
</div>
<a id="a41e6abd8eca3cbf22a958dbddbfe9069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e6abd8eca3cbf22a958dbddbfe9069">&#9670;&nbsp;</a></span>addVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::addVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function adds a variable (empty column) to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of variable; if hd &lt; 0, then you must overload <code><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn()</a></code> (version with 11 parameters); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cost</td><td>objective coefficient; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l,u</td><td>lower and upper bounds of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of added column (variable). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343e6b0b673160229a69b80fc8e08f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343e6b0b673160229a69b80fc8e08f7a">&#9670;&nbsp;</a></span>allocMemForAuxArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::allocMemForAuxArrays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function allocates memory for three auxiliary arrays, <code>m_dpArray</code> and <code>m_ipArray</code>, both of size <code>m_iNmax+m_iMmax</code>, <code>m_dpArray</code> and <code>m_ipArray</code>, both of size <code>m_iNmax+m_iMmax</code>, <code>dpW</code> of size <code>2*m_iMmax</code>, <code>m_dpFd</code> of size 2*m_iNmax<code>, and</code>m_dpFb<code>of size</code>max{2*m_iMmax,m_iNmax}`.</p>
<dl class="section attention"><dt>Attention</dt><dd><code><a class="el" href="classCLP.html#a343e6b0b673160229a69b80fc8e08f7a">allocMemForAuxArrays()</a></code> should not be called in user applications. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aa893045084c9180cec0420d0c1b0a6ad">reallocMemForAuxArrays()</a>. </dd></dl>

</div>
</div>
<a id="afe129407333ac743e0c4da6dd2ae5128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe129407333ac743e0c4da6dd2ae5128">&#9670;&nbsp;</a></span>allocMemForSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::allocMemForSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure allocates memory needed for both, prime and dual, simplex algorithms. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d3621d8732a32eab9a5314e75a6068c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3621d8732a32eab9a5314e75a6068c">&#9670;&nbsp;</a></span>allowNormCtrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::allowNormCtrs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCtrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>avCtrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Using quadratic constraints in MIPs is not common.
Therefore, __MIPCL__ treats norm-cone constraints of the form \f$\|x\|\le t\f$ as a supplementary feature.
Despite of apparent simplicity of such norm-constraints, we can use them to model
many restrictions of practical importance.
To use such restrictions in your __MIPCL__ application,
call `allowNormCtrs()` before `closeMatrix()`.
In most case (if not in all) you must also disable the preprocessing,
the application of which to an incomplete formulation will almost certainly result in an error.

\param[in] maxCtrNum maximum number of norm constraints;
\param[in] avCtrSize average size of norm constraints to be added.
</pre> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aead89f9f0ae4100f6639678a8ff98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aead89f9f0ae4100f6639678a8ff98b">&#9670;&nbsp;</a></span>basicPreprocess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::basicPreprocess </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDominant</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preprocessing without probing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bDominant</td><td>if <code>true</code>, dominated constraints are detected and processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of variables fixed and constraints eliminated. </dd></dl>

</div>
</div>
<a id="a704eb701bea22a2008f3bd02f1c561cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704eb701bea22a2008f3bd02f1c561cc">&#9670;&nbsp;</a></span>beSilent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::beSilent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>if set to <code>true</code>, all run time messages are blocked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a099efa5c25b4be3361d2764584f4fb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099efa5c25b4be3361d2764584f4fb81">&#9670;&nbsp;</a></span>buildRowColLists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::buildRowColLists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used internally in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. It builds linked lists of both, rows and columns. </p>

</div>
</div>
<a id="aafd55a5bdee0bded239e5d2d772cbea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd55a5bdee0bded239e5d2d772cbea5">&#9670;&nbsp;</a></span>changeEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::changeEntry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function changes the matrix entry in row <code>i</code> and column <code>j</code>; if <code>i &lt; 0</code>, the function changes the cost of variable <code>j</code>, setting <code>m_dpC[j]=val</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>new entry value; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e86b274e43b78732ff9f51b9249f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e86b274e43b78732ff9f51b9249f33">&#9670;&nbsp;</a></span>closeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::closeMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does all preparations for solving the problem: allocates memory, does preprocessing, scales the matrix. </p>

<p>Reimplemented in <a class="el" href="classCMIP.html#ac5a190e3a9fea5b1ee960edf73d9fa66">CMIP</a>.</p>

</div>
</div>
<a id="a1c15331979ed725b3175a0547b8885a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c15331979ed725b3175a0547b8885a7">&#9670;&nbsp;</a></span>compressMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::compressMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEntry</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure deletes from the matrix all the rows and columns that were deleted during preprocessing. This procedure is also used in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code> to delete from the matrix those cuts that are not "tight" for optimal node LP-solutions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m0</td><td>initial row to start search for unneeded rows; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n0</td><td>initial column to start search for unneeded columns; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prepFlag</td><td>if <code>true</code>, expressions in preprocessing stack are also updated; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEntry</td><td>is used internally in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Never set both, <code>prepFlag</code> and <code>bEntry</code>, flags to <code>false</code> in your applications. </dd></dl>

</div>
</div>
<a id="a3440356b6889cf285de7eb2a2c852a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3440356b6889cf285de7eb2a2c852a42">&#9670;&nbsp;</a></span>computeBasicColumnSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::computeBasicColumnSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function computes the vector weighted sum of all non-basic columns, i.e. each column is first multiplied by the value of corresponding variable. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#abbdf654da45516869b3d507ed7a03be7">incColumnSum()</a>. </dd></dl>

</div>
</div>
<a id="a9d5309eca95342409d93fec05a7375d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5309eca95342409d93fec05a7375d7">&#9670;&nbsp;</a></span>computeObjValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::computeObjValue </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recomputeBasicVarsCost</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recomputeBasicVarsCost</td><td>if <code>true</code>, total cost of non-basic variables stored in <code>m_dBasicVarCost</code> is recomputed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cost of of current basic solution. </dd></dl>

</div>
</div>
<a id="a99f4f473f360001301df583f052d3b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f4f473f360001301df583f052d3b53">&#9670;&nbsp;</a></span>computeX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::computeX </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function computes the expression of a given vector in the current basis. If <code>col &gt;= 0</code>, then the expression (in current basis) of the unit vector with 1 in position <code>col</code> is computed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>array of size <code>m_iN</code> storing vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used internally in <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> and <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a59e3d3e14993182d12867c6c23c2107e">computeY()</a>. </dd></dl>

</div>
</div>
<a id="a59e3d3e14993182d12867c6c23c2107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e3d3e14993182d12867c6c23c2107e">&#9670;&nbsp;</a></span>computeY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::computeY </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withFixedVars</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function computes the expression of a given dual vector in the current basis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>array of size <code>m_iN</code> storing vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">withFixedVars</td><td>if <code>false</code> reduced costs of fixed variables are not computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used internally in <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> and <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a99f4f473f360001301df583f052d3b53">computeX()</a>. </dd></dl>

</div>
</div>
<a id="a28902beb78bacc0501a0991a87621655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28902beb78bacc0501a0991a87621655">&#9670;&nbsp;</a></span>deleteNonBasicLines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::deleteNonBasicLines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure deletes all "_non-tight_" inequalities and columns previously generated during the solution process, and which indices <code>&gt;=</code> m for rows, and <code>&gt;= n</code> for columns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>only rows which index is not less than <code>m</code> are considered as candidates for deletion; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>only columns which index is not less than <code>n</code> are considered as candidates for deletion; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bFull</td><td>if <code>true</code>, matrix must be compressed and solution be updated; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tight</td><td>inequality (resp, column) is "_tight_" if its <em>slack</em> (resp., <em>reduced cost</em>) is less than value of <code>tight</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad95f90e4d8c3668245e5cac467cfba21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95f90e4d8c3668245e5cac467cfba21">&#9670;&nbsp;</a></span>deleteVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::deleteVariable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function deletes variable (column) <code>j</code> from the matrix and adds its expression x(j) = b +sum(i=0,...,sz-1} dpVal[i]*x(ipCol[i]) to the preprocessing stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of deleted variable, or <code>hd in {-1,-2}</code>; if <code>hd = -1</code>, then <code>sz = 1</code> and variable <code>x[ipCol[0]]</code> is substituted for <code>x[ipCol[0]]*dpVal[0]+b</code>; if <code>hd = 2</code>, then <code>sz = 1</code>, and, for <code>c=reinterpret_cast&lt;int*&gt;(dpVal)[0]</code>, if <code>x[ipCol[0]] &gt;= 0.0</code>, then <code>x[c]=0.0</code>; otherwise, <code>x[c]=-x[ipCol[0]]</code> and <code>x[ipCol[0]]=0.0</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>free term of expression; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of variables in expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipCol</td><td>list of <code>sz</code> variables (columns) in expression; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal</td><td>list of <code>sz</code> coefficients in expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f4a451dece7eb131a6c63bdcc7189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f4a451dece7eb131a6c63bdcc7189d">&#9670;&nbsp;</a></span>dualSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::dualSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>timeToStop</em> = <code>0l</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowerBound</em> = <code>-<a class="el" href="classCLP.html#acbcd9ecf00ad8658d570dd803b0aabe3">INF</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxItNum</em> = <code>1000000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>needSol</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inconsistSertificate</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degCheckInterval</em> = <code>250</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDegPrc</em> = <code>90</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure implements a dual simplex algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeToStop</td><td>procedure will stop running at time <code>timeToStop</code> (given in seconds since epoch); <code>timeToStop==0l</code> means no time limitation; if you want <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code> to stop running in <code>timeLimit</code> seconds, set <code>timeToStop=<a class="el" href="classCLP.html#ae15b567a7fcdf060320225b107e5a7c2">getStartTime()</a>/1000l + timeLimit</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerBound</td><td>procedure stops if objective value becomes less than <code>lowerBound</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxItNum</td><td>procedure stops after carrying out at most <code>maxItNum</code> iterates; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needSol</td><td>if set to <code>true</code> and if solution has been found, on termination basic matrix is re-factored to eliminate computational errors; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inconsistSertificate</td><td>if set to <code>true</code>, on termination, even if problem has been proven to be infeasible, basic matrix is re-factored to eliminate computational errors; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degCheckInterval,maxDegPrc</td><td>degeneracy test is activated after <code>degCheckInterval</code> consecutive iterations; if more than <code>maxDdegPrc</code>% iterations among the last <code>degCheckInterval</code> ones were degenerated, objective is perturbed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code> solution found;</li>
<li><code>1</code> inconsistency detected;</li>
<li><code>2</code> limit on number of iterates, <code>maxItNum</code>, exceeded;</li>
<li><code>3</code> objective function is less than <code>lowerBound</code>;</li>
<li><code>4</code> time limit, <code>timeLimit</code>, exceeded. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a>. </dd></dl>

</div>
</div>
<a id="ad894bdbde67dd19464df9e48ebd2c7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad894bdbde67dd19464df9e48ebd2c7bb">&#9670;&nbsp;</a></span>dublicateRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::dublicateRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds to the matrix another copy of row <code>row</code>. </p>
<p>The function may be useful for adding to the matrix several very similar constraints. </p>

</div>
</div>
<a id="a33872ba1f311ba9cd26d9e8cc0a938d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33872ba1f311ba9cd26d9e8cc0a938d0">&#9670;&nbsp;</a></span>estimateCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::estimateCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is helpful in branch-and-price algorithms when pricing columns that are not in the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>number of non-zero coefficients in column; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipRow</td><td>arrays of size <code>sz</code>; <code>dpVal[i]</code> is coefficient in row <code>ipRow[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <code>c</code> is the cost coefficient of corresponding variable and <code>q</code> denotes return value, then <code>c-q</code> is reduced cost of that variable. </dd></dl>

</div>
</div>
<a id="a6433f319b666c6c42389875c232f920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6433f319b666c6c42389875c232f920e">&#9670;&nbsp;</a></span>extendCtrType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CLP::extendCtrType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The functions extends the type of constraint <code>i</code> by bitwise ORing its current type with the flags stored in the parameter<code>type</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of constraint; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is bitwise OR of members of <code>enCtrType</code> and <code><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa" title="MIP types of constraints.">CMIP::enCtrType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5" title="LP types of constraints.">enCtrType</a>, <a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa" title="MIP types of constraints.">CMIP::enCtrType</a>. </dd></dl>

</div>
</div>
<a id="ae90bf133c46fe102d2b10805f8bfdec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90bf133c46fe102d2b10805f8bfdec3">&#9670;&nbsp;</a></span>extendVarType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CLP::extendVarType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The functions extends the type of variable <code>j</code> by bitwise ORing its current type with the flags stored in the parameter <code>type</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is bitwise OR of members of <code>enVarType</code> and <code><a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92" title="MIP types of variables.">CMIP::enVarType</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627" title="LP types of variables.">enVarType</a>, <a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92" title="MIP types of variables.">CMIP::enVarType</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#affc325e5a1dd43d1a87cebc5857a0a70">CMIP</a>.</p>

</div>
</div>
<a id="a75b5306fe2f902f31ce3d368aa1ba14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b5306fe2f902f31ce3d368aa1ba14f">&#9670;&nbsp;</a></span>GCD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::GCD </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,b</td><td>two integers (although written as double reals). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global common divisor of input integers. </dd></dl>

</div>
</div>
<a id="a7a22364cac6b727f5b4e8416b753e3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a22364cac6b727f5b4e8416b753e3cc">&#9670;&nbsp;</a></span>generateColumns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::generateColumns </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipRowHd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function must be overloaded in user applications generating columns. The functions is to produce a number of columns (presently not in the matrix) with negative reduced costs defined to be the cost of the column minus the value returned by <code>estimateColumn()</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in matrix; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipRowHd,dpY</td><td>arrays of size <code>m</code>; <code>dpY[i]</code> is shadow price (value of dual variable) of constraint (row) having handle <code>ipRowHd</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one column was generated; otherwise, <code>false</code>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The procedure must add columns to the matrix by calling <code><a class="el" href="classCLP.html#ad040a1690b496a9f62cf0908b953360a">addNewColumn()</a></code> with parameter <code>flag</code> set to <code>false</code>. </dd></dl>

</div>
</div>
<a id="a75754fed56e5caa1755a72a8adab225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75754fed56e5caa1755a72a8adab225e">&#9670;&nbsp;</a></span>getColumn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bScaled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>column index; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpVal,ipRow</td><td>arrays of size <code>k</code>, where <code>k</code> is return value; <code>dpVal[i]</code> is the coefficient in row <code>ipRow[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bScaled</td><td>if <code>true</code>, column of scaled matrix is returned; otherwise, column of non-scaled matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of non-zero coefficients in column <code>col</code>. </dd></dl>

</div>
</div>
<a id="a5ff2fde24973288a44a64fa017337364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff2fde24973288a44a64fa017337364">&#9670;&nbsp;</a></span>getColumn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::getColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipHd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that generates columns and stores them in its own pool. If a new column is added to the matrix with a positive handle, later, the solver may call <code><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn()</a></code> to reload this column to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of column to be returned; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in matrix; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipHd</td><td>array of size <code>n</code>; <code>ipHd[i]</code> is handle of row <code>i</code>; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>type of corresponding variable; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost</td><td>objective coefficient; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l,u</td><td>lower and upper bounds of corresponding variable; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sz</td><td>number of non-zero coefficients in column; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpVal,ipRow</td><td>arrays of size <code>sz</code>; <code>dpVal[i]</code> is coefficient in row <code>ipRow[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if column with handle <code>hd</code> was successfully restored; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ad040a1690b496a9f62cf0908b953360a">addNewColumn()</a>. </dd></dl>

</div>
</div>
<a id="a747e320a943d314b9407a03f45e6711a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747e320a943d314b9407a03f45e6711a">&#9670;&nbsp;</a></span>getColumnSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getColumnSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of non-zero entries in column <code>j</code>. </dd></dl>

</div>
</div>
<a id="a4b035339093737c069e2f6e58ffab494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b035339093737c069e2f6e58ffab494">&#9670;&nbsp;</a></span>getCtrHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> CLP::getCtrHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>handle of constraint indexed by <code>i</code>. </dd></dl>

</div>
</div>
<a id="a6c3298cc487c5408a38b6f55262d7ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3298cc487c5408a38b6f55262d7ad6">&#9670;&nbsp;</a></span>getCtrLeftSlack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getCtrLeftSlack </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaled</td><td>if <code>true</code>, slack for scaled matrix is returned; otherwise, for not-scaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slack value of left part of constraint <code>i</code> for basic solution currently stored in memory. </dd></dl>

</div>
</div>
<a id="a564de7d70495c8124d685908c64a05b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564de7d70495c8124d685908c64a05b4">&#9670;&nbsp;</a></span>getCtrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * CLP::getCtrName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload this function to allow <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> to use symbolic constraint names when storing solutions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>constraint (row) handle; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>memory to store returned name; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <code>name</code> parameter. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Default implementation composes the names as the concatenation of string "ctr_" with the value of <code>hd</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a24a9d61baa772136537322854f15b6ed">getVarName()</a>. </dd></dl>

</div>
</div>
<a id="af4080308e4f21d6f55514ac92fc3fb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4080308e4f21d6f55514ac92fc3fb1f">&#9670;&nbsp;</a></span>getCtrNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getCtrNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of constraints. </dd></dl>

</div>
</div>
<a id="a5a9136db891a9e87dc6e2e2726feb0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9136db891a9e87dc6e2e2726feb0ab">&#9670;&nbsp;</a></span>getCtrRightSlack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getCtrRightSlack </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaled</td><td>if <code>true</code>, slack for scaled matrix is returned; otherwise, for not-scaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slack value of right part of constraint <code>i</code> for basic solution currently stored in memory. </dd></dl>

</div>
</div>
<a id="aaeddcd066d467d08fb8328f7ccae88f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeddcd066d467d08fb8328f7ccae88f8">&#9670;&nbsp;</a></span>getCtrTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getCtrTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum violation allowed for regular constraints (not cuts). </dd></dl>

</div>
</div>
<a id="a19188e63c2b129617b4397812cf7b811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19188e63c2b129617b4397812cf7b811">&#9670;&nbsp;</a></span>getCurrentLPmethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a> CLP::getCurrentLPmethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used LP algorithm. </dd></dl>

</div>
</div>
<a id="a811a70fe6c1839a2378815f19468cc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811a70fe6c1839a2378815f19468cc08">&#9670;&nbsp;</a></span>getDegItNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getDegItNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of degenerate iterates performed by <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> or <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code>. </dd></dl>

</div>
</div>
<a id="aa0af3765cf29ebec0e93462b47958408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0af3765cf29ebec0e93462b47958408">&#9670;&nbsp;</a></span>getDualDegTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getDualDegTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>degeneracy tolerance values for dual simplex algorithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aa6eb4ddddfc54fd90df48a07e89c555b">setDegenTol()</a>. </dd></dl>

</div>
</div>
<a id="a87c0e85fa6ec0116b6b3c1ed7563071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c0e85fa6ec0116b6b3c1ed7563071a">&#9670;&nbsp;</a></span>getDualRowVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::getDualRowVars </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bScaled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is used when working with preprocessed matrix; otherwise, <code><a class="el" href="classCLP.html#ae45de9d5f0eea44f06a733026b9a99fd">getShadowPrices()</a></code> should be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>vector of potentials; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>array of size <code>m_iM</code>, <code>y[i]</code> dual variable for constraint <code>i</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bScaled</td><td>if <code>true</code>, output <code>y</code> is computed for scaled problem; otherwise, for not-scaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ae45de9d5f0eea44f06a733026b9a99fd">getShadowPrices()</a>. </dd></dl>

</div>
</div>
<a id="a1e52370b1b816c402867dd27aeb0c64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e52370b1b816c402867dd27aeb0c64f">&#9670;&nbsp;</a></span>getGoodPiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getGoodPiv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>minimum absolute value of pivots that are considered as "good". </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol()</a>. </dd></dl>

</div>
</div>
<a id="ac8380195e69c672761c60a954e028f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8380195e69c672761c60a954e028f89">&#9670;&nbsp;</a></span>getLastLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double CLP::getLastLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>-INF</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>CMIP::getLastLowerBound(). </dd></dl>

</div>
</div>
<a id="a61adc020de168f43627a0d1e3e1a78dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61adc020de168f43627a0d1e3e1a78dd">&#9670;&nbsp;</a></span>getLHS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getLHS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>left hand side of constraint <code>i</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#acc4295d11a43be2e37beb19366b97c16">getRHS()</a>. </dd></dl>

</div>
</div>
<a id="a1cad4021fc1fb67c4dd0290b51f099d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cad4021fc1fb67c4dd0290b51f099d6">&#9670;&nbsp;</a></span>getLPItNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getLPItNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of iterates performed by <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> or <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code>. </dd></dl>

</div>
</div>
<a id="af368038ca0f767d2aa0deee9e68e070a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af368038ca0f767d2aa0deee9e68e070a">&#9670;&nbsp;</a></span>getNonZerosNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getNonZerosNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of nonzero entries in the matrix. </dd></dl>

</div>
</div>
<a id="ab5be852e69e8ce4f885d59825b425214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5be852e69e8ce4f885d59825b425214">&#9670;&nbsp;</a></span>getNotScaledObjVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getNotScaledObjVal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Usually, the function is used in MIP applications. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>objective value of some solution in scaled variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>objective value of that solution in original (not-scaled) variables.. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a3b924d5bbf633e2f350e5051aa4a8d2b">getScaledObjVal()</a>. </dd></dl>

</div>
</div>
<a id="a1b76fdfaaea16e1d251688a596e4ad01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b76fdfaaea16e1d251688a596e4ad01">&#9670;&nbsp;</a></span>getObjCoeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getObjCoeff </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of a variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cost of variable <code>j</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aeb97ed82d53f698715069ce966a1dd0e">setObjCoeff()</a>. </dd></dl>

</div>
</div>
<a id="a75327ce571f101fe443033506f7423d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75327ce571f101fe443033506f7423d2">&#9670;&nbsp;</a></span>getObjSense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::getObjSense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the goal is to <em>maximize</em> the objective function, or <code>false</code> if the goal is to _minimize__ the objective. </dd></dl>

</div>
</div>
<a id="a7b51623f53e3da259dfac58d65d0d3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b51623f53e3da259dfac58d65d0d3dd">&#9670;&nbsp;</a></span>getObjVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getObjVal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is usually called when the problem has been solved already. </p><dl class="section return"><dt>Returns</dt><dd>optimal objective value of solved LP. </dd></dl>

</div>
</div>
<a id="ad291b60e0912a053f08bd0981244502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad291b60e0912a053f08bd0981244502d">&#9670;&nbsp;</a></span>getPartitionNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getPartitionNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used privately in <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a>. </p><dl class="section return"><dt>Returns</dt><dd>the number of times the basic matrix has been refactored during last call to <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> or <code>dualSimplexthis()</code>. </dd></dl>

</div>
</div>
<a id="a60f1b1273fc526e772a8bc17f7df93e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f1b1273fc526e772a8bc17f7df93e5">&#9670;&nbsp;</a></span>getPivErrTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getPivErrTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>tolerance for relative pivot errors. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol()</a>. </dd></dl>

</div>
</div>
<a id="ac816fe1f356205b0fef57c3cdb500ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac816fe1f356205b0fef57c3cdb500ca0">&#9670;&nbsp;</a></span>getPivTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getPivTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>minimum absolute value of pivots. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol()</a>. </dd></dl>

</div>
</div>
<a id="a885168355b7d81cfa3cb7872ec5ec0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885168355b7d81cfa3cb7872ec5ec0a4">&#9670;&nbsp;</a></span>getPricingRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a> CLP::getPricingRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used pricing rule. </dd></dl>

</div>
</div>
<a id="ae39a48a82310b64fbfd5db845cf6fe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39a48a82310b64fbfd5db845cf6fe11">&#9670;&nbsp;</a></span>getPrimeDegTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getPrimeDegTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>degeneracy tolerance values for prime simplex algorithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aa6eb4ddddfc54fd90df48a07e89c555b">setDegenTol()</a>. </dd></dl>

</div>
</div>
<a id="aff4da1233ad71119bd3b1aabb79d0073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4da1233ad71119bd3b1aabb79d0073">&#9670;&nbsp;</a></span>getPrimeSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getPrimeSolution </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpBasicX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function transforms a non-scaled basic solution for the LP in the memory into a solution of the original LP or MIP. To do its job, the function uses expressions in the preprocessing stack to recover the values of those variables that were eliminated from the matrix during preprocessing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dpBasicX</td><td>basic solution; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpX</td><td>array of size <code>m_iN</code> that sores extended solution; <code>dpX[i]</code> is value of variable with handle <code>m_ipColHd[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7ca5b92a36189f315f43067727cf510a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca5b92a36189f315f43067727cf510a">&#9670;&nbsp;</a></span>getProblemName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::getProblemName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>problem name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>allocate for <code>name</code> at least 32 bytes. </dd></dl>

</div>
</div>
<a id="a5f5efb7a119d591a4c575ee0b464f8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5efb7a119d591a4c575ee0b464f8bd">&#9670;&nbsp;</a></span>getProbStatStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * CLP::getProbStatStr </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is to compose a string describing the problem being solved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>memory for output string; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to output string. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>str=0</code> when calling <code><a class="el" href="classCLP.html#a5f5efb7a119d591a4c575ee0b464f8bd">getProbStatStr()</a></code>, on return <code>str</code> points to an internal <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> array. </dd></dl>

</div>
</div>
<a id="a14a0519468aae3f041641948cf59aea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a0519468aae3f041641948cf59aea2">&#9670;&nbsp;</a></span>getRedCostTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getRedCostTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used value for reduced cost tolerance. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ad7feb77a91a7839b570a69e712da2a83">setRedCostTol()</a>. </dd></dl>

</div>
</div>
<a id="a90a68321fefd80cacbb77c3076703cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a68321fefd80cacbb77c3076703cc6">&#9670;&nbsp;</a></span>getReducedCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getReducedCosts </td>
          <td>(</td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function returns <em>reduced costs</em> of variables for the solved LP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpC,ipHd</td><td>- arrays of size <code>n</code>, where <code>n</code> denotes return value; <code>dpC[i]</code> is reduced cost of variable with handle <code>ipHd[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of variables. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code><a class="el" href="classCLP.html#a90a68321fefd80cacbb77c3076703cc6">getReducedCosts()</a></code> is called with <code>dpC</code> and/or <code>ipHd</code> set to zero, on return <code>dpC</code> and/or <code>ipHd</code> are pointers to internal <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> arrays.</dd></dl>
<p>dpRV and ipHd - arrays of size <code>m</code>, where <code>m</code> is return value; <code>dpRV[i]</code> is row value of constraint with handle <code>ipHd[i]</code>. </p><dl class="section return"><dt>Returns</dt><dd>number of constraints. </dd></dl>

</div>
</div>
<a id="af24f7fcadce90f9e2f0200641e389839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24f7fcadce90f9e2f0200641e389839">&#9670;&nbsp;</a></span>getRelPivErrTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getRelPivErrTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>tolerance for pivot errors. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol()</a>. </dd></dl>

</div>
</div>
<a id="a1fd3feb9f48d6a206cef0e7c74dceebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd3feb9f48d6a206cef0e7c74dceebe">&#9670;&nbsp;</a></span>getRelPivTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getRelPivTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>minimum relative pivot value in pivot row and column. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a378a97cf0e8477e6f81c2ea40b760897">setPivTol()</a>. </dd></dl>

</div>
</div>
<a id="acc4295d11a43be2e37beb19366b97c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4295d11a43be2e37beb19366b97c16">&#9670;&nbsp;</a></span>getRHS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getRHS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>right hand side of constraint <code>i</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a61adc020de168f43627a0d1e3e1a78dd">getLHS()</a>. </dd></dl>

</div>
</div>
<a id="a16ed51f6357c2a1a7a9e3cd434296a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ed51f6357c2a1a7a9e3cd434296a41">&#9670;&nbsp;</a></span>getRow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bScaled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>row index; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>k</code>, where <code>k</code> is return value; <code>dpVal[i]</code> is coefficient in column <code>ipCol[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bScaled</td><td>if <code>true</code>, row of scaled matrix is returned; otherwise, row of non-scaled matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of non-zero coefficients in row <code>row</code>. </dd></dl>

</div>
</div>
<a id="a6dc545048ac0bee2405278c5394f5a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc545048ac0bee2405278c5394f5a72">&#9670;&nbsp;</a></span>getRow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::getRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipHd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>scaled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be overloaded in any derived class that generates rows (cuts) and stores them in its own pool. If a new inequality is added to the matrix with a positive handle, later, the solver may call <code><a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow()</a></code> to reload this inequality to the matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of constraint (row) to be returned; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns in matrix; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipHd</td><td>array of size <code>n</code>; <code>ipHd[j]</code> is handle of column <code>j</code>; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>type of constraint; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lhs,rhs</td><td>LHS and RHS; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sz</td><td>number of variables in constraint; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>sz</code>; <code>dpVal[i]</code> is coefficient in column <code>ipCol[i]</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scaled</td><td>if <code>true</code> the constraint (row) is returned in scaled variables; otherwise, <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constraint with handle <code>hd</code> was successfully restored; otherwise, <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a40b16107bf05adff72406dbb0869d682">addNewRow()</a>. </dd></dl>

</div>
</div>
<a id="a63b1aab13d38650f5c441d2fa986c550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b1aab13d38650f5c441d2fa986c550">&#9670;&nbsp;</a></span>getRowSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getRowSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of non-zero entries in row <code>i</code>. </dd></dl>

</div>
</div>
<a id="ab857670786cb53f3ea8479db7cc3a154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab857670786cb53f3ea8479db7cc3a154">&#9670;&nbsp;</a></span>getRowValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getRowValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of row <code>i</code>. </dd></dl>

</div>
</div>
<a id="a58670ea03d928f8310d1974409daba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58670ea03d928f8310d1974409daba4a">&#9670;&nbsp;</a></span>getRowValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getRowValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpX</td><td>array of size <code>m_iN</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scalar product of the constraint vector of row <code>i</code> and the vector stored in <code>dpX</code>. </dd></dl>

</div>
</div>
<a id="a3b924d5bbf633e2f350e5051aa4a8d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b924d5bbf633e2f350e5051aa4a8d2b">&#9670;&nbsp;</a></span>getScaledObjVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getScaledObjVal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Usually, the function is used in MIP applications. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>objective value of some solution in original (not-scaled) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>objective value of that solution in scaled variables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ab5be852e69e8ce4f885d59825b425214">getNotScaledObjVal()</a>. </dd></dl>

</div>
</div>
<a id="acec30b96087c0a237e468907de24c75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec30b96087c0a237e468907de24c75e">&#9670;&nbsp;</a></span>getSepRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a> CLP::getSepRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used <em>separation rule</em>. </dd></dl>

</div>
</div>
<a id="ae45de9d5f0eea44f06a733026b9a99fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45de9d5f0eea44f06a733026b9a99fd">&#9670;&nbsp;</a></span>getShadowPrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getShadowPrices </td>
          <td>(</td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function returns constraint <em>shadow prices</em> (optimal values of dual variables). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpP,ipHd</td><td>arrays of size <code>m</code>, where <code>m</code> is return value; <code>dpP[i]</code> is shadow price of constraint with handle `ipHd[i]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of constraints. </dd></dl>

</div>
</div>
<a id="a9ccd228f5834359466cff18b0f6f05f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccd228f5834359466cff18b0f6f05f0">&#9670;&nbsp;</a></span>getShadowPriceTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getShadowPriceTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used value for shadow price tolerance. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ac888a61e64a5f4a3a52bbfd2cbc3cac3">setShadowPriceTol()</a>. </dd></dl>

</div>
</div>
<a id="a96c239f18033b08ccc18a711d953765b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c239f18033b08ccc18a711d953765b">&#9670;&nbsp;</a></span>getSolTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> CLP::getSolTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>solution time (in seconds). </dd></dl>

</div>
</div>
<a id="a1636d6070c91135f68892056e59b33b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1636d6070c91135f68892056e59b33b4">&#9670;&nbsp;</a></span>getSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getSolution </td>
          <td>(</td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function returns two pointers to the internal MIPCL arrays storing the LP solution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpX,ipHd</td><td><code>dpX[j]</code> is value of variable whose handle is <code>ipHd[j]</code>, <code>j=1,...,n</code>, where <code>n</code> is return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of variables. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Do not modify the values of both arrays <code>dpX</code> and <code>ipHd</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a536ace1560abb8de5c9b7941720df9b4">CMIP::getSolution()</a>. </dd></dl>

</div>
</div>
<a id="ae15b567a7fcdf060320225b107e5a7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15b567a7fcdf060320225b107e5a7c2">&#9670;&nbsp;</a></span>getStartTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> CLP::getStartTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>start time (given in seconds since epoch). </dd></dl>

</div>
</div>
<a id="a7e990d15247758a448cedb3391c42013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e990d15247758a448cedb3391c42013">&#9670;&nbsp;</a></span>getThisCtrTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double CLP::getThisCtrTol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>tolerance value for a given constraint; for LPs, this is always <code>m_dCtrTol</code>. </dd></dl>

</div>
</div>
<a id="abf707db6eafaf6fe2248dda596475c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf707db6eafaf6fe2248dda596475c61">&#9670;&nbsp;</a></span>getVarHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> CLP::getVarHandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>handle of variable indexed by <code>j</code>. </dd></dl>

</div>
</div>
<a id="a3bfd0f57b4fea770d264857d149c2c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfd0f57b4fea770d264857d149c2c51">&#9670;&nbsp;</a></span>getVarInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getVarInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used value of "infinity" for variables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ad58522cc43d5bc30264c9fed54e3f8a4">setVarInf()</a>. </dd></dl>

</div>
</div>
<a id="a07712842e5a79726863b4a08f3e1410a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07712842e5a79726863b4a08f3e1410a">&#9670;&nbsp;</a></span>getVarLoBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getVarLoBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of a variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lower bound of variable <code>j</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a68264a2571e3f720bddb4afb2be3e8a5">getVarUpBound()</a>. </dd></dl>

</div>
</div>
<a id="a24a9d61baa772136537322854f15b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a9d61baa772136537322854f15b6ed">&#9670;&nbsp;</a></span>getVarName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * CLP::getVarName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload this function to allow <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> to use symbolic names of variables when storing solutions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd</td><td>handle of variable (column); </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>memory to store returned name; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <code>name</code> parameter. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Default implementation represents the name as the string "x(q)", where <code>q</code> is the value of <code>hd</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a564de7d70495c8124d685908c64a05b4">getCtrName()</a>. </dd></dl>

</div>
</div>
<a id="ad7842343e7840db5a2284c66428a4b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7842343e7840db5a2284c66428a4b70">&#9670;&nbsp;</a></span>getVarNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::getVarNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of variables. </dd></dl>

</div>
</div>
<a id="ac08c3dd8c2a520eab4122a2789609810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08c3dd8c2a520eab4122a2789609810">&#9670;&nbsp;</a></span>getVarTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getVarTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum violation allowed for bounds on variables. </dd></dl>

</div>
</div>
<a id="a68264a2571e3f720bddb4afb2be3e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68264a2571e3f720bddb4afb2be3e8a5">&#9670;&nbsp;</a></span>getVarUpBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getVarUpBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of a variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper bound of variable <code>j</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a07712842e5a79726863b4a08f3e1410a">getVarLoBound()</a>. </dd></dl>

</div>
</div>
<a id="a6d0562bb322f77d142d666ed8152b7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0562bb322f77d142d666ed8152b7f1">&#9670;&nbsp;</a></span>getVarValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getVarValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of variable <code>j</code>. </dd></dl>

</div>
</div>
<a id="a529998af95e064af12df5e28790958b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529998af95e064af12df5e28790958b5">&#9670;&nbsp;</a></span>getVarViolatThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getVarViolatThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a bound for a variable is violated by more than a given value, called variable violation threshold, the separation procedure will not verify any non-trivial inequalities. </p><dl class="section return"><dt>Returns</dt><dd>variable violation threshold. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#af9e92e08af8ffe926643a4bf18b8c4c9">setVarViolatThreshold()</a>. </dd></dl>

</div>
</div>
<a id="a4993a49b26e7fcda789a74d055b2d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993a49b26e7fcda789a74d055b2d9d7">&#9670;&nbsp;</a></span>getZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CLP::getZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used value of "zero". </dd></dl>

</div>
</div>
<a id="abbdf654da45516869b3d507ed7a03be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdf654da45516869b3d507ed7a03be7">&#9670;&nbsp;</a></span>incColumnSum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::incColumnSum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function adds a given matrix column, <code>col</code>, multiplied by <code>delta</code> to the sum of basic columns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>column index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>multiplier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ecd97c12ae3986296c8d581c41f5848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecd97c12ae3986296c8d581c41f5848">&#9670;&nbsp;</a></span>incMaxColumnNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::incMaxColumnNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is called when the number of columns (variables) exceeds <code>m_iNmax</code>. </p><dl class="section attention"><dt>Attention</dt><dd><code><a class="el" href="classCLP.html#a5ecd97c12ae3986296c8d581c41f5848">incMaxColumnNumber()</a></code> should not be called in user applications. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is overloaded in <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> to make it thread safe. </dd></dl>

</div>
</div>
<a id="ac2c4c39286e5c005fc8474d27ac631bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4c39286e5c005fc8474d27ac631bc">&#9670;&nbsp;</a></span>incMaxRowNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::incMaxRowNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is called when the number of rows (constraints) exceeds <code>m_iMmax</code>. </p><dl class="section attention"><dt>Attention</dt><dd><code><a class="el" href="classCLP.html#ac2c4c39286e5c005fc8474d27ac631bc">incMaxRowNumber()</a></code> should not be called in user applications. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is overloaded in <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> to make it thread safe. </dd></dl>

</div>
</div>
<a id="a3aee610537e542da711336710937131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aee610537e542da711336710937131e">&#9670;&nbsp;</a></span>infoMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::infoMessage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function prints messages to the standard output stream. This function should be overloaded in applications with graphic user interfaces (GUI). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>message string; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>if set to 1) 0 - info message; 2) 1 - warning message; 3) 2 - error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Warning and error messages are also printed to LOG stream. </dd></dl>

</div>
</div>
<a id="adb64ae5e18034796c87fd473f889a5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb64ae5e18034796c87fd473f889a5fd">&#9670;&nbsp;</a></span>isCLP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isCLP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this function is called from an object of type <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>, and <code>false</code> if it is called from an object of type <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </dd></dl>

</div>
</div>
<a id="ad90e7c2012c4b3bc852a7a2c19e5863a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90e7c2012c4b3bc852a7a2c19e5863a">&#9670;&nbsp;</a></span>isColGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isColGen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if columns can be generated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>enRowGenRule</code>. </dd></dl>

</div>
</div>
<a id="aa6d2f383c7cc7adc1f0b9aec343fd7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d2f383c7cc7adc1f0b9aec343fd7d5">&#9670;&nbsp;</a></span>isCtrBounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isCtrBounded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a constraint is two side bounded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of constraint; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constrain <code>i</code> is <em>bounded</em> (its left and right hand are finite), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a4b2d9a525711f3ea84041d576e81a2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2d9a525711f3ea84041d576e81a2ae">&#9670;&nbsp;</a></span>isCtrEq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isCtrEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a constraint is an equality constraint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of constraint; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constrain <code>i</code> is <em>equality</em> (its left and right hand are equal), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="adf2c0fafb334e3f569d3e425ad66b431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2c0fafb334e3f569d3e425ad66b431">&#9670;&nbsp;</a></span>isCtrFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isCtrFree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a constraint is <em>free</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of constraint; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constrain <code>i</code> is <em>free</em>, otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a58999f5b5a8426cdb355c2a7432f658a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58999f5b5a8426cdb355c2a7432f658a">&#9670;&nbsp;</a></span>isCtrLoBounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isCtrLoBounded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a constraint is lower bounded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of constraint; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constrain <code>i</code> is <em>lower bounded</em> (its left hand is finite), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a7d731369346a8563306d9f370d1f11db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d731369346a8563306d9f370d1f11db">&#9670;&nbsp;</a></span>isCtrModifyable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isCtrModifyable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To be overloaded in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><dl class="section see"><dt>See also</dt><dd>CMIP::isVarModifyable(). </dd></dl>

</div>
</div>
<a id="a883a6c79534131e46e17853f4b7d4ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883a6c79534131e46e17853f4b7d4ee8">&#9670;&nbsp;</a></span>isCtrUpBounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isCtrUpBounded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a constraint is upper bounded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of constraint; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if constrain <code>i</code> is <em>upper bounded</em> (its right hand is finite), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a50da983157733dd19de4d91dfec2aabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50da983157733dd19de4d91dfec2aabf">&#9670;&nbsp;</a></span>isInfeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isInfeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this LP or MIP is infeasible (has no solution). </dd></dl>

</div>
</div>
<a id="a497f4551e040248b83ced4d34c0ab017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497f4551e040248b83ced4d34c0ab017">&#9670;&nbsp;</a></span>isLpInfeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isLpInfeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LP in memory has been solved and proven to be <em>infeasible</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a>, <a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible()</a>. </dd></dl>

</div>
</div>
<a id="a297ec9a7bc4bd6a249a0c73de69f1b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297ec9a7bc4bd6a249a0c73de69f1b17">&#9670;&nbsp;</a></span>isLpUnbounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isLpUnbounded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LP in memory has been solved and proven to be <em>unbounded</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a7d11405730a32a3917518bd97f06d6ae">whyLpUnbounded()</a>, <a class="el" href="classCLP.html#a6d5f5d38fd9d40af6e38eba360bc48e2">showWhyLpUnbounded()</a>. </dd></dl>

</div>
</div>
<a id="af3b6916019aae383786af2635687f359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b6916019aae383786af2635687f359">&#9670;&nbsp;</a></span>isPrepared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isPrepared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LP (MIP) in memory has been prepared for optimization. </dd></dl>

</div>
</div>
<a id="a5042f6464f736fffb5321693464b8339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5042f6464f736fffb5321693464b8339">&#9670;&nbsp;</a></span>isPureLP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isPureLP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the problem is an LP, otherwise, <code>false</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Default implementation always returns <code>true</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a5825362f7121939d1dd3060e50198706">CMIP</a>.</p>

</div>
</div>
<a id="a28f623b653c23c1585978f1cbbccab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f623b653c23c1585978f1cbbccab34">&#9670;&nbsp;</a></span>isRowGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isRowGen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if rows can be generated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>enRowGenRule</code>. </dd></dl>

</div>
</div>
<a id="ae1e6dfc38f4087fb3e106663c8da2639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e6dfc38f4087fb3e106663c8da2639">&#9670;&nbsp;</a></span>isSilent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isSilent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if silent mode has been set. </dd></dl>

</div>
</div>
<a id="a8af1978cf8a498333938e780412f33e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af1978cf8a498333938e780412f33e9">&#9670;&nbsp;</a></span>isSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LP in memory has been solved and optimal solution found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a79a188db14fbd2a57e18729cd7376a89">CMIP::isSolution()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a79a188db14fbd2a57e18729cd7376a89">CMIP</a>.</p>

</div>
</div>
<a id="a277afd563c5fd0849a6480a80f486fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277afd563c5fd0849a6480a80f486fee">&#9670;&nbsp;</a></span>isSolved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isSolved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LP (or MIP) in memory has been solved. </dd></dl>

</div>
</div>
<a id="a72a42d3bb1f3cd41bf5454106080139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a42d3bb1f3cd41bf5454106080139d">&#9670;&nbsp;</a></span>isVarBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarBinary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> is highly integrated with <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>, it is useful to keep this function in <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> even if it is not used when solving LPs. </p><pre class="fragment">\param[in] j variable index.
\return `true` if variable `j` is binary.
</pre> 
</div>
</div>
<a id="ad8a9d2aaa65e01f1f08113fcae7b8a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a9d2aaa65e01f1f08113fcae7b8a8c">&#9670;&nbsp;</a></span>isVarBounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarBounded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is <em>bounded</em> (both its bounds, lower and upper, are finite), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a3cf2304fcf592f3684a293514a4e0e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf2304fcf592f3684a293514a4e0e11">&#9670;&nbsp;</a></span>isVarDeletable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isVarDeletable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To be overloaded in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><dl class="section see"><dt>See also</dt><dd>CMIP::isVarDeletable(). </dd></dl>

</div>
</div>
<a id="aa885958373244ebe82c17796bf17dd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa885958373244ebe82c17796bf17dd29">&#9670;&nbsp;</a></span>isVarFixed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarFixed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is <em>fixed</em> (its lower and upper bounds are equal), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a8e92ccb47a2381fdc335faec89bfc84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e92ccb47a2381fdc335faec89bfc84d">&#9670;&nbsp;</a></span>isVarFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarFree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is <em>free</em>, otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a5a388179951a58ff108cb9aeffc48aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a388179951a58ff108cb9aeffc48aba">&#9670;&nbsp;</a></span>isVarIntegral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarIntegral </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is integer-valued. </dd></dl>

</div>
</div>
<a id="a3e297bc60583f0a97604e536364ff803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e297bc60583f0a97604e536364ff803">&#9670;&nbsp;</a></span>isVarLoBounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarLoBounded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a variable is lower bounded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is <em>lower bounded</em> (its lower bound is finite), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae0e84d3f6fbde33cc62795e5176f2eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e84d3f6fbde33cc62795e5176f2eb3">&#9670;&nbsp;</a></span>isVarScalable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isVarScalable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To be overloaded in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ab1ecb21cc14bdb8cdeb068c13fde435d">CMIP::isVarScalable()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#ab1ecb21cc14bdb8cdeb068c13fde435d">CMIP</a>.</p>

</div>
</div>
<a id="af5d0a21407f597a92d9f5924cef1714c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d0a21407f597a92d9f5924cef1714c">&#9670;&nbsp;</a></span>isVarStrongIntegral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isVarStrongIntegral </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To be overloaded in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ae06691ddef275b820b98471b8d8e3e19">CMIP::isVarStrongIntegral()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#ae06691ddef275b820b98471b8d8e3e19">CMIP</a>.</p>

</div>
</div>
<a id="a9166442b72ec9b457b643150e198cafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9166442b72ec9b457b643150e198cafa">&#9670;&nbsp;</a></span>isVarUpBounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::isVarUpBounded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to verify whether a variable is upper bounded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of variable; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is <em>upper bounded</em> (its upper bound is finite), otherwise, <code>false</code>. </dd></dl>

</div>
</div>
<a id="a0ce3965a0ec3cd2275ce18a2045f594f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce3965a0ec3cd2275ce18a2045f594f">&#9670;&nbsp;</a></span>isVarUsedForBranching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::isVarUsedForBranching </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>variable index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if variable <code>j</code> is can be used for branching on it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a89565cfb1b01944400728feca3c7d982">CMIP::isVarUsedForBranching()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a89565cfb1b01944400728feca3c7d982">CMIP</a>.</p>

</div>
</div>
<a id="a633f873f131cfe55c8e9df25eca7b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f873f131cfe55c8e9df25eca7b43b">&#9670;&nbsp;</a></span>lpInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::lpInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degItNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function prints into the standard output stream a message string which describes the current state of the solution process when running <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> or <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code>. When developing an application with a GUI interface, the user may wish to overload this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>string describing simplex method that is currently running; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>string representation of time elapsed since application start; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itNum</td><td>number of simplex-iterates; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degItNum</td><td>number of degenerate simplex-iterates; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objVal</td><td>current objective value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9704ad0e87c595e671ed0d45e72eaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9704ad0e87c595e671ed0d45e72eaa0">&#9670;&nbsp;</a></span>lpInfoMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::lpInfoMsg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a> run time messages are to be printed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a6759b414050614829e2e5570e8d03fb6">switchLpInfoMsg()</a> </dd></dl>

</div>
</div>
<a id="aee1fe3f4410af3413f07297d2930c142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1fe3f4410af3413f07297d2930c142">&#9670;&nbsp;</a></span>modInv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a> CLP::modInv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements the extended Euclidean algorithm to compute a <em>modular multiplicative inverse</em> of <code>a</code> modulo <code>m</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a,m</td><td>integers such that <code>GCD(a,m)=1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x in {0,1,...,m-1}</code> such that <code>a*x = 1 (mod m)</code>. </dd></dl>

</div>
</div>
<a id="a2da8fa240b6d69974fb73c0ee942de52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da8fa240b6d69974fb73c0ee942de52">&#9670;&nbsp;</a></span>multiplyCtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::multiplyCtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function multiplies the constraint coefficients by a given factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>multiplier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0040e9c15a3ed866edc35a5b1cd6896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0040e9c15a3ed866edc35a5b1cd6896b">&#9670;&nbsp;</a></span>openLogStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::openLogStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure opens a log file, which name is the value of <code>name</code> appended by <code>_mipcl.log</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>log file name; if <code>name=0</code>, <code>m_strProblemName</code> is used as log file name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd2170c41aaba9fd1dcd4db56ed7a408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2170c41aaba9fd1dcd4db56ed7a408">&#9670;&nbsp;</a></span>openMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::openMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRowGen</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bColGen</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mMax</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMax</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nzMax</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates memory for an LP problem of the required size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>number of non-zeroes in the matrix; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRowGen</td><td><code>true</code> if generation of rows is assumed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bColGen</td><td><code>true</code> if generation of columns is assumed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mMax</td><td>maximum number of rows; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nMax</td><td>maximum number of columns; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nzMax</td><td>maximum number of non-zeroes in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If <code>bRowGen=true</code> and <code>mMax=0</code>, <code><a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">openMatrix()</a></code> will estimate <code>mMax</code>; if <code>bColGen=true</code> and <code>nMax=0</code>, <code><a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">openMatrix()</a></code> will estimate <code>nMax</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a93d43af3654fd597ed45fbebd6ddf6d8">CMIP</a>.</p>

</div>
</div>
<a id="acac38ce07ce257c0a7ee44dfc12e59b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac38ce07ce257c0a7ee44dfc12e59b4">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>timeLimit</em> = <code>1000000l</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>solFileName</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure solves LPs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeLimit</td><td>limit on solution time (in seconds); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>integrality gap; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solFileName</td><td>pointer to string with file name for storing intermediate solutions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When solving LPs, input parameters are not used. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">CMIP::optimize()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">CMIP</a>.</p>

</div>
</div>
<a id="a06cdbbfacf5e68b29ac174c97a392e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cdbbfacf5e68b29ac174c97a392e47">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::prepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This procedure does a lot of useful things: allocates memory, applies different preprocessing techniques, scales the matrix, and so on. As a results, in many cases, we can get substantially simple (for solving) problem, which is still equivalent to the original (user) problem. The latter means that, given an optimal solution to the transformed problem, we can easily compute an optimal solution to the original problem. </p><dl class="section return"><dt>Returns</dt><dd><code>false</code> if inconsistency has been detected; otherwise, <code>true</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a12182abf970a184aeb1dba3658f619c4">CMIP</a>.</p>

</div>
</div>
<a id="af1d3efb7db52940403ab6d32bfe45fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d3efb7db52940403ab6d32bfe45fb6">&#9670;&nbsp;</a></span>preprocess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::preprocess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure reformulate an LP (or MIP) by calling, in turn,</p><ul>
<li><code><a class="el" href="classCLP.html#aca55b1b4117eb73f8c1ef49ba3dec07d">preprocessInit()</a></code>,</li>
<li><code><a class="el" href="classCLP.html#a9aead89f9f0ae4100f6639678a8ff98b">basicPreprocess()</a></code>,</li>
<li><code><a class="el" href="classCLP.html#a00d8a1df14e4e090338de0fa9a95e097">preprocessPlus()</a></code>. <dl class="section return"><dt>Returns</dt><dd><code>false</code> if inconsistency has been detected; otherwise, <code>true</code>. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aca55b1b4117eb73f8c1ef49ba3dec07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca55b1b4117eb73f8c1ef49ba3dec07d">&#9670;&nbsp;</a></span>preprocessInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::preprocessInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just a skeleton. To be overloaded in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Default implementations does nothing. </dd></dl>

</div>
</div>
<a id="a00d8a1df14e4e090338de0fa9a95e097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d8a1df14e4e090338de0fa9a95e097">&#9670;&nbsp;</a></span>preprocessPlus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CLP::preprocessPlus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just a skeleton. To be overloaded in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Default implementations does nothing. </dd></dl>

</div>
</div>
<a id="a7f638d505d663c8782b2935e8410b3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f638d505d663c8782b2935e8410b3be">&#9670;&nbsp;</a></span>preprocOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::preprocOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this function to switch off all preprocessing actions, excluding scaling the matrix. </p>

</div>
</div>
<a id="ac62425ce4381d5cb0fa084815590eeb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62425ce4381d5cb0fa084815590eeb6">&#9670;&nbsp;</a></span>primeSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::primeSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>timeToStop</em> = <code>0l</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperBound</em> = <code><a class="el" href="classCLP.html#acbcd9ecf00ad8658d570dd803b0aabe3">INF</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxItNum</em> = <code>1000000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degCheckInterval</em> = <code>250</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDegPrc</em> = <code>90</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure implements a prime simplex algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeToStop</td><td>procedure will stop at time <code>timeToStop</code> (given in seconds since epoch); <code>timeToStop==0l</code> means no time limitation; if you want <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> to stop running in <code>timeLimit</code> seconds, set <code>timeToStop=<a class="el" href="classCLP.html#ae15b567a7fcdf060320225b107e5a7c2">getStartTime()</a>/1000l + timeLimit</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperBound</td><td>procedure stops if objective value exceeds <code>upperBound</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxItNum</td><td>procedure stops after carrying out at most <code>maxItNum</code> iterations; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">degCheckInterval,maxDegPrc</td><td>degeneracy test is activated after <code>degCheckInt</code> consecutive iterations; if more than <code>maxDegPrc</code>% iterations among the last <code>degCheckInterval</code> ones were degenerated, bounds on variables are perturbed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>0</code> solution found;</li>
<li><code>-1</code> objective function upper bound, <code>upperBound</code>, exceeded;</li>
<li><code>2</code> limit on number of iterates, <code>maxItNum</code>, exceeded;</li>
<li><code>3</code> time limit, <code>timeLimit</code>, exceeded. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a>. </dd></dl>

</div>
</div>
<a id="a0cff57f622722c92212ebc47b54e2441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cff57f622722c92212ebc47b54e2441">&#9670;&nbsp;</a></span>printColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::printColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is useful for debugging. It prints a given column of the matrix to the standard error stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1562920480fa37e7107b59a80a9be3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1562920480fa37e7107b59a80a9be3e">&#9670;&nbsp;</a></span>printCtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::printCtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>side</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is used for debugging. It prints the constraint <code>sum(i=0,..,sz-1) dpVal[i]*x(ipCol[i]) &lt;= (&gt;=) b</code> given given by its argument to the standard error stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of arrays <code>dpVal</code> and <code>ipCol</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal</td><td>array of size <code>sz</code> storing coefficients; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipCol</td><td>array of size <code>sz</code> storing indices of variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>depending on value of <code>side</code>, right-hand-side or left-hand-side of inequality to be printed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>if <code>true</code>, the inequality sign is <code>&lt;=</code>; otherwise, the sign is <code>&gt;=</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dcd371acb757fe0683f639cf1cf7646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcd371acb757fe0683f639cf1cf7646">&#9670;&nbsp;</a></span>printMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::printMatrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is useful for debugging. Prints a the matrix to the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>file name; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaled</td><td>if <code>true</code>, scaled matrix is printed; otherwise, not-scaled; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CFileException.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bf63388547e9d3523c70699094314cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf63388547e9d3523c70699094314cb">&#9670;&nbsp;</a></span>printRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::printRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>varValues</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is useful for debugging. It prints a given row of the matrix to the standard error stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaled</td><td>if <code>true</code>, row of scaled matrix is printed; otherwise, not-scaled; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">varValues</td><td>if <code>true</code>, current values of variables that occur in row are also printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f2b66733b6e5eea018d638c4f9538ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2b66733b6e5eea018d638c4f9538ef">&#9670;&nbsp;</a></span>printSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::printSolution </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function writes LP solutions into the file. The user can overload this function to store solutions in an appropriate way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>name of the file to store solutions; if <code>fileName=</code>0`, the solver makes up the file name by appending the extension ".sol" to the name of the problem being solved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CFileException.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a91249febf036dd979f7584bc0962137a">CMIP</a>.</p>

</div>
</div>
<a id="aa893045084c9180cec0420d0c1b0a6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa893045084c9180cec0420d0c1b0a6ad">&#9670;&nbsp;</a></span>reallocMemForAuxArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::reallocMemForAuxArrays </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rowMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>colMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function reallocates memory for five auxiliary arrays, <code>m_dpArray</code> and <code>m_ipArray</code>, both of size <code>m_iNmax+m_iMmax</code>, <code>dpW</code> of size <code>2*m_iMmax</code>, <code>m_dpFd</code> of size 2*m_iNmax<code>, and</code>m_dpFb<code>of size</code>max{2*m_iMmax,m_iNmax}`. This function is called when either the number of columns exceeds <code>m_iNmax</code>, or the number of rows exceeds <code>m_iMmax</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rowMem</td><td>if <code>true</code>, memory for arrays which size depends on <code>m_iMmax</code> is reallocated; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">colMem</td><td>if <code>true</code>, memory for arrays which size depends on <code>m_iNmax</code> is reallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd><code><a class="el" href="classCLP.html#aa893045084c9180cec0420d0c1b0a6ad">reallocMemForAuxArrays()</a></code> should not be called in user applications. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a343e6b0b673160229a69b80fc8e08f7a">allocMemForAuxArrays()</a>. </dd></dl>

</div>
</div>
<a id="aca1efa53f4deb2fc8bc02f5027af7416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1efa53f4deb2fc8bc02f5027af7416">&#9670;&nbsp;</a></span>reallocMemForEntries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::reallocMemForEntries </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function reallocates memory for the matrix.</p>
<p>If the number of nonzero entries (<code>m_iNZ</code>) approaches its limit (<code>m_iNZmax</code>), this limit is increased 1/3-d of its initial value, and then memory is reallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>maximum number of entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is overloaded in <a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a> to make it thread safe. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The procedure should not be called in user applications. </dd></dl>

</div>
</div>
<a id="af2f6b96b5f6164fda355bfeb10d5ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f6b96b5f6164fda355bfeb10d5ed4a">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function resumes the state in which the problem was before the solution procedure has started. </p>

<p>Reimplemented in <a class="el" href="classCMIP.html#a2c3a97823fbb2c93ac23647f649485b6">CMIP</a>.</p>

</div>
</div>
<a id="ae8da82ce47808a11b30e749fbb568b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8da82ce47808a11b30e749fbb568b37">&#9670;&nbsp;</a></span>restoreBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::restoreBasis </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function restores basis previously stored by <code><a class="el" href="classCLP.html#ab223b0873095d4b64a958e83c79438e4">saveBasis()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>pointer to memory array with stored basis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ab223b0873095d4b64a958e83c79438e4">saveBasis()</a>. </dd></dl>

</div>
</div>
<a id="a2384498ec70e9fbc955e2cffc935c20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384498ec70e9fbc955e2cffc935c20d">&#9670;&nbsp;</a></span>restoreBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::restoreBasis </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipRowMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipColMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function restores full basis from its short version given by two arrays <code>m_ipRowMap</code> and <code>m_ipColMap</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipRowMap,ipColMap</td><td>pointer to memory array with stored basis in short form; usually, <code>ipRowMap</code> and <code>ipColMap</code> are copies of <code>m_ipRowMap</code> and <code>m_ipColMap</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is used internally in <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCLP.html#a2ac6fb5c88b7e46c5df16aff64fe75c7">m_ipRowMap</a></code> and <code><a class="el" href="classCLP.html#a40da01358a5856facd1f09ae37a30b3e">m_ipColMap</a></code>. </dd></dl>

</div>
</div>
<a id="a62386390656150763472f05e4419e82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62386390656150763472f05e4419e82d">&#9670;&nbsp;</a></span>safeAddColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::safeAddColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a safer version of <a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">addColumn()</a>. If <code>dpVal</code> and <code>ipCol</code> are references to internal MIPCL arrays such as <code>m_dpFb</code> or <code>m_ipArray</code>, memory for such arrays may be reallocated during the call to <code><a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">addColumn()</a></code>, and, as a consequence, the pointers <code>dpVal</code> and <code>ipRow</code> becomes not valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd,type,cost,l,u,sz,dpVal,ipRow,bSort</td><td>have the same meanings as parameters of <code><a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">addColumn()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of added column (variable). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a41e6abd8eca3cbf22a958dbddbfe9069">addVar()</a>, <a class="el" href="classCLP.html#aae1903c28e39c136ec8fcbe9cb65a8bd">addColumn()</a>, <a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn()</a>. </dd></dl>

</div>
</div>
<a id="ac7cfc7443dff945bc5a424fb161e5d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cfc7443dff945bc5a424fb161e5d5c">&#9670;&nbsp;</a></span>safeAddRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::safeAddRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>&#160;</td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSort</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a safer version of <a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow()</a>. If <code>dpVal</code> and <code>ipCol</code> are references to internal MIPCL arrays such as <code>m_dpFb</code> or <code>m_ipArray</code>, memory for such arrays may be reallocated during the call to <code><a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow()</a></code>, and, as a consequence, the pointers <code>dpVal</code> and <code>ipCol</code> becomes not valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hd,type,lhs,rhs,sz,dpVal,ipCol,bSort</td><td>have the same meanings as parameters of <code><a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constraint index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a0d5b435146fc416d5bc296f0acbbf029">addCtr()</a>, <a class="el" href="classCLP.html#aee7861b5b2e692f6043dfe1d7bd77e21">addRow()</a>, <a class="el" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow()</a>. </dd></dl>

</div>
</div>
<a id="ab223b0873095d4b64a958e83c79438e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab223b0873095d4b64a958e83c79438e4">&#9670;&nbsp;</a></span>saveBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::saveBasis </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function packs the basis into a memory buffer (pointed to by <code>mem</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mem</td><td>pointer to memory array of size at least <code>m_iN</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size (in integer words) of stored data. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ae8da82ce47808a11b30e749fbb568b37">restoreBasis()</a>. </dd></dl>

</div>
</div>
<a id="af9fbf7efb944d49efcca01a0f9c083d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fbf7efb944d49efcca01a0f9c083d7">&#9670;&nbsp;</a></span>scaleColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::scaleColumn </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function multiplies each coefficient (including the cost) in the column by the factor of that row the coefficient belongs to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cost</td><td>cost of column being scaled; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size (number of rows with non-zero coefficients) of column; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>sz</code>; in column being scaled, <code>dpVal[i]</code> is coefficient in row <code>ipRow[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#af9fbf7efb944d49efcca01a0f9c083d7">scaleColumn()</a>. </dd></dl>

</div>
</div>
<a id="a47ddbe21b8a232349765cfc3017d726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ddbe21b8a232349765cfc3017d726b">&#9670;&nbsp;</a></span>scaleCtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::scaleCtr </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">When implementing a separation, or cut generation procedure,
 the user knows nothing about transformations of the matrix
that will be done by the solver. Therefore, in user defined procedures inequalities (cuts) are generated
assuming that the matrix had not been changed.
 Before adding such inequalities to the matrix, they must be previously scaled.
</pre><p>Given a constraint expressed in scaled variables, the function computes <em>scaling factor</em> and multiplies that constraint by this factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs,rhs</td><td>left and right sides of constraint being scaled; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size (number of variables) of constraint; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>sz</code>; in constraint being scaled, <code>dpVal[i]</code> is coefficient at variable <code>ipCol[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scaling factor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a369f06d58c9f995bbbf5942c5c812eb2">scaleRow()</a>. </dd></dl>

</div>
</div>
<a id="a5fa07941b540e729bca314a31369373e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa07941b540e729bca314a31369373e">&#9670;&nbsp;</a></span>scaleMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::scaleMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute factors and then scales matrix. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The method used for computing factors is determined by the current value of <code>m_eScaling</code>, which is set by <code><a class="el" href="classCLP.html#a91942427d24c7c88a0a3feda3bd92b1a">setScaling()</a></code>. </dd></dl>

</div>
</div>
<a id="a369f06d58c9f995bbbf5942c5c812eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369f06d58c9f995bbbf5942c5c812eb2">&#9670;&nbsp;</a></span>scaleRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::scaleRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is used to express constraints in scaled variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size (number of variables) of constraint; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dpVal,ipCol</td><td>arrays of size <code>sz</code>; in constraint being scaled, <code>dpVal[i]</code> is coefficient at variable <code>ipCol[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a47ddbe21b8a232349765cfc3017d726b">scaleCtr()</a>. </dd></dl>

</div>
</div>
<a id="adaddeb4967c9c44cca3505f3e8c4a99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaddeb4967c9c44cca3505f3e8c4a99d">&#9670;&nbsp;</a></span>scaleVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::scaleVar </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ipRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">When implementing a column generating procedure, the user knows nothing about transformations of the matrix
that will be done by the solver. Therefore, in user defined procedures columns are generated assuming
that the matrix had not been changed. Before adding such columns to the matrix, they must be previously scaled.
</pre><p>Given a variable (cost coefficient, column of the matrix, and lower and upper bounds), <code><a class="el" href="classCLP.html#adaddeb4967c9c44cca3505f3e8c4a99d">scaleVar()</a></code> computes <em>scaling factor</em> and multiplies that column by this factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cost</td><td>cost of column being scaled; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">l,u</td><td>lower and upper bounds that corresponds to column being scaled; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size (number of variables) of constraint; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dpVal,ipRow</td><td>arrays of size <code>sz</code>; in column being scaled, <code>dpVal[i]</code> is coefficient in row <code>ipRow[i]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scaling factor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#af9fbf7efb944d49efcca01a0f9c083d7">scaleColumn()</a>. </dd></dl>

</div>
</div>
<a id="a06d0849fc963749a56b07560abaa6ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d0849fc963749a56b07560abaa6ad8">&#9670;&nbsp;</a></span>separate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::separate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a> *&#160;</td>
          <td class="paramname"><em>ipColHd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>genFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Usually, this function is used for generating (adding to the matrix) strong inequalities, i.e., those that are a part of problem formulation, or those that are facet-defining cuts, and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of variables; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpX,ipColHd</td><td>arrays of size <code>n</code>; <code>dpX[i]</code> is value of variable having handle <code>ipColHd[i]</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">genFlag</td><td>if <code>true</code>, all generated inequalities are added to matrix by calling <code><a class="el" href="classCLP.html#a40b16107bf05adff72406dbb0869d682">addNewRow()</a></code> (or <code><a class="el" href="classCMIP.html#a3c7398f71012d27f00d10db22b6b458b">CMIP::addCut()</a></code> in MIP applications); otherwise, none inequality should be added; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>genFlag==true</code>: <code>true</code> if at least one inequality were generated; otherwise, <code>false</code>;</li>
<li><code>genFlag==false</code>: <code>false</code> (!!!) if solution presented in <code>dpX,ipColHd</code> is feasible, or <code>true</code> if it is infeasible. </li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCMemoryException.html" title="Exceptions thrown if any problem arises when allocating (reallocating) memory.">CMemoryException</a></td><td>lack of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Default implementation does nothing. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a40b16107bf05adff72406dbb0869d682">addNewRow()</a>, <a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">CMIP::genCut1()</a>, <a class="el" href="classCMIP.html#a6af3635d2a8696dc3ae7b55e6006c4de">CMIP::genCut2()</a>. </dd></dl>

</div>
</div>
<a id="a2bf78b8f2562769fda19237d42f8c0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf78b8f2562769fda19237d42f8c0da">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::serialize </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_storing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function stores into (or restores from) the stream <code>ar</code> <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> objects (all its member storing permanent data). Derived classes may overload this function to store additional information. In such a case, call first <code><a class="el" href="classCLP.html#a2bf78b8f2562769fda19237d42f8c0da">serialize()</a></code> of the base class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ar</td><td>reference to a stream; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_storing</td><td>if <code>true</code>, the object is written to the stream; otherwise, the object is restored from the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>CMIPP::serialize(). </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#abd245965e7a73e148149eb8c198dacb4">CMIP</a>.</p>

</div>
</div>
<a id="a2d7c374f8854c9e143e645737bfa981f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7c374f8854c9e143e645737bfa981f">&#9670;&nbsp;</a></span>setColumnsInactive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CLP::setColumnsInactive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is called when a set of columns is deleted from the matrix. Default <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>-implementation does nothing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#a612e469aee7603340f2084491b155e76">CMIP::setColumnsInactive()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a612e469aee7603340f2084491b155e76">CMIP</a>.</p>

</div>
</div>
<a id="afde48f5ce2e42ac3feee72da0cf74ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde48f5ce2e42ac3feee72da0cf74ff8">&#9670;&nbsp;</a></span>setCtrBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setCtrBounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure sets both, lower and upper, bounds for a given constraint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index (not handle); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs,rhs</td><td>new left and right hand sides for constraint <code>i</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Changing bounds for constraints may make the basis prime or dual infeasible. </dd></dl>

</div>
</div>
<a id="a53b06d08bbbe459d890cb206b4c03328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b06d08bbbe459d890cb206b4c03328">&#9670;&nbsp;</a></span>setCtrFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setCtrFree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure sets the left hand side to minus infinity, and the right hand side to infinity. </p><dl class="section attention"><dt>Attention</dt><dd>Removing bounds for constraints may make the basis dual infeasible. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#afde48f5ce2e42ac3feee72da0cf74ff8">setCtrBounds()</a>. </dd></dl>

</div>
</div>
<a id="a2294953950b9fd61ca9b1e9d9d9893be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2294953950b9fd61ca9b1e9d9d9893be">&#9670;&nbsp;</a></span>setCtrsInactive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CLP::setCtrsInactive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function is called when a set of constraints is deleted from the matrix. Default <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code>-implementation does nothing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCMIP.html#ad52f642c579d214dfa706ddca4abc375">CMIP::setCtrsInactive()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#ad52f642c579d214dfa706ddca4abc375">CMIP</a>.</p>

</div>
</div>
<a id="a8eda3b06a9294104d19ad3fce885b007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eda3b06a9294104d19ad3fce885b007">&#9670;&nbsp;</a></span>setCtrTol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setCtrTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>maximum violation allowed for regular constraints (not cuts). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#aaeddcd066d467d08fb8328f7ccae88f8">getCtrTol()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCMIP.html#a74d43cf4b29aad6073839da5acad5d3e">CMIP</a>.</p>

</div>
</div>
<a id="aa6eb4ddddfc54fd90df48a07e89c555b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eb4ddddfc54fd90df48a07e89c555b">&#9670;&nbsp;</a></span>setDegenTol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setDegenTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>primeDegTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dualDegTol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function sets <em>degeneracy tolerance</em> values for both, prime and dual<code>simplex procedures. \param[in] primeDegTol if increase of objective after performing any iterate of</code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a><code> is less than</code>primeDegTol<code>this iterate is considered as _degenerate_. \param[in] dualDegTol if decrease of objective after performing any iterate of</code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a><code> is less than</code>dualDegTol` this iterate is considered as <em>degenerate</em>. </p><dl class="section remark"><dt>Remarks</dt><dd>If one of two input parameters has a negative value, the corresponding tolerance value remains unaffected. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ae39a48a82310b64fbfd5db845cf6fe11">getPrimeDegTol()</a>, <a class="el" href="classCLP.html#aa0af3765cf29ebec0e93462b47958408">getDualDegTol()</a>. </dd></dl>

</div>
</div>
<a id="ad74448bf0bb4ddd874f517399e8789fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74448bf0bb4ddd874f517399e8789fd">&#9670;&nbsp;</a></span>setFrequencyForInfoMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setFrequencyForInfoMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>CLP-messages will be printed after those LP-iterates which index is a multiple of <code>fr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>switchPrintingInfoMsg(). </dd></dl>

</div>
</div>
<a id="a260179a2e457f650376e7a92b8136549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260179a2e457f650376e7a92b8136549">&#9670;&nbsp;</a></span>setLHS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setLHS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure sets the lower (left hand side) bound for a given constraint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index (not handle); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>new left hand side for constraint <code>i</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Changing bounds for constraints may make the basis prime or dual infeasible. </dd></dl>

</div>
</div>
<a id="a30a12c913e4ddbdb194d7b75b11d0500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a12c913e4ddbdb194d7b75b11d0500">&#9670;&nbsp;</a></span>setLPmethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setLPmethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e">enLPmethod</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets the solution algorithm to be used for solving LPs and root LPs of MIPs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>solution algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a2a7aedeedf26a9bcab5d5e32c528131e" title="LP methods.">enLPmethod</a>, <a class="el" href="classCLP.html#a19188e63c2b129617b4397812cf7b811">getCurrentLPmethod()</a>. </dd></dl>

</div>
</div>
<a id="ac09cc6122bc3b2f960723b9e6daabfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09cc6122bc3b2f960723b9e6daabfe7">&#9670;&nbsp;</a></span>setLpPricingRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setLpPricingRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5">enPricingRule</a>&#160;</td>
          <td class="paramname"><em>pricingRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The functions sets the pricing rule to be used for solving LPs and root LPs of MIPs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pricingRule</td><td>new pricing rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ad5c02821b739c221b8e3672a46bc4ea5" title="Pricing rules.">enPricingRule</a>, <a class="el" href="classCLP.html#a885168355b7d81cfa3cb7872ec5ec0a4">getPricingRule()</a>. </dd></dl>

</div>
</div>
<a id="a8bb08fe1a8a4075dc382d6df66638061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb08fe1a8a4075dc382d6df66638061">&#9670;&nbsp;</a></span>setLpSepRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setLpSepRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584">enSepRule</a>&#160;</td>
          <td class="paramname"><em>sepRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function sets the <b>separaion rule</b> applied when solving LPs, and is also used when solving root LPs of MIPs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sepRule</td><td>new separation rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#abd7826c555555d1888a96efa8572f584" title="Separation rules.">enSepRule</a>, <a class="el" href="classCLP.html#acec30b96087c0a237e468907de24c75e">getSepRule()</a>, setMipSepRule(). </dd></dl>

</div>
</div>
<a id="a7c7f26d09a5c395b7abe013ce5b4b571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7f26d09a5c395b7abe013ce5b4b571">&#9670;&nbsp;</a></span>setMaxLuUpdateNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setMaxLuUpdateNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxUpdateNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>At each iterate both, prime and dual, simplex algorithms solves at least two linear systems, <code>B x = b</code> and <code>B^Ty=c</code>. Here $B$ denotes basic matrix, vector $b$ is composed from the basic components of the right or left hand side vectors, and vector $c$ is composed from the basic components of the upper or lower bound vectors. To solve the systems <code>B x = b</code> and <code>B^Ty=c</code>, <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> <em>factors</em> the basic matrix, i.e., computes an LU-partition: <code>B=LU</code>, where <code>L</code> is lower, and <code>U</code> upper triangular matrices. Since computing LU-partition is time-consuming operation, it is computed only in those simplex-iterations that are multiple of some predefined number (say, 50). In all other iterations, <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a></code> updates the partition of the previous iteration. Although updating LU-partitions is less costly than re-factoring the basic matrix, such updates introduce additional errors in the solutions. To eliminate these the solver has to re-factor the basis after carrying out a predefined number of updates, or in case the solver detects computational instability.</p>
<p><code><a class="el" href="classCLP.html#a7c7f26d09a5c395b7abe013ce5b4b571">setMaxLuUpdateNum()</a></code> sets a new limit on the number of consecutive updates of the LU-partition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxUpdateNum</td><td>maximum number of LU-updates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb97ed82d53f698715069ce966a1dd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb97ed82d53f698715069ce966a1dd0e">&#9670;&nbsp;</a></span>setObjCoeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setObjCoeff </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function sets (or changes) the cost of a variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of a variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>cost of variable <code>j</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a1b76fdfaaea16e1d251688a596e4ad01">getObjCoeff()</a>, <a class="el" href="classCLP.html#a574534be9bfcd5d37b8cd209cf2e2535">addEntry()</a>, <a class="el" href="classCLP.html#aafd55a5bdee0bded239e5d2d772cbea5">changeEntry()</a>. </dd></dl>

</div>
</div>
<a id="a16c2920755af35791f7244dbe1ccdf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c2920755af35791f7244dbe1ccdf4f">&#9670;&nbsp;</a></span>setObjective() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setObjective </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>dpC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sense</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scale</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dpC</td><td>array of size <code>m_iN</code> of objective coefficients; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sense</td><td>if <code>true</code>, the goal is to <em>maximize</em> the objective function; otherwise, to <em>minimize</em>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>if <code>true</code>, the objective is given in the scaled variables; otherwise, in non-scaled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c4a43ce27925dc2b132d89475ccc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c4a43ce27925dc2b132d89475ccc0a">&#9670;&nbsp;</a></span>setObjective() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setObjective </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sense</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>if <code>i &lt; SHIFT</code>, the objective is row <code>i</code>; otherwise, if <code>i &gt;= SHIFT</code>, the objective is to optimize the (i-SHIFT)-th variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sense</td><td>if <code>true</code>, the goal is to <em>maximize</em> the objective function; otherwise, to <em>minimize</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1cc3d96268be208d0e9a730b067f1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cc3d96268be208d0e9a730b067f1f1">&#9670;&nbsp;</a></span>setObjSense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setObjSense </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sense</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sense</td><td>if <code>true</code>, the goal is to <em>maximize</em> the objective function; otherwise, to <em>minimize</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae77d02d81b5e5a3899d084d4e421059e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77d02d81b5e5a3899d084d4e421059e">&#9670;&nbsp;</a></span>setOptFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setOptFlags </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>primeFeasible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dualFeasible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some modification of the matrix may make the currently optimal basis either prime or dual infeasible. Therefore, after having done any such modifications, the user must call this function to change the status of the basis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">primeFeasible</td><td>if <code>false</code>, the basis becomes prime infeasible; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dualFeasible</td><td>if `false, the basis becomes dual infeasible; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a378a97cf0e8477e6f81c2ea40b760897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378a97cf0e8477e6f81c2ea40b760897">&#9670;&nbsp;</a></span>setPivTol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setPivTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolPiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relTolPiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>goodPiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolPivErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relTolPivErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The absolute value of any pivot element must always be greater than <code>m_dPivotTol</code> (an internal MICL parameter), and it also must be greater than either <code>m_dGoodPivot</code> or <code>m_dRelPivotTol * gamma</code>, where gamma is the maximum absolute value of a nonzero entry in the pivot column for the prime simplex method, or in the pivot row for the dual simplex method. The other two parameters, <code>m_dPivotErrTol</code> and <code>m_dRelPivotErrTol</code> are used to estimate absolute and relative errors when computing pivot elements.</p>
<p>Default values:</p><ul>
<li>1.0e-9 for <code>m_dPivotTol</code>,</li>
<li>1.0e-3 for <code>m_dGoodPivot</code>,</li>
<li>1.0e-10 for <code>m_dPivotErrTol</code></li>
<li>1.0e-7 for <code>m_dRelPivotTol</code> and <code>m_dRelPivotErrTol</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolPiv</td><td>new value for <code>m_dPivotTol</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relTolPiv</td><td>new value for <code>m_dRelPivotTol</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">goodPiv</td><td>new value for <code>m_dGoodPivot</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolPivErr</td><td>new value for <code>m_dPivotErrTol</code>; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relTolPivErr</td><td>new value for <code>m_dRelPivotErrTol</code>; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>All these tolerance parameters are interdependent; therefore, tuning them is a subtle task. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ac816fe1f356205b0fef57c3cdb500ca0">getPivTol()</a>, <a class="el" href="classCLP.html#a1e52370b1b816c402867dd27aeb0c64f">getGoodPiv()</a>, <a class="el" href="classCLP.html#a1fd3feb9f48d6a206cef0e7c74dceebe">getRelPivTol()</a>, <a class="el" href="classCLP.html#a60f1b1273fc526e772a8bc17f7df93e5">getPivErrTol()</a>, <a class="el" href="classCLP.html#af24f7fcadce90f9e2f0200641e389839">getRelPivErrTol()</a> </dd></dl>

</div>
</div>
<a id="a5d9cc1618db03af0e431b1404b392af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9cc1618db03af0e431b1404b392af6">&#9670;&nbsp;</a></span>setProblemName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setProblemName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets problem name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>problem name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The name is truncated to have at most 31 symbol. </dd></dl>

</div>
</div>
<a id="ad7feb77a91a7839b570a69e712da2a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7feb77a91a7839b570a69e712da2a83">&#9670;&nbsp;</a></span>setRedCostTol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setRedCostTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>Reduced costs</em> of variables are considered as non-negative if their values are not less than <code>-m_dRedCostTol</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>new value for <code>m_dRedCostTol</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a14a0519468aae3f041641948cf59aea2">getRedCostTol()</a>. </dd></dl>

</div>
</div>
<a id="ad8b45b189fcc1114a6dd99afb68709c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b45b189fcc1114a6dd99afb68709c2">&#9670;&nbsp;</a></span>setRHS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setRHS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The procedure sets the upper (right hand side) bound for a given constraint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>constraint index (not handle); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>new right hand side for constraint <code>i</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Changing bounds for constraints may make the basis prime or dual infeasible. </dd></dl>

</div>
</div>
<a id="a91942427d24c7c88a0a3feda3bd92b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91942427d24c7c88a0a3feda3bd92b1a">&#9670;&nbsp;</a></span>setScaling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setScaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877">enScaling</a>&#160;</td>
          <td class="paramname"><em>scalingMethod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalingMethod</td><td>new scaling method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a69612f747174f3c3e3a19f17cc290877" title="This is the list of all possible ways to scale matrix.">enScaling</a>. </dd></dl>

</div>
</div>
<a id="ac888a61e64a5f4a3a52bbfd2cbc3cac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac888a61e64a5f4a3a52bbfd2cbc3cac3">&#9670;&nbsp;</a></span>setShadowPriceTol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setShadowPriceTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>Shadow prices</em> (dual variables) are considered as non-negative if their values are not less than <code>-m_dShadowPriceTol</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>new value for <code>m_dShadowPriceTol</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a9ccd228f5834359466cff18b0f6f05f0">getShadowPriceTol()</a>. </dd></dl>

</div>
</div>
<a id="adb50173d4aa205755b0808ab32912992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb50173d4aa205755b0808ab32912992">&#9670;&nbsp;</a></span>setShadowPriceToleranceThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setShadowPriceToleranceThreshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>th</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a dual variable is less than a given value, the corresponding column is chosen as a pivot column; the latter is not true for the steepest edge strategy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>tolerance value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06d0fb59442b39d19e5bfc77b92a935f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d0fb59442b39d19e5bfc77b92a935f">&#9670;&nbsp;</a></span>setVarBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarBounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index (not handle) of variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l,u</td><td>new lower and upper bounds for variable <code>j</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Changing bounds for variables may make the basis prime or dual infeasible. </dd></dl>

</div>
</div>
<a id="ab31b76176f5ffbcaf2898eaa2d1a2e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31b76176f5ffbcaf2898eaa2d1a2e24">&#9670;&nbsp;</a></span>setVarFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarFree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure removes both, lower and upper, bounds. Sets the lower bound to minus infinity, and the upper to infinity. </p><dl class="section attention"><dt>Attention</dt><dd>Removing bounds for variables may make the basis dual infeasible. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a06d0fb59442b39d19e5bfc77b92a935f">setVarBounds()</a>. </dd></dl>

</div>
</div>
<a id="ad58522cc43d5bc30264c9fed54e3f8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58522cc43d5bc30264c9fed54e3f8a4">&#9670;&nbsp;</a></span>setVarInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarInf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the lower bound of a variable is less than <code>-val</code>, then the variable is assumed not bounded from below. Similarly, if the upper bound of a variable is greater than <code>val</code>, then the variable is assumed not bounded from above. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inf</td><td>new value of "infinity" for variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a3bfd0f57b4fea770d264857d149c2c51">getVarInf()</a>. </dd></dl>

</div>
</div>
<a id="a164c589a3f2bce353f2585f37ab5109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164c589a3f2bce353f2585f37ab5109c">&#9670;&nbsp;</a></span>setVarLoBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarLoBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of a variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>new lower bound for variable <code>j</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Changing bounds for variables may make the basis prime or dual infeasible. </dd></dl>

</div>
</div>
<a id="a576593762fc04542102b77b183fe1b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576593762fc04542102b77b183fe1b5a">&#9670;&nbsp;</a></span>setVarTol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>any variable may maximum violation allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ac08c3dd8c2a520eab4122a2789609810">getVarTol()</a>. </dd></dl>

</div>
</div>
<a id="a4910c689baa5522fc29d77599affc2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4910c689baa5522fc29d77599affc2cb">&#9670;&nbsp;</a></span>setVarUpBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarUpBound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>index of a variable; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>new upper bound for variable <code>j</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Changing bounds for variables may make the basis prime or dual infeasible. </dd></dl>

</div>
</div>
<a id="af9e92e08af8ffe926643a4bf18b8c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e92e08af8ffe926643a4bf18b8c4c9">&#9670;&nbsp;</a></span>setVarViolatThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setVarViolatThreshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>th</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a bound for a variable is violated by more than a given value, the separation procedure will not verify any non-trivial inequalities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>tolerance value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a529998af95e064af12df5e28790958b5">getVarViolatThreshold()</a>. </dd></dl>

</div>
</div>
<a id="a1c00ecaf1e40dc3077988b1a75190e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c00ecaf1e40dc3077988b1a75190e2c">&#9670;&nbsp;</a></span>setZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::setZero </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zero</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All numeric values that are less than <code>m_dZeroEntry</code> are considered as zeroes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zero</td><td>new value of "zero". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The default value is 1.0e-13. </dd></dl>

</div>
</div>
<a id="a10d5e85eed5683918536072019f7bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d5e85eed5683918536072019f7bda5">&#9670;&nbsp;</a></span>shiftBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::shiftBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedures replaces bounds <code>[d1[j],d2[j]]</code> for <code>[0,d2[j]-d1[j]]</code>) for those variables, <code>j</code>, which lower bounds <code>d1[j] &lt;!= 0</code>. </p><dl class="section return"><dt>Returns</dt><dd>number of changed bounds. </dd></dl>

</div>
</div>
<a id="afdc8c6445cbc093409f21ee338f0924c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc8c6445cbc093409f21ee338f0924c">&#9670;&nbsp;</a></span>showWhyLpInfeasible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::showWhyLpInfeasible </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function simply writes to the output stream the result returned by <code><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>output file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a>, <a class="el" href="classCLP.html#aab0ea08d73d4bcbcbdb38176627aa52f">showWhyLpInfeasible(const char* fileName)</a>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call <code><a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible()</a></code> only if <code><a class="el" href="classCLP.html#a497f4551e040248b83ced4d34c0ab017">isLpInfeasible()</a></code> returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="aab0ea08d73d4bcbcbdb38176627aa52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0ea08d73d4bcbcbdb38176627aa52f">&#9670;&nbsp;</a></span>showWhyLpInfeasible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::showWhyLpInfeasible </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function simply writes to the file the result returned by <code><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>output file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a>, <a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible(std::ostream &amp;out)</a>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call <code><a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible()</a></code> only if <code><a class="el" href="classCLP.html#a497f4551e040248b83ced4d34c0ab017">isLpInfeasible()</a></code> returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a6d5f5d38fd9d40af6e38eba360bc48e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5f5d38fd9d40af6e38eba360bc48e2">&#9670;&nbsp;</a></span>showWhyLpUnbounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::showWhyLpUnbounded </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function simply writes to the file the result returned by <code><a class="el" href="classCLP.html#a7d11405730a32a3917518bd97f06d6ae">whyLpUnbounded()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>output file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a7d11405730a32a3917518bd97f06d6ae">whyLpUnbounded()</a>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call <code><a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible()</a></code> only if <code><a class="el" href="classCLP.html#a297ec9a7bc4bd6a249a0c73de69f1b17">isLpUnbounded()</a></code> returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a582069e20a64bafa43df0e1d6f30c36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582069e20a64bafa43df0e1d6f30c36b">&#9670;&nbsp;</a></span>solveLP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::solveLP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lp_8h.html#aca4f61cd813633bbf0e0051dc67546d8">__LONG</a>&#160;</td>
          <td class="paramname"><em>timeLimit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>genFlag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The procedure first computes an initial basis, and then implements an iterative procedure that, until the current basic solution is prime and dual feasible, applies either <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> or <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeLimit</td><td>procedure will stop running in at most <code>timeLimit</code> seconds; <code>timeLimit==0l</code> means no time limitation; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">genFlag</td><td>if <code>false</code>, both, inequalities and columns, are not generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case a solution has been found; otherwise, the return value is that of <code><a class="el" href="classCLP.html#ac62425ce4381d5cb0fa084815590eeb6">primeSimplex()</a></code> or <code><a class="el" href="classCLP.html#ae6f4a451dece7eb131a6c63bdcc7189d">dualSimplex()</a></code> depending which of them returned a non-zero value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#acac38ce07ce257c0a7ee44dfc12e59b4">optimize()</a>. </dd></dl>

</div>
</div>
<a id="ac1d8af63bdc483cc78628d591ff5f90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d8af63bdc483cc78628d591ff5f90e">&#9670;&nbsp;</a></span>STRBR_estimateObjDecrease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::STRBR_estimateObjDecrease </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxItNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This procedure implements a very restricted variation of the dual simplex algorithm in order to fulfill just a few iterates (without re-factoring the basic matrix). Such a behavior is needed to efficiently implement a strong branching procedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerBound</td><td>lower bound on optimal objective value; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxItNum</td><td>maximum number of iterates to be accomplished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1: in case of success; 2: exceeded maximum number of iterations; 3: exceeded given lower bound on optimal objective value; 6: any numeric instability. </dd></dl>

</div>
</div>
<a id="a6759b414050614829e2e5570e8d03fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6759b414050614829e2e5570e8d03fb6">&#9670;&nbsp;</a></span>switchLpInfoMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::switchLpInfoMsg </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The function is called to switch on or off printing CLP run time messages.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>if set to <code>true</code>, run time CLP-messages will be printing; otherwise, not, </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af133727d823c6536163212af7e98ca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af133727d823c6536163212af7e98ca50">&#9670;&nbsp;</a></span>switchOffRowGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::switchOffRowGen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this function to prevent generation of any inequalities. </p><dl class="section attention"><dt>Attention</dt><dd>The function should be called before <code><a class="el" href="classCLP.html#acd2170c41aaba9fd1dcd4db56ed7a408">openMatrix()</a></code>, which allocates memory. Otherwise, unnecessary additional amount of memory will be allocated. </dd></dl>

</div>
</div>
<a id="a029d2b59626190b5c3c03f3f01544255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029d2b59626190b5c3c03f3f01544255">&#9670;&nbsp;</a></span>updateSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::updateSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function re-factors the basis, and then recomputes both, prime and dual, basic solutions. </p>

</div>
</div>
<a id="a4f43361e3880af54ce8ff86d806d4ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f43361e3880af54ce8ff86d806d4ded">&#9670;&nbsp;</a></span>whyLpInfeasible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::whyLpInfeasible </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipRowHd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpYctr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipColHd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpYbd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>According to Farkas Lemma, a system of inequalities is infeasible if can get the wrong inequality <code>0 &lt; -1</code> by multiplying these inequalities by some numbers (multiplies) &mdash; of course,if we multiply an inequality by a negative number, we also have to change the sign of that inequality) &mdash; an then sum up the results. A collection of such multipliers is known as a <em>sertificate</em> of inconsistency.</p>
<p><code><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a></code> returns a certificate of inconsistency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>number of constraints; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpYctr,ipRowHd</td><td>arrays of size <code>m</code>; if <code>dpYctr[i] &gt; 0</code> (<code>dpYctr[i] &lt; 0</code>), then right (left) part of constraint with handle <code>ipRowHd[i]</code> belongs to the set of contradicting constraints; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>number of variables; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpYbd,ipColHd</td><td>arrays of size <code>n</code>; if <code>dpYbd[i] &gt; 0</code> (<code>dpYbd[i] &lt; 0</code>), then right (left) bound of variable with handle <code>ipColHd[i]</code> belongs to the set of contradicting constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a497f4551e040248b83ced4d34c0ab017">isLpInfeasible()</a>, <a class="el" href="classCLP.html#afdc8c6445cbc093409f21ee338f0924c">showWhyLpInfeasible()</a>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>1. Call <code><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a></code> only if <code><a class="el" href="classCLP.html#a497f4551e040248b83ced4d34c0ab017">isLpInfeasible()</a></code> returns <code>true</code>.</dd></dl>
<ol type="1">
<li>If the value of any input parameter is <code>0</code>, then the output value of this parameter points to an internal MIPCL buffer. Therefore, calling two function in sequence, keep in mind that the second call may override the values returned by the first call. This is not true for the handle-parameters, you can always set initial values for these parameters to <code>0</code>.</li>
</ol>
<p>If you do not allocate memory to some input parameter and its value is not <code>0</code>, then the behavior of the calling function is not predicted!!! </p>

</div>
</div>
<a id="a7d11405730a32a3917518bd97f06d6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d11405730a32a3917518bd97f06d6ae">&#9670;&nbsp;</a></span>whyLpUnbounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CLP::whyLpUnbounded </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>dpRay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&amp;&#160;</td>
          <td class="paramname"><em>ipColHd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An LP is unbounded if the there exists a ray such that all its points are feasible solutions to the system of LP inequalities. This procedure returns such a ray. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>number of columns; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpX,dpRay</td><td>arrays of size <code>n</code>; <code>dpX + lambda * dpRay</code> is feasible point for all <code>lambda &gt;= 0</code>; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipColHd</td><td>arrays of size <code>n</code>; variable with handle <code>ipColHd[i]</code> has index <code>i</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the problem is feasible but unbounded (<code>dpX</code> contains a feasible point), and <code>false</code> if the problem is either infeasible or unbounded; in the latter case, any feasible point has not been found, and, therefore, <code>dpX</code> contains nothing.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#a4f43361e3880af54ce8ff86d806d4ded">whyLpInfeasible()</a>. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Call <code><a class="el" href="classCLP.html#a7d11405730a32a3917518bd97f06d6ae">whyLpUnbounded()</a></code> only if <code><a class="el" href="classCLP.html#a297ec9a7bc4bd6a249a0c73de69f1b17">isLpUnbounded()</a></code> returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="a7a3fdda6619175bb60893ed01f97648d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3fdda6619175bb60893ed01f97648d">&#9670;&nbsp;</a></span>writeStrToLogStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP::writeStrToLogStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>MIPCL</b> writes to the LOG file, which name is the concatenation of the problem name and the extension ".log" quite a lot of information describing all phases of the solution process. After having been analyzed the contents of the LOG file, the user may adjust the parameters of the solver to improve its efficiency. The user can also write to this LOG file any messages by calling <code><a class="el" href="classCLP.html#a7a3fdda6619175bb60893ed01f97648d">writeStrToLogStream()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>message string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="acbcd9ecf00ad8658d570dd803b0aabe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcd9ecf00ad8658d570dd803b0aabe3">&#9670;&nbsp;</a></span>INF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double CLP::INF =1.0e+20</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default value of infinity. </p>
<p>Devault value for infinity. </p>

</div>
</div>
<a id="ac14d891f81497d3a31f6f1f9b734c134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14d891f81497d3a31f6f1f9b734c134">&#9670;&nbsp;</a></span>m_cpColScale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed char* CLP::m_cpColScale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>column factors. </p>
<p>Array of size <code>m_iNmax</code>, <code>s=m_cpColScale[j]</code> is a scale factor of column <code>j</code>, i.e., column <code>j</code> is multiplied by 2^s. </p>

</div>
</div>
<a id="a70b73524e19624b92f012306cc7dafcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b73524e19624b92f012306cc7dafcb">&#9670;&nbsp;</a></span>m_cpRowScale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">signed char* CLP::m_cpRowScale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>row factors. </p>
<p>Array of size <code>m_iMmax</code>, <code>s=m_cpRowScale[i]</code> is a scale factor of row <code>i</code>, i.e., row <code>i</code> is multiplied by 2^s. </p>

</div>
</div>
<a id="a4a933977c2361e2360df3bb9d448db37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a933977c2361e2360df3bb9d448db37">&#9670;&nbsp;</a></span>m_dpB</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* CLP::m_dpB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>left and right hand sides of constraints. </p>
<p>Array of size <code>2*m_iMmax</code>, <code>m_dpB[i&lt;&lt;1]</code> and <code>m_dpB[(i&lt;&lt;)+1]</code> are left and right hand sides of constraint <code>i</code>. </p>

</div>
</div>
<a id="aa9f23a7edca7c9542be3158f05d59cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f23a7edca7c9542be3158f05d59cfd">&#9670;&nbsp;</a></span>m_dpNorm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* CLP::m_dpNorm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>row or column norms in the current basis. </p>
<p>Array of size max{<code>m_iNmax,m_iMmax+m_iMaxLuUpdateNum</code>}, may be freely used in user cut and column generating procedures. </p>

</div>
</div>
<a id="ad63a7c7ed4a5ca7f2101addf51d340f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63a7c7ed4a5ca7f2101addf51d340f9">&#9670;&nbsp;</a></span>m_iMmax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::m_iMmax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of constraints. </p>
<p>If an extra constraint (above this limit) is added, memory for the matrix is reallocated. </p>

</div>
</div>
<a id="a60913419a10a2601b7f070aed76015b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60913419a10a2601b7f070aed76015b1">&#9670;&nbsp;</a></span>m_iNZmax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::m_iNZmax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of entries. </p>
<p>If an extra entry (above this limit) is added, memory for the matrix is reallocated. </p>

</div>
</div>
<a id="af090a53877a7aeeb727300ccfcc6d94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af090a53877a7aeeb727300ccfcc6d94e">&#9670;&nbsp;</a></span>m_iObjScaleExp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::m_iObjScaleExp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>objective scaling factor. </p>
<p>Cost vector <code>m_dpC</code> is multiplied by 2^{m_iObjScaleExp}. </p>

</div>
</div>
<a id="ae23ed97c6887b059d2066950213df2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23ed97c6887b059d2066950213df2e5">&#9670;&nbsp;</a></span>m_ipBasicRow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* CLP::m_ipBasicRow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>list of basic rows. </p>
<p>If <code>(r=m_ipBasicRow[i]) &gt;= 0</code>, row <code>r</code> is the <code>i</code>-th row in the basis; if <code>(r=m_ipBasicRow[i]) &lt; 0</code>, row e_{-r-1} is the <code>i</code>-th row in the basis. </p>

</div>
</div>
<a id="acd0a7058459b5d9e59394e5620ebcdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0a7058459b5d9e59394e5620ebcdda">&#9670;&nbsp;</a></span>m_ipColHd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>* CLP::m_ipColHd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>column handles. </p>
<p>Array of size <code>m_iNmax</code>, <code>m_ipColHd[j]</code> CNormCone *m_pNormCone;</p>
<p>is <em>handle</em> of column (or variable) <code>j</code>,</p><ul>
<li>if <code>m_ipColHd[j] &lt; 0</code>, column <code>i</code> is also stored in the pool;</li>
<li>if <code>m_ipColHd[j] &gt;= 0</code>, it is up to the user to assign a value to the handle, say, this may be an index specifying the location of a data structure describing column <code>j</code>.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>each column handle must be unique. </dd></dl>

</div>
</div>
<a id="a40da01358a5856facd1f09ae37a30b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40da01358a5856facd1f09ae37a30b3e">&#9670;&nbsp;</a></span>m_ipColMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* CLP::m_ipColMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>(k=m_ipColMap[j]) &lt; SHIFT</code>, then <code>m_ipBasicColumn[abs(k)-1]=j</code> and the value of the value of variable is equal to its</p><ul>
<li>lower bound if <code>k &lt; 0</code>;</li>
<li>upper bound if <code>k &gt; 0</code>. m_dRelPivotTol If <code>k &gt;= SHIFT</code>, then <code>m_ipBasicColumn[k-SHIFT]=j</code>. <dl class="section remark"><dt>Remarks</dt><dd>The pair (<code>m_ipRowMap</code>,<code>m_ipColMap</code>) is called a <em>short basis</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCLP.html#aa0e4edaf1625342659a98a2ba97514c2" title="list of basic columns.">m_ipBasicColumn</a></code>. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ac3ad613a157f4931a769199ea1ccba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ad613a157f4931a769199ea1ccba9c">&#9670;&nbsp;</a></span>m_ipCtrType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int* CLP::m_ipCtrType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constraint types. </p>
<p>Array of size <code>m_iMmax</code>, <code>m_ipCtrType[i]</code> is a type of constraint <code>i</code>, which is the bitwise OR of the members of two enumerations <code><a class="el" href="classCLP.html#ac886bb1c9454ba327bc52b46b72f7ac5" title="LP types of constraints.">CLP::enCtrType</a></code> and <code><a class="el" href="classCMIP.html#af376f7257f718501639a17f9ac0e44fa" title="MIP types of constraints.">CMIP::enCtrType</a></code>. </p>

</div>
</div>
<a id="a81eb7d1b7e39c81ac444918c5fc0881f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eb7d1b7e39c81ac444918c5fc0881f">&#9670;&nbsp;</a></span>m_ipRowHd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCLP.html#accbd20f2d40a5aec4e06474a7bef2b2d">tagHANDLE</a>* CLP::m_ipRowHd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>row handles. </p>
<p>Array of size <code>m_iMmax</code>, <code>m_ipRowHd[i]</code> is <em>handle</em> of row (or constraint) <code>i</code>,</p><ul>
<li>if <code>m_ipRowHd[i] &lt; 0</code>, constraint <code>i</code> is also stored in the pool;</li>
<li>if <code>m_ipRowHd[i] &gt;= 0</code>, it is up to the user to assign a value to the handle, say, this may be an index specifying the location of a data structure describing constraint <code>i</code>.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>each row handle must be unique. </dd></dl>

</div>
</div>
<a id="a2ac6fb5c88b7e46c5df16aff64fe75c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac6fb5c88b7e46c5df16aff64fe75c7">&#9670;&nbsp;</a></span>m_ipRowMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* CLP::m_ipRowMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <code>(k=m_ipRowMap[i]) &lt; SHIFT</code>, then <code>m_ipBasicRow[abs(k)-1]=i</code> and the value of the inequality is equal to its</p><ul>
<li>left-hand-side if <code>k &lt; 0</code>;</li>
<li>right-hand-side if <code>k &gt; 0</code>.</li>
</ul>
<p>If <code>k &gt;= SHIFT</code>, then <code>m_ipBasicRow[k-SHIFT]=i</code>. </p><dl class="section remark"><dt>Remarks</dt><dd>The pair (<code>m_ipRowMap</code>,<code>m_ipColMap</code>) is called a <em>short basis</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCLP.html#ae23ed97c6887b059d2066950213df2e5" title="list of basic rows.">m_ipBasicRow</a>. </dd></dl>

</div>
</div>
<a id="a0505305247f3bc5762990010d0645c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0505305247f3bc5762990010d0645c58">&#9670;&nbsp;</a></span>m_ipVarType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int* CLP::m_ipVarType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>types of variables. </p>
<p>Array of size <code>m_iNmax</code>, <code>m_ipVarType[j]</code> is a type of variable <code>j</code>, which is the bitwise OR of the members of two enumerations <a class="el" href="classCLP.html#a89292c62c83b834a8b451bde23c67627" title="LP types of variables.">CLP::enVarType</a> and <a class="el" href="classCMIP.html#a70cd164e97628571f7d774472a1e2c92" title="MIP types of variables.">CMIP::enVarType</a>. </p>

</div>
</div>
<a id="aaa6a5c813dbf43e1d52c91fe53b595ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6a5c813dbf43e1d52c91fe53b595ab">&#9670;&nbsp;</a></span>m_iS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::m_iS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a state of the last LP solved. </p>
<p>Problem is</p><ul>
<li>infeasible if m_iS != 0 &amp;&amp; m_bDualFeasible,<ul>
<li>unbounded if m_iS &gt;= 0 &amp;&amp; m_bPrimeFeasible </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="aaf7953644c5b1f45524141bce781d0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7953644c5b1f45524141bce781d0a6">&#9670;&nbsp;</a></span>m_iState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::m_iState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State of the problem, which is the bitwise OR of the members of the enumeration <code>enProbState</code>. </p>

</div>
</div>
<a id="ac02c276e8722797060de6ce60c584603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02c276e8722797060de6ce60c584603">&#9670;&nbsp;</a></span>m_iUpdatePrimeSol</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CLP::m_iUpdatePrimeSol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of modified bounds of non-basic variables. </p>
<p>Sometimes we need to solve an LP that is a slightly modified version of previously another LP. If those modification does not affect the basic submatrix and the objective, one can apply the dual simplex algorithm to re-optimizing the LP starting from an optimal basis of the original LP. But if the bounds of some non-basic variables were modified, we need to update an initial basic solution as well. </p>

</div>
</div>
<a id="a5a6d9c16c926728d109d9fc34fbd4245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d9c16c926728d109d9fc34fbd4245">&#9670;&nbsp;</a></span>m_sWarningMsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char CLP::m_sWarningMsg[256]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character array for using as message strings. </p>
<dl class="section warning"><dt>Warning</dt><dd>Each message must contain no more than <code>255</code> characters. </dd></dl>

</div>
</div>
<a id="aa9f1d2167504fa29b777f6b88259803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f1d2167504fa29b777f6b88259803d">&#9670;&nbsp;</a></span>MAX_BIG_M</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double CLP::MAX_BIG_M =1.0e+20</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default value for big <code>M</code> used in the one phase implementation of the prime simplex algorithm. </p>
<p>Maximum value for big M. </p>

</div>
</div>
<a id="a8bc0df6ea9e3d6ede8c252b9d67b0d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc0df6ea9e3d6ede8c252b9d67b0d4a">&#9670;&nbsp;</a></span>SHIFT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int CLP::SHIFT =0x40000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equals to (std::numeric_limits&lt;int&gt;::max() &gt;&gt; 1). </p>
<p>In fact, only <code>SHIFT-1</code> variables and/or constraints are allowed. </p>

</div>
</div>
<a id="a921256fa400b2cdb6c5008bf189aa7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921256fa400b2cdb6c5008bf189aa7a8">&#9670;&nbsp;</a></span>VAR_INF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double CLP::VAR_INF =1.0e+12</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default value of infinity for variables. </p>
<p>Devault value for infinite bound on variables. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/nick/programs/mip/mipcl/headers/<a class="el" href="lp_8h_source.html">lp.h</a></li>
<li>/home/nick/programs/mip/mipcl/sources/lp.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:35 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
