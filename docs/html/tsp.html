<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: Traveling salesman problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Traveling salesman problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_TSP"></a>
Traveling salesman problem</h1>
<p>The <em>traveling salesman problem</em> (<em>TSP</em>) is the minimum Hamilton cycle problem in complete graphs. It is one of the most famous combinatorial optimization problems. Its name is due to the following interpretation: starting from a given city, a traveling salesman has to visit each of other <em>n</em>-1 cities exactly once, and then return to the initial city, covering the minimal distance. Input data for this problem is given by a <em>distance matrix</em> <img class="formulaInl" alt="$D=[d_{ij}]_{n\times n}$" src="form_206.png"/> which entry <img class="formulaInl" alt="$d_{ij}$" src="form_207.png"/> is the distance between cities <em>i</em> and <em>j</em>.</p>
<p>The branch-and-cut method was first applied by Dancig, Fulkerson, and Jonson (G.B.Dancig, R.Fulkerson, S.M.Jonson. Solution of a large-scale traveling salesman problem. <em>Oper. Res.</em> <b>2</b> (1954) 393&ndash;410) to solve a TSP with 49 cities (an impressive size for the year of 1954). And today branch-and-cut is the only methodology that is able to solve TSPs of big size to optimality.</p>
<p>In what follows, we will use graph terminology and call cities, inter-city roads, and salesman's roundtrips, respectively, vertices , edges, and <em>Hamilton cycles</em> or <em>tours</em>. Introducing binary variables <img class="formulaInl" alt="$x_{ij}\text{ with } x_{ij}=1$" src="form_208.png"/> if edge (<em>i,j</em>) belongs to a Hamilton cycle, we formulate the TSP as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{i=1}^n \sum_{j=1}^n d_{ij} x_{ij} &amp;\to \min\tag{1.a}\\ \sum_{j=1}^n x_{ij} &amp;= 2,\quad i=1,\dots,n,\tag{1.b}\\ \sum_{i,j\in S} x_{ij} &amp;\le |S|-1,\quad \emptyset\neq S\subset V,\tag{1.c}\\ x_{ij} &amp;\in \{0,1\},\quad i,j=1,\dots,n.\tag{1.d} \end{align*}" src="form_209.png"/>
</p>
<p>Here the objective (1.a) is to minimize the length of the tour. The equations (1.b) force each vertex be incident to exactly two edges on the tour: the salesman enters any city by one road and then leaves the city by the other road.</p>
<p>The constraints (1.c) eliminate <em>short cycles</em> (covering less than <em>n</em> vertices). Let us consider an instance of the Hamilton cycle problem in Figure 1 when <img class="formulaInl" alt="$\alpha=4\text{ and } \beta=10$" src="form_210.png"/>.</p>
<div class="image">
<img src="hamilton.png" alt="hamilton.png"/>
<div class="caption">
Figure 1: Hamilton cycle problem</div></div>
<p>  This instance can be considered as a TSP instance if we asume that the distance between any pair of nodes not connected by an edge in Figure 1 is <img class="formulaInl" alt="$\infty$" src="form_116.png"/>. The optimal solution to the IP (1) but without inequalities (1.c), written for our instance, is the point <img class="formulaInl" alt="$x^{(1)}$" src="form_211.png"/> with the following components: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} x^{(1)}_{1,2}=x^{(1)}_{2,3}=x^{(1)}_{3,1}=x^{(1)}_{4,5}=x^{(1)}_{5,6}=x^{(1)}_{6,4} &amp;=1,\\ x^{(1)}_{1,4}=x^{(1)}_{2,5}=x^{(1)}_{3,6} &amp;=0. \end{align*}" src="form_212.png"/>
</p>
<p> This solution corresponds to two short cycles </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ 1\to 2\to 3 \to 1\quad\text{and}\quad 4\to 5\to 6\to 1 \]" src="form_213.png"/>
</p>
<p> and violates two short-cycle inequalities written for the sets <img class="formulaInl" alt="$S_1=\{1,2,3\}\text{ and } S_2=\{4,5,6\}$" src="form_214.png"/>.</p>
<h2><a class="anchor" id="sec_tspTruncatedMIP"></a>
Truncated problem</h2>
<p>Even for problems with a few hundreds of cities the number of variables <img class="formulaInl" alt="$x_{ij}$" src="form_215.png"/> in formulation (1) is very big. Therefore, TSPs of big size are solved using column generation. First, we transform (1) to make it easier for using in a branch-and-price algorithm.</p>
<p>Let us denote by <em>V</em> the set {1,...,n} of all vertices. Let <img class="formulaInl" alt="$\displaystyle D=1 + \max_{1\le i,j\le n} d_{ij}\text{ and } c_{ij}=D-d_{ij}$" src="form_216.png"/>. Since <img class="formulaInl" alt="$\displaystyle \sum_{i=1}^n\sum_{j=1}^n x_{ij} = n$" src="form_217.png"/>, then </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=1}^n\sum_{j=1}^n c_{ij}x_{ij} = D\,n - \sum_{i=1}^n\sum_{j=1}^n d_{ij}x_{ij}. \]" src="form_218.png"/>
</p>
<p> Therefore, formulation (1) is equivalent to the following one:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{i=1}^n \sum_{j=1}^n c_{i,j} x_{ij} &amp;\to \max\tag{2.a}\\ \sum_{j=1}^n x_{ij} &amp;\le 2,\quad i=1,\dots,n,\tag{2.b}\\ \sum_{i,j\in S} x_{ij} &amp;\le |S|-1,\quad \emptyset\neq S\subset V,\tag{2.c}\\ x_{ij} &amp;\in \{0,1\},\quad i,j=1,\dots,n.\tag{2.d} \end{align*}" src="form_219.png"/>
</p>
<p>Here, we relaxed the equations (1.b) to get the inequalities (2.b). As all objective coefficients <img class="formulaInl" alt="$c_{ij}$" src="form_162.png"/> are strictly positive, any optimal solution to problem (2) satisfies all the inequalities (2.b) as equalities.</p>
<p>Next, we are going to "truncate" (2) to get an IP of moderate size. It is reasonable assuming that an optimal tour will consist of most short (with respect to distances <img class="formulaInl" alt="$d_{ij}$" src="form_207.png"/>) edges. Therefore, we build an <em>active graph</em> <em>G</em>=(<em>V</em>,<em>E</em>) including into <em>E</em>, for each vertex, a fixed number, say 10, of most short incident edges. Besides, to guarantee that <em>G</em> be <em>hamiltonian</em> (has a Hamilton cycle), we add to <em>E</em> the edges of a Hamilton cycle build by one of the numerous TSP heuristics. Next, we formulate the following truncated <em>master problem</em>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{(i,j)\in E} c_{i,j} x_{ij} &amp;\to \max\tag{3.a}\\ \sum_{(i,j)\in E(i,V)} x_{ij} &amp;\le 2,\quad i=1,\dots,n,\tag{3.b}\\ \sum_{(i,j)\in E(S,S)} x_{ij} &amp;\le |S|-1,\quad \emptyset\neq S\subset V,\tag{3.c}\\ x_{ij} &amp;\in \{0,1\},\quad (i,j)\in E.\tag{3.d} \end{align*}" src="form_220.png"/>
</p>
<p>Once the relaxation LP for IP (3) (we will see later that cuts are generated and some of them are added to this LP) is solved, we have to check whether adding new edges (<em>i,j</em>) to the active graph may help us to improve the solution found. To find out whether improvements are possible, having shadow prices for the constraints, we compute the reduced cost of each variable <img class="formulaInl" alt="$x_{ij}\text{ for } (i,j)\not\in E$" src="form_221.png"/>. If all these reduced costs are non positive, we proceed to branching; otherwise, some (or all) of the edges, corresponding to the variables with positive reduced costs, are added to the active graph, our truncated MIP is modified accordingly, and its relaxation LP is solved again.</p>
<p>We prefer formulation (2) to formulation (1) because the former has a number of properties that the later has not.</p><ol type="1">
<li>Any truncation of problem (2) always has feasible solutions;</li>
<li>Automatically generated cuts (for example, fractional Gomory cuts) that are valid for truncated MIP (3) are also valid for the complete MIP (2);</li>
<li>When solving a MIP of type (3) by branch-and-cut, if it turns out that the MIP at some search tree node has no solution, then the corresponding subproblem of the complete MIP (2) has no solution as well.</li>
</ol>
<h2><a class="anchor" id="sec_tspCuts"></a>
Cuts</h2>
<p>Many classes of cuts &mdash; perhaps more than for any other combinatorial problem &mdash; have been developed for the TSP. Specialized modern computer programs for solving TSPs use very complex separation and cut generation procedures. Here, we do not pose to ourselves the goal of developing a program for solving TSPs with thousands cities. Our goal is more moderate, we want to demonstrate the power of <b>MIPCL</b> on a rather complex example problem. In our implementation we generate cuts only of two types. Nevertheless, it is suffice for our program to solve TSPs with hundreds cities. Furthermore, you can try to improve this program by adding cut generation procedures for new classes of inequalities.</p>
<h3><a class="anchor" id="sec_tspCutCuts"></a>
Elimination of Short Cycles</h3>
<p>Since system (3.c) contains exponentially (in <em>n</em>) many inequalities, then we can handle them only via a separation procedure that, for a given point <img class="formulaInl" alt="$\tilde{x}\in [0,1]^{E}$" src="form_47.png"/>, is to find an inequality in (3.c) that is violated at <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/>.</p>
<p>It is not difficult to understand that, subject to the constraint </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tag{4} \sum_{(i,j)\in E} x_{ij} = n, \]" src="form_222.png"/>
</p>
<p> system (3.c) is equivalent to the following system of <em>cut inequalities</em> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tag{5} \sum_{(i,j)\in E(S,V\setminus S)} x_{ij} \ge 2,\quad \emptyset\neq S\subset V. \]" src="form_223.png"/>
</p>
<p> Though, in general, the systems (3.c) and (5) are not equivalent, we should not be bothered about this since, generating new cuts, we, sooner or later, will reach a point where equation (4) is satisfied and, consequently, both systems, (2.c) and (5) are equivalent.</p>
<p>If we succeeded to find a cut inequality that is violated at <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{(i,j)\in E(\tilde{S},V\setminus \tilde{S})} \tilde{x}_{ij} \ge 2, \]" src="form_224.png"/>
</p>
<p> we then substitute <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/> into two inequalities from system (3.c): one written for <img class="formulaInl" alt="$S=\tilde{S}$" src="form_225.png"/>, and the other for <img class="formulaInl" alt="$S=V\setminus\tilde{S}$" src="form_226.png"/>. If only one of these two inequalities is violated at <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/>, it is declared as a cut.</p>
<p>The problem of separating for cut inequalities is formulated as the <em>minimum cut problem</em> that is to find a proper subset <img class="formulaInl" alt="$\tilde{S}$" src="form_227.png"/> of the vertex set <em>V</em> such that the value of <img class="formulaInl" alt="$\tilde{x}(\tilde{S})=\sum_{(i,j)\in E(\tilde{S},V\setminus \tilde{S})} \tilde{x}_{ij}$" src="form_228.png"/> is minimal. If <img class="formulaInl" alt="$\tilde{x}(\tilde{S}) &lt; 2$" src="form_229.png"/>, then the inequality <img class="formulaInl" alt="$\sum_{(i,j)\in E(\tilde{S},V\setminus \tilde{S})} x_{ij} \ge 2$" src="form_230.png"/> is violated at <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/>; otherwise, <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/> satisfies all the cut inequalities.</p>
<p>There are efficient deterministic (H.Nagamochi, T.Ibaraki Computing edge connectivity in multigraphs and capacitated graphs. <em>SIAM J. Disc. Math.</em> <b>5</b> (1992) 54&ndash;66) as well as probabilistic (D.R.Karger. Minimum cuts in near-linear time. <em>Journal of the ACM</em> <b>47</b> (2000) 46&ndash;7) minimum cut algorithms.</p>
<p>Besides, we can simultaneously look for many violated cut inequalities if we first build the Gomory-Hu tree for the network <img class="formulaInl" alt="$(G,\tilde{x})$" src="form_231.png"/>. It is said that a cut <img class="formulaInl" alt="$(S,V\setminus S)$" src="form_232.png"/> separates two vertices <em>s</em> and <em>t</em> if exactly one of these vertices belongs to <em>S</em>; such a cut is also called <em>s,t</em>-cut. The Gomory-Hu tree <img class="formulaInl" alt="$T_{GH}=(V,\tilde{E})$" src="form_233.png"/> is defined on the vertex set <em>V</em> of graph <em>G</em>, but its edges <img class="formulaInl" alt="$e\in\tilde{E}$" src="form_234.png"/> are not necessary edges in <em>G</em>. Each edge <img class="formulaInl" alt="$e\in \tilde{E}$" src="form_235.png"/> is assigned a number <img class="formulaInl" alt="$f_e$" src="form_236.png"/>. For two given vertices <img class="formulaInl" alt="$s,t\in V$" src="form_237.png"/>, we can find a minimum <em>s,t</em>-cut as follows. First, on the only path in <img class="formulaInl" alt="$T_{GH}$" src="form_238.png"/> between <em>s</em> and <em>t</em>, we look for an edge <em>e</em> with the minimal value <img class="formulaInl" alt="$f_e$" src="form_236.png"/>. After removing this edge <em>e</em> from <img class="formulaInl" alt="$T_{GH}$" src="form_238.png"/>, we get two connected subtrees. Let <em>S</em> and <img class="formulaInl" alt="$V\setminus S$" src="form_239.png"/> be vertex sets of these subtrees. The partition <img class="formulaInl" alt="$(S,V\setminus S)$" src="form_232.png"/> gives a minimum <em>s,t</em>-cut. Let us also note that building the Gomory-Hu tree assumes solving <em>n</em>-1 maximum flow problems in <img class="formulaInl" alt="$(G,\tilde{x})$" src="form_231.png"/> (D.Gusfield. Very simple method for all pairs network flow analysis. <em>SIAM J. Comput.</em> <b>19</b> (1990) 143&ndash;155).</p>
<h3><a class="anchor" id="sec_tspCombCuts"></a>
Comb cuts</h3>
<p>Despite the fact that formulation (3) consists of so many inequalities, it is not ideal. For example, the point <img class="formulaInl" alt="$x^{(2)}$" src="form_240.png"/>, with coordinates </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} &amp; x^{(2)}_{1,2}=x^{(2)}_{2,3}=x^{(2)}_{3,1}=x^{(2)}_{4,5}= x^{(2)}_{5,6}=x^{(2)}_{6,4}=\frac{1}{2},\\ &amp; x^{(2)}_{1,4}=x^{(2)}_{2,5}=x^{(2)}_{3,6}=1. \end{align*}" src="form_241.png"/>
</p>
<p> is an optimal solution to the relaxation LP for IP (3) that is written for the instance in Figure 1 when <img class="formulaInl" alt="$\alpha=\beta=0$" src="form_242.png"/>. You can easily argue that, among six edges </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1,2),\;(2,3),\; (3,1),\; (1,2),\;(2,3),\; (3,1), \]" src="form_243.png"/>
</p>
<p> at most four edges may be on a Hamilton cycle. Therefore, the following </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tag{6} x_{1,2}+x_{2,3}+x_{3,1}+x_{1,4}+x_{2,5}+x_{3,6} \le 4, \]" src="form_244.png"/>
</p>
<p> which is violated at <img class="formulaInl" alt="$x^{(2)}$" src="form_240.png"/>, is valid for the TSP polyhedron that is defined as the convex hull of all characteristic vectors of Hamilton cycles. Observe, that for the simple instance in Figure 1 (with <img class="formulaInl" alt="$\alpha=\beta=0$" src="form_242.png"/>), it is enough to add only one inequality (6) to solve this instance without branching.</p>
<p>Inequality (6) belongs to a wide class of inequalities named comb inequalities. Let <img class="formulaInl" alt="$H\subseteq V\text{ and } T_i\subseteq V,\; i=1,\dots,k$" src="form_245.png"/>, be such subsets of vertices that satisfy the conditions: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tag{7} \begin{aligned} |H\cap T_i|\ge 1,\; |T_i\setminus H|\ge 1,\quad i=1,\dots,k,\\ T_i\cap T_j =\emptyset,\quad j=i+1,\dots,k;\; i=1,\dots,k-1, \end{aligned} \]" src="form_246.png"/>
</p>
<p> where <em>k</em> &gt; 2 is an odd integer. The configuration <img class="formulaInl" alt="$(H,T_1,\dots,T_k)$" src="form_247.png"/> is called a <em>comb</em> in <em>G</em> with the <em>handle</em> <em>H</em> and the <em>teeth</em> <img class="formulaInl" alt="$T_i$" src="form_248.png"/> (for illustration, see Figure 2).</p>
<div class="image">
<img src="comb.png" alt="comb.png"/>
<div class="caption">
Figure 2: Graphic representation of comb inequalities</div></div>
<p>  As before, let <em>x</em>(<em>S</em>) denote the sum <img class="formulaInl" alt="$\sum_{(i,j)\in E(S,S)} x_{ij}$" src="form_249.png"/>. The inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tag{8} x(H) + \sum_{i=1}^k x(T_i)\le |H| + \sum_{i=1}^k (|T_i|-2) + \left\lfloor\frac{k}{2}\right\rfloor \]" src="form_250.png"/>
</p>
<p> is called a <em>comb inequality</em>. Its validity for the TSP polyhedron is easily justified. Using the inequalities (2.b) and (2.c), we can write down the following chain of inequalities: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} 2 x(H) &amp;+ 2 \sum_{i=1}^k x(T_i) \:\le\: x(H,V) + \sum_{i=1}^k \left(x(T_i) + x(T_i\cap H) + x(T_i\setminus H)\right)\\ &amp;\le 2\,|H| + \sum_{i=1}^k \left((|T_i|-1) + (|T_i\cap H|-1) + (|T_i\setminus H|-1)\right)\\ &amp;= 2\,|H| + 2 \sum_{i=1}^k (|T_i|-2) + k. \end{align*}" src="form_251.png"/>
</p>
<p> Dividing both part of the resulting inequality by 2, we get inequality (8).</p>
<p>The total number of comb inequalities is huge even for small <em>n</em>, this number substantially exceeds the number of cut inequalities. Therefore, to use comb inequalities in computations, we need an efficient separation procedure for these inequalities. We cannot hope that such a procedure will developed because the separation problem for comb inequalities is known to be <b>NP</b>-hard.</p>
<p>There exists an efficient separation procedure for the subclass of comb inequalities when </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ |H\cap T_i|=1,\; |T_i\setminus H|=1,\quad i=1,\dots,k. \]" src="form_252.png"/>
</p>
<p> Such comb inequalities are also called <em>flower inequalities</em>, because these inequalities are sufficient to describe the convex hull of the 2-matching polyhedron (flowers are "bad" structures for the <em>b</em>-matching problem). Given a point <img class="formulaInl" alt="$x\in [0,1]^E$" src="form_253.png"/>, we act as follows to find a violated flower inequality (M.~Padberg, M.R.~Rao. Odd minimum cut-sets and b-matchings. <em>Math. Oper. Res.</em> <b>7</b> (1982) 67&ndash;80).</p>
<ol type="1">
<li>Build graph $G^*(x) = (V^*(x),E^*(x))$ and define its edge capacities as follows: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} V^*(x) &amp;= V \cup \{v_e: e\in E\},\\ E^*(x) &amp;= \{(v,v_e),(v_e,w): e=(v,w) \in E,\; x(e) &gt; 0\},\\ u(v,v_e) &amp;= x(e),\; u(v_e,w) = 1-x(e),\quad e=(v,w)\in E. \end{align*}" src="form_254.png"/>
</p>
</li>
<li>For an odd set <p class="formulaDsp">
<img class="formulaDsp" alt="\[ O = \{v_e: e \in E\} \cup \{w \in V:\; |\{(v_e,w): e \in E\}| \text{ --- odd}\}, \]" src="form_255.png"/>
</p>
 find in <img class="formulaInl" alt="$(G^*(x),u)$" src="form_256.png"/> an odd cut <img class="formulaInl" alt="$(S,V^*(x)\setminus S)$" src="form_257.png"/> (a cut is called odd if <img class="formulaInl" alt="$|S\cap O|$" src="form_258.png"/> is an odd number, we can find an odd cut if we first build a Gomory-Hu tree). If the value of the cut is at least 1, then STOP (there exists no flower inequality violated at <em>x</em>). Otherwise, go to Step 3 to build a comb structure.</li>
<li>Build the comb structure <img class="formulaInl" alt="$(H;T_1,\dots,T_{2K+1})$" src="form_259.png"/> by the rules:<ul>
<li>a) all vertices from <img class="formulaInl" alt="$S \cap V$" src="form_260.png"/> include to the handle <em>H</em>;</li>
<li>b) if <img class="formulaInl" alt="$(v_e,w)\in E(S,V^*(x)\setminus S)$" src="form_261.png"/>, then <em>e</em>=(<em>v,w</em>) is declared as a tooth;</li>
<li>c) if two teeth have a vertex <em>q</em> in common, then both these teeth are removed from the comb structure, and <em>q</em> is either removed from <em>H</em> if it is already in <em>H</em>, or added to <em>H</em> if it is not in <em>H</em>.</li>
</ul>
</li>
</ol>
<p>There are a few heuristics (M.Padberg, G.Rinaldi. Facet identification for the symmetric traveling salesman polytope. <em>Math. Program.</em> <b>47</b> (1990) 219&ndash;257) for separating with general comb inequalities. These heuristics may not find a violated inequality even if such one exists.</p>
<p>Many other classes of inequalities for the TSP polyhedron were developed. But in contrast to cut inequalities all other classes of inequalities are not the part of the formulation. From practical point of view, the main difference between inequalities that constitute the formulation and inequalities that are generated to improve this formulation is in that the former need an exact separation procedure while for the latter separation heuristics can be used. There are many examples, when even in those cases, where theoretically efficient algorithms are known, fast heuristics are preferable in practice.</p>
<h1><a class="anchor" id="sec_mipclTSPimpl"></a>
MIPCL-implementation</h1>
<p>All functionality of our application is implemented in a class <code>CTsp</code> that extends <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. Definition of <code>CTsp</code> is as follows.</p>
<p></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cmip_8h.html">cmip.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;flowNet.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>CTspPool;</div><div class="line"><span class="keyword">enum</span> EDGE_WEIGHT_TYPE {ATT,GEO,EUC_2D};</div><div class="line"></div><div class="line"><span class="keyword">class </span>CTsp: <span class="keyword">public</span> <a class="code" href="classCMIP.html">CMIP</a>  </div><div class="line">{</div><div class="line">        CFlowNet&lt;double&gt; *m_pNet; </div><div class="line">        EDGE_WEIGHT_TYPE m_enType; </div><div class="line">        <span class="keywordtype">int</span> m_iPointNum;        </div><div class="line">        <span class="keywordtype">double</span>* m_dpCoordX; </div><div class="line">        <span class="keywordtype">double</span>* m_dpCoordY; </div><div class="line">        <span class="keywordtype">double</span> m_dMaxDist; </div><div class="line">        <span class="keywordtype">double</span> m_dTourLength; </div><div class="line">        <span class="keywordtype">int</span> *m_ipNextOnTour; </div><div class="line">        CTspPool *m_pTspPool; </div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">        CTsp(<span class="keyword">const</span> <span class="keywordtype">char</span> *name); </div><div class="line"><span class="preprocessor">        #ifndef __ONE_THREAD_</span></div><div class="line">                CTsp(<span class="keyword">const</span> CTsp &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">                <a class="code" href="classCMIP.html">CMIP</a>* <a class="code" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a>(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">                </div><div class="line">        <span class="keyword">virtual</span> ~CTsp(); </div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">double</span> dist(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j); </div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> allocMemForCoords();</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> readPoints(<span class="keyword">const</span> <span class="keywordtype">char</span> *fileName); </div><div class="line">        <span class="keywordtype">void</span> buildActiveGraph();</div><div class="line">        <span class="keywordtype">void</span> setMIP();</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow</a>(tagHANDLE hd, <span class="keywordtype">int</span> n, <span class="keyword">const</span> tagHANDLE* ipColHd,</div><div class="line">                        <span class="keywordtype">int</span>&amp; type, <span class="keywordtype">double</span>&amp; b1, <span class="keywordtype">double</span>&amp; b2,</div><div class="line">                        <span class="keywordtype">int</span>&amp; sz, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipCol, <span class="keywordtype">bool</span> &amp;bScaled);</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">getColumn</a>(tagHANDLE hd, <span class="keywordtype">int</span> m, <span class="keyword">const</span> tagHANDLE* ipRowHd,</div><div class="line">                <span class="keywordtype">int</span>&amp; type, <span class="keywordtype">double</span>&amp; cost, <span class="keywordtype">double</span>&amp; d1, <span class="keywordtype">double</span>&amp; d2,</div><div class="line">                <span class="keywordtype">int</span>&amp; sz, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipRow);</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">lockCtr</a>(tagHANDLE hd);</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">unlockCtr</a>(tagHANDLE hd);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> goToNearest(<span class="keywordtype">int</span> s, <span class="keywordtype">int</span>* tau); <span class="comment">// builds initial feasible solution</span></div><div class="line">        <span class="keywordtype">void</span> approximate(); <span class="comment">// calls goToNearest() in turns with any node as a starting position</span></div><div class="line"></div><div class="line"><span class="comment">// separation routines</span></div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate</a>(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd, <span class="keywordtype">bool</span> GenFlag);</div><div class="line">        <span class="keywordtype">int</span> separateFromPool(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> <span class="keywordtype">int</span>* ipColHd, <span class="keywordtype">bool</span> bGenFlag);</div><div class="line">        <span class="keywordtype">void</span> buildSupportGraph(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd);</div><div class="line">        <span class="keywordtype">int</span> cutSeparate(<span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd, <span class="keywordtype">bool</span> GenFlag);</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">genCut1</a>(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd);</div><div class="line">        <span class="keywordtype">int</span> BLOSSOM_separate(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd);</div><div class="line">        <span class="keywordtype">void</span> addCombCut(<span class="keywordtype">int</span> b, <span class="keywordtype">int</span>* ipComb,</div><div class="line">                <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd);</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a7a22364cac6b727f5b4e8416b753e3cc">generateColumns</a>(<span class="keywordtype">int</span> m, <span class="keyword">const</span> tagHANDLE* ipRowHd, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpY);</div><div class="line">        <span class="keywordtype">void</span> buildSupportGraph();</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">changeRecord</a>(<span class="keywordtype">double</span> dObjVal, <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipHd);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <span class="keywordtype">void</span> solve();</div><div class="line">        <span class="keywordtype">void</span> <a class="code" href="classCMIP.html#a91249febf036dd979f7584bc0962137a">printSolution</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName=0);</div><div class="line">}; <span class="comment">//==============================================</span></div></div><!-- fragment --><p>Its members are:</p><ul>
<li><code>m_pNet</code>: pointer to a <code>CFlowNet&lt;double&gt;</code> object that represents graphs used in our cut generation procedures;</li>
<li><code>m_enType</code>: specifies how distances are computed;</li>
<li><code>m_iPointNum</code>: number of points (cities);</li>
<li><code>m_dpCoordX, m_dpCoordY</code>: arrays of size <code>m_iPointNum</code>, <code>m_dpCoordX[i], m_dpCoordY[i]</code> are x- and y-coordinates of point <code>i</code>;</li>
<li><code>m_dMaxDist</code>: maximum distance between two point;</li>
<li><code>m_dTourLength</code>: length of best tour found;</li>
<li><code>m_ipNextOnTour</code>: array of size <code>m_iPointNum</code> that stores best tour found, where (<code>i,m_ipNextOnTour[i]</code>), <code>i=0,...,m_iPointNu</code>, are tour edges;</li>
<li><code>m_pTspPool</code>: pointer to class that implements memory pool.</li>
</ul>
<p>A substantial part of functionality of our application is implements in another class <code>CFlowNet</code> that was developed to solve a number of graph and network flow optimization problems. As discussion graph and network flow algorithms is not a goal of this manual, we will use functions from <code>CFlowNet</code> as black boxes briefly explaining their functionality and input and output parameters.</p>
<h2><a class="anchor" id="mipclTSP_constructors"></a>
Constructors and destructor</h2>
<p>The base <code>CTsp</code> constructor is presented below.</p>
<p></p>
<div class="fragment"><div class="line">CTsp::CTsp(<span class="keyword">const</span> <span class="keywordtype">char</span> *name): <a class="code" href="classCMIP.html">CMIP</a>(<span class="stringliteral">&quot;tsp&quot;</span>)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> k;</div><div class="line">        m_pTspPool=0;</div><div class="line">        m_pNet=0;</div><div class="line">        m_dpCoordX=0;</div><div class="line">        m_ipNextOnTour=0;</div><div class="line">        readPoints(name);</div><div class="line">        </div><div class="line">        k=m_iPointNum*MAX_DEGREE;</div><div class="line">        m_pNet= <span class="keyword">new</span> CFlowNet&lt;double&gt;(m_iPointNum+k,2*k,CFlowNet&lt;double&gt;::m_iUpCapMsk);</div><div class="line">        m_pNet-&gt;COMB_AND_CUT_getMem();</div><div class="line">        m_pTspPool = <span class="keyword">new</span> CTspPool(m_iPointNum);</div><div class="line">        setMIP();</div><div class="line">} <span class="comment">// end of CTsp::CTsp</span></div></div><!-- fragment --><p>In this base constructor, first, we initialize to zeroes a number of <code>CTsp</code> members. Next, we call the function <code>readPoints()</code> to read input data from the file which name is passed to the constructor as the value of its only argument <code>name</code>; this input data are stored in some <code>CTsp</code> members described earlier. Knowing the dimension of the TSP instance to be solved, we create two objects, one of class <code>CFlowNet}&lt;double}&gt;</code> and the other of class <code>CTspPool</code>; the former implements some network flow algorithms, while the latter implements functions for working with the cut pool. Before termination, the constructor calls the function <code>setMIP()</code> to build an initial truncated IP.</p>
<p>The clone constructor and the function <code>clone()</code> are presented in the listing below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">CTsp::CTsp(<span class="keyword">const</span> CTsp &amp;other, <span class="keywordtype">int</span> thread): <a class="code" href="classCMIP.html">CMIP</a>(other,thread)</div><div class="line">{</div><div class="line">        m_enType=other.m_enType;</div><div class="line">        m_iPointNum=other.m_iPointNum;</div><div class="line">        m_dpCoordX=other.m_dpCoordX;</div><div class="line">        m_dpCoordY=other.m_dpCoordY;</div><div class="line">        m_dMaxDist=other.m_dMaxDist;</div><div class="line">        m_ipNextOnTour=other.m_ipNextOnTour;</div><div class="line">        m_pTspPool=other.m_pTspPool;</div><div class="line">        <span class="keywordtype">int</span> u=m_iPointNum*MAX_DEGREE;</div><div class="line">        m_pNet= <span class="keyword">new</span> CFlowNet&lt;double&gt;(m_iPointNum+u,2*u,CFlowNet&lt;double&gt;::m_iUpCapMsk);</div><div class="line">        m_pNet-&gt;COMB_AND_CUT_getMem();</div><div class="line">} <span class="comment">// end of CTsp::CTsp(const CTsp &amp;other, int thread)</span></div><div class="line"></div><div class="line"><a class="code" href="classCMIP.html">CMIP</a>* CTsp::clone(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread)</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;CMIP*&gt;(<span class="keyword">new</span> CTsp(*static_cast&lt;CTsp*&gt;(const_cast&lt;CMIP*&gt;(pMip)),thread));</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The clone constructor is needed only when developing a multithreaded application. In the clone constructor, we copy all the scalar members as well as all the pointers (with one exception) from the fields of the object to be cloned into corresponding fields of the newly created object. The only object that is not shared between two objects, existing and cloned, is <code>m_pNet</code>. We need this object to do some computations on the fly, and, therefore, the object do not permanently store any data. The function <code>clone()</code> in its essence is standard for all <b>MIPCL</b> applications.</p>
<p>The destructor</p>
<div class="fragment"><div class="line">CTsp::~CTsp()</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">        <span class="keywordflow">if</span> (!m_iThread) {</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">if</span> (m_dpCoordX) </div><div class="line">                <span class="keyword">delete</span>[] m_dpCoordX;</div><div class="line">        <span class="keywordflow">if</span> (m_ipNextOnTour)</div><div class="line">                <span class="keyword">delete</span>[] m_ipNextOnTour;</div><div class="line">        <span class="keywordflow">if</span> (m_pTspPool)</div><div class="line">                <span class="keyword">delete</span> m_pTspPool;</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">        }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">if</span> (m_pNet)</div><div class="line">                <span class="keyword">delete</span> m_pNet;</div><div class="line">} <span class="comment">// end of CTsp::~CTsp()</span></div></div><!-- fragment --><p>deletes all the objects created dynamically. Observe that all shared objects must be deleted only once by the thread with index <code>m_iThread=0</code>.</p>
<h2><a class="anchor" id="sec_mipclTSP_input"></a>
Input data</h2>
<p>We are going to develop an application that is able to solve test instances from the test library <a href="http://netlib.lucent.com/netlib/lp/data/index.html">tsplib</a>. In this library TSP instances are stored in files written in the <code>tsp</code>-format. This is a very simple format and we do not discuss it here. Looking through a few such files, you will easily understand this format. Therefore, we also do not discuss in details implementation of the <code>readPoints()</code> subroutine that reads the coordinates of cities from the file which name is passed as its input argument. <code>CTsp</code> stores these coordinates in two arrays <code>m_dpCoordX</code> and <code>m_dpCoordY</code>, both of size <em>n</em>=<code>m_iPointNum</code>: the pair (<code>m_dpCoordX[i],m_dpCoordY[i]</code>) represents coordinates of city <em>i</em>=1,...,<em>n</em>. Besides the coordinates, any input file stores an indicator that points out the way of computing intercity distances. We store this indicator in the class member <code>m_enType</code> of the enumeration <code>EDGE_WEIGHT_TYPE</code>.</p>
<p>The following function computes the distance between cities <code>i</code> and <code>j</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> CTsp::dist(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> d,dx,dy;</div><div class="line">        dx=m_dpCoordX[i]-m_dpCoordX[j];</div><div class="line">        dy=m_dpCoordY[i]-m_dpCoordY[j];</div><div class="line">        d=sqrt(dx*dx+dy*dy);</div><div class="line">        <span class="keywordflow">if</span> (m_enType==ATT) {</div><div class="line">                <span class="keywordtype">int</span> l;</div><div class="line">                <span class="keywordflow">if</span> ((l=static_cast&lt;int&gt;(floor(d))) &lt; d+1.0e-8)</div><div class="line">                        ++l;</div><div class="line">                d=l;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> d;</div><div class="line">} <span class="comment">// end of CTsp::dist</span></div></div><!-- fragment --><p>The member <code>m_dMaxDist</code> stores the maximum intercity distance increased by one. This value is used for computing objective coefficients of truncated IPs.</p>
<h2><a class="anchor" id="sec_mipclTSPinitProb"></a>
Truncated problem</h2>
<p>The procedure <code>setMIP()</code> formulates an initial truncated problem as it is described in Section <a class="el" href="tsp.html#sec_tspTruncatedMIP">Truncated problem</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::setMIP()</div><div class="line">{</div><div class="line">        approximate();</div><div class="line">        buildActiveGraph();</div><div class="line">        <span class="keywordtype">double</span> dpVal[2];</div><div class="line">        <span class="keywordtype">int</span> n=m_pNet-&gt;getVertNum(), m=m_pNet-&gt;getEdgeNum();</div><div class="line">        <span class="keywordtype">int</span> hd,ipRow[2];</div><div class="line">        openMatrix(n*3,m*2,m*10,<span class="keyword">true</span>,<span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i) {</div><div class="line">                addCtr(i | 0xE0000000,0,-INF,2.0);</div><div class="line">        }</div><div class="line">        dpVal[0]=dpVal[1]=1.0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> hd,j=0; j &lt; m; ++j) {</div><div class="line">                hd=(ipRow[0]=m_pNet-&gt;getTail(j)) &lt;&lt; 16;</div><div class="line">                hd|=(ipRow[1]=m_pNet-&gt;getHead(j));</div><div class="line">                addColumn(hd,VAR_BIN,m_dMaxDist-dist(ipRow[0],ipRow[1]),0.0,1.0,2,dpVal,ipRow);</div><div class="line">        }</div><div class="line">        preprocOff();</div><div class="line">        setScaling(SCL_NO);</div><div class="line">        closeMatrix();</div><div class="line">} <span class="comment">// end of CTsp::setMIP</span></div></div><!-- fragment --><p>First, <code>setMIP()</code> calls the function <code>approximate()</code> &mdash; which description is not given here &mdash; to find a salesman's tour which length if "close" to the minimum tour length. There exist a number of TSP heuristics (see. G.Reinelt. The traveling salesman. Computational solutions for TSP Applications. Springr-Verlag Berlin Heidelberg, 1994). We have implemented the simplest one that is known as "go to nearest" heuristic: starting a tour from a given initial city, the salesman leaves any city for the nearest to it city that has not been visited so far; after visiting all the cities, the salesman returns to the initial city. To get a better solution, <code>approximate()</code> applies the "go to nearest" heuristic <em>n</em> times (<em>n</em> denotes the number of cities) with different initial cities to find <em>n</em> approximate tours. The shortest of these <em>n</em> tours is stored in the array <code>m_ipNextOnTour</code> &mdash; the salesman goes from city <code>i</code> to city <code>m_ipRecTour[i]</code> &mdash; as the best (or record) solution, and its length is stored in <code>m_dTourLength</code>.</p>
<p>Next, <code>setMIP()</code> calls the function <code>buildActiveGraph()</code> that, according to the rules described in Section <a class="el" href="tsp.html#sec_tspTruncatedMIP">Truncated problem</a>, builds a graph on <em>n</em> vertices with an edge set composed of the edges stored in <code>m_ipNextOnTour</code> plus a fixed number of the shortest edges leaving each of <em>n</em> vertices.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::buildActiveGraph()</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> n,u,w,*ipDeg, *ipFlag;</div><div class="line">        n=m_iPointNum;</div><div class="line">        <span class="keywordflow">if</span> (!(ipDeg = <span class="keyword">new</span> <span class="keywordtype">int</span>[2*n])) {</div><div class="line">                <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="code" href="classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;CTsp::BuildActiveGraph&quot;</span>);</div><div class="line">        }</div><div class="line">        ipFlag=ipDeg+n;</div><div class="line">        m_pNet-&gt;setVertNum(n);</div><div class="line">        m_pNet-&gt;setEdgeNum(0);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=0; v &lt; n; ++v) {</div><div class="line">                ipDeg[v]=2;</div><div class="line">                m_pNet-&gt;addEdge(v,w=m_ipNextOnTour[v]);</div><div class="line">        }</div><div class="line">        <span class="keywordtype">int</span> e=m_iPointNum;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=0; v &lt; n; ++v) {</div><div class="line">                memset(ipFlag,0,m_iPointNum*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line">                ipFlag[v]=1;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; e; ++j) {</div><div class="line">                        w=m_pNet-&gt;getTail(j);</div><div class="line">                        u=m_pNet-&gt;getHead(j);</div><div class="line">                        <span class="keywordflow">if</span> (w == v)</div><div class="line">                                ipFlag[u]=1;</div><div class="line">                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u == v)</div><div class="line">                                ipFlag[w]=1;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">for</span> (; ipDeg[v] &lt; INIT_DEGREE; ++e) {</div><div class="line">                        <span class="keywordtype">double</span> q,d=std::numeric_limits&lt;double&gt;::max();</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i) {</div><div class="line">                                <span class="keywordflow">if</span> (!ipFlag[i])</div><div class="line">                                        <span class="keywordflow">if</span> (d &gt; (q=dist(v,i))) {</div><div class="line">                                                d=q; w=i;</div><div class="line">                                        }</div><div class="line">                        }</div><div class="line">                        ipFlag[w]=1;</div><div class="line">                        ++ipDeg[v]; ++ipDeg[w];</div><div class="line">                        m_pNet-&gt;addEdge(v,w);</div><div class="line">                }</div><div class="line">        }</div><div class="line">        m_pNet-&gt;buildEdgeList();</div><div class="line">        <span class="keyword">delete</span>[] ipDeg;</div><div class="line">}  <span class="comment">// end of CTsp::buildActiveGraph</span></div></div><!-- fragment --><p><code>buildActiveGraph()</code> uses a number of functions from <code>CFlowNet</code>:</p><ul>
<li><code>setVertNum(n)</code> and <code>setEdgeNum(m)</code> set, respectively, number of vertices to <code>n</code>, and number of edges to <code>m</code>;</li>
<li><code>setMask()</code> specifies that each edge is assigned one numeric parameter, edge capacity;</li>
<li><code>GrGetMem(n,m)</code> allocates memory for graph with <code>n</code> vertices and <code>m</code> edges;</li>
<li><code>addEdge(v,w)</code> adds edge <code>(v,w)</code>;</li>
<li><code>getTail(e)</code> and <code>getHead(e)</code> return, respectively, tail and head vertices of edge <code>e</code>;</li>
<li><code>COMB_AND_CUT_getMem()</code> allocates and then distributes memory needed for algorithms of finding minimum cuts and simple combs.</li>
<li><code>buildEdgeList()</code>, for each vertex, builds a list of adjacent edges.</li>
</ul>
<p>Let us return back to the procedure <code>setMIP()</code>. After calling <code>buildActiveGraph()</code>, we then open the matrix specifying the maximum numbers of rows, <code>3n</code>, columns, <code>2m</code>, and nonzero entries , <code>10m</code>. This time, we also specify that rows and columns will be generated (two last parameters are <code>true</code>).</p>
<p>Next, we proceed to building the constraints (3.b). First, we add rows, one per vertex. The handle of row indexed by <code>e</code> is the bit-wise OR of <code>e</code> and <code>0xE0000000</code>. Note, that these handles are never used. Next, we add columns that correspond to edges of the active graph. Each such column has only two nonzero entries, both equal to 1, in the rows <code>v</code> and <code>w</code>, where <code>(v,w)</code> is the edge that corresponds to the edge being added; the handle of the column represents the edge <code>(v,w)</code>: its low half-word stores <code>v</code> and high half-word stores <code>w</code>.</p>
<h2><a class="anchor" id="sec_mipclTSPcutPool"></a>
Cut pool</h2>
<p>A <em>cut pool</em> is a storage for cuts. Cut pools are present in almost any of the known branch-and-cut implementations because relaxation LPs at different nodes of the search tree are described by different sets of inequalities, which are to be stored somewhere. <b>MIPCL</b> supports its own cut pool accomplishing all the pool operations (such as adding, extracting, and deleting cuts, reallocating memory, and so on). In <b>MIPCL</b>-pool, any inequality is stored as a list of its nonzero entries. In those cases when there exists a less memory consuming way of storing inequalities, it may be preferable to implement a pool that takes into account problem specifics.</p>
<p>Most of the known TSP cuts can be written in the form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tag{9} \sum_{i=1}^h x(H_i) + \sum_{j=1}^t x(T_j) \le \beta, \]" src="form_262.png"/>
</p>
<p> where <img class="formulaInl" alt="$H_1,\dots,H_h\text{ and } T_1,\dots,T_t$" src="form_263.png"/> are, respectively, handles and teeth of a <em>comb</em>. Let us remember, that handles (resp., teeth) are pairwise disjoint sets; therefore, each vertex may belong to at most one handle and one tooth. As a consequence, any coefficient in inequality (9) may take only three values, 0, 1, and 2. In general, an inequality of type (9) can have <img class="formulaInl" alt="$O(n^2)$" src="form_264.png"/> nonzero coefficients. But we can store these inequalities more efficiently assigning an array of <em>n</em> integers per inequality: when an element <em>v</em> of this array stores the following information: its low half-word stores <em>i</em> if vertex <em>v</em> belong to some set <img class="formulaInl" alt="$H_i$" src="form_265.png"/>, or 0 otherwise; its high half-word stores <em>j</em> if vertex <em>v</em> belongs to some set <img class="formulaInl" alt="$T_j$" src="form_266.png"/>, or 0 otherwise.</p>
<p>In <code>CTsp</code>, the cut pool is represented as an object <code>m_pTspPool</code> of the class <code>CTspPool</code> which is defined as follows.</p>
<p></p>
<p><a class="anchor" id="tagPoolEntry"></a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread_8h.html">thread.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>tagPoolEntry {</div><div class="line">    <span class="keywordtype">int</span> state; <span class="comment">// number of node LPs that use this constraint</span></div><div class="line">        <span class="keywordtype">int</span> ct; <span class="comment">// number of active nodes using this cut</span></div><div class="line">        <span class="keywordtype">int</span> b;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>CTspPool {</div><div class="line">        <span class="keywordtype">int</span> m_iPointNum, m_iPoolSize, m_iMaxPoolSize, m_iFirstFreeInPool; <span class="comment">// describe the state of the pool</span></div><div class="line">        tagPoolEntry* m_pEntry; <span class="comment">// pool for storing cuts</span></div><div class="line">        <span class="keywordtype">int</span>* m_ipBuf; <span class="comment">// memory buffer for storing cut coefficients</span></div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">        <a class="code" href="thread_8h.html#aafaf2b420929d82222f1ac18803acc8c">_RWLOCK</a> m_rwLock;</div><div class="line">        <a class="code" href="thread_8h.html#a70f4cef07991c3eff066e0b23c27dd11">_MUTEX</a> *m_pMemMutex;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">        CTspPool(<span class="keywordtype">int</span> ptNum);</div><div class="line">        ~CTspPool();</div><div class="line">        <span class="keywordtype">void</span> allocMem();</div><div class="line">        <span class="keywordtype">void</span> reallocMem();</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">int</span> getCoefficient(<span class="keywordtype">int</span> yv, <span class="keywordtype">int</span> yw);</div><div class="line">        <span class="keywordtype">int</span> addCut(<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> *ipComb);</div><div class="line">        <span class="keywordtype">void</span> freeNotUsedCuts();</div><div class="line"></div><div class="line">        <span class="keywordtype">int</span> buildRow(<span class="keywordtype">int</span> hd, <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> *ipColHd, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipCol, <span class="keywordtype">double</span> &amp;rhs);</div><div class="line">        <span class="keywordtype">int</span> buildColumn(<span class="keywordtype">int</span> v, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">int</span>* ipRowHd, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipRow);</div><div class="line"></div><div class="line">        <span class="keywordtype">int</span> getNextCut(<span class="keywordtype">int</span> thread, <span class="keywordtype">int</span> &amp;hd, <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> <span class="keywordtype">int</span>* ipColHd,</div><div class="line">                        <span class="keywordtype">int</span> *ipCol, <span class="keywordtype">double</span> *dpVal, <span class="keywordtype">double</span> &amp;rhs);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> markCtr(<span class="keywordtype">int</span> hd, <span class="keywordtype">int</span> thread)</div><div class="line">                {m_pEntry[hd].state|= 1 &lt;&lt; thread;}</div><div class="line">        <span class="keywordtype">void</span> unmarkCtr(<span class="keywordtype">int</span> hd, <span class="keywordtype">int</span> thread)</div><div class="line">                {m_pEntry[hd].state&amp;=~(1 &lt;&lt; thread);}</div><div class="line">        </div><div class="line">        <span class="keywordtype">void</span> lockCtr(<span class="keywordtype">int</span> hd)</div><div class="line">        {</div><div class="line">                <a class="code" href="thread_8h.html#a4e605baf1cd403d87e1247a8eb537fa8">_RWLOCK_WRLOCK</a>(&amp;m_rwLock)</div><div class="line">                ++m_pEntry[hd].ct;</div><div class="line">                <a class="code" href="thread_8h.html#ab5832f1e1c85f91a410a45e7fc408967">_RWLOCK_UNLOCK_WRLOCK</a>(&amp;m_rwLock)</div><div class="line">        }</div><div class="line">        <span class="keywordtype">void</span> unlockCtr(<span class="keywordtype">int</span> hd)</div><div class="line">        {</div><div class="line">                <a class="code" href="thread_8h.html#a4e605baf1cd403d87e1247a8eb537fa8">_RWLOCK_WRLOCK</a>(&amp;m_rwLock)</div><div class="line">                --m_pEntry[hd].ct;</div><div class="line">                <a class="code" href="thread_8h.html#ab5832f1e1c85f91a410a45e7fc408967">_RWLOCK_UNLOCK_WRLOCK</a>(&amp;m_rwLock)</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordtype">void</span> wrLockPool()</div><div class="line">                {<a class="code" href="thread_8h.html#a4e605baf1cd403d87e1247a8eb537fa8">_RWLOCK_WRLOCK</a>(&amp;m_rwLock)}</div><div class="line">                </div><div class="line">        <span class="keywordtype">void</span> wrUnlockPool()</div><div class="line">                {<a class="code" href="thread_8h.html#ab5832f1e1c85f91a410a45e7fc408967">_RWLOCK_UNLOCK_WRLOCK</a>(&amp;m_rwLock)}</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> rdUnlockPool()</div><div class="line">                {<a class="code" href="thread_8h.html#ab4dd3e1ee87df31a4e2ee05aa391a2a8">_RWLOCK_UNLOCK_RDLOCK</a>(&amp;m_rwLock)}</div><div class="line"></div><div class="line">        <span class="keywordtype">int</span>* getBufPtr()</div><div class="line">                {<span class="keywordflow">return</span> m_ipBuf;}</div><div class="line"></div><div class="line">}; <span class="comment">//========================================</span></div></div><!-- fragment --><p>As a storage, the pool is represented by two arrays:</p>
<p><code>m_pEntry</code>: array of size <code>m_iMaxPoolSize</code> which elements are records of type <code>tagPoolEntry</code>; <code>m_ipBuf</code>: array of integers of size <code>m_iMaxPoolSize*n</code>, where <code>n=m_iPointNum</code>.</p>
<p>An inequality <img class="formulaInl" alt="$\sum_{i=1}^n\sum_{j=1}^n \alpha_{ij} x_{ij}\le\beta$" src="form_267.png"/> with a handle <code>hd</code> is stored as follows: <img class="formulaInl" alt="$\tt{m_pPool[hd].b} = \beta$" src="form_268.png"/> and its left hand side is written (in a packed way) into the array <code>m_ipBuff</code> starting from the position <code>hd*n</code>. The coefficient <img class="formulaInl" alt="$\alpha_{ij}$" src="form_269.png"/> is computed by the function <code>getCoefficient(y[i],y[j])</code>, where <code>y=m_pBuff+hd*n</code>.</p>
<p></p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTspPool::getCoefficient(<span class="keywordtype">int</span> yv, <span class="keywordtype">int</span> yw)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> s1,s2,l=0;</div><div class="line">        s1=yv &amp; 0x0000FFFF;</div><div class="line">        s2=yw &amp; 0x0000FFFF;</div><div class="line">        <span class="keywordflow">if</span> (s1 &amp;&amp; (s1==s2))</div><div class="line">                l++;</div><div class="line">        s1=yv &gt;&gt; 16;</div><div class="line">        s2=yw &gt;&gt; 16;</div><div class="line">        <span class="keywordflow">if</span> (s1 &amp;&amp; (s1==s2))</div><div class="line">                l++;</div><div class="line">        <span class="keywordflow">return</span> l;</div><div class="line">} <span class="comment">// end of Ctsp::getCoefficient</span></div></div><!-- fragment --><p>Two parameters control how cuts are added to and deleted from the pool:</p><ul>
<li><code>m_iPoolSize</code>: last occupied pool position;</li>
<li><code>m_iFirstFree</code>: first free pool position.</li>
</ul>
<p>If <code>m_iFirstFree &lt; 0</code>, then the number of inequalities in the pool is <code>m_iPoolSize</code>, and the first free pool position is <code>m_iPoolSize</code>. A positive value of <code>q1=m_iFirstFree</code> points to the starting position of a linked list of free pool positions which indices are less than <code>m_iPoolSize</code>. More precisely, the first free poo; position is <code>m_pPool[q1]</code>, and, if <code>q2=m_pPool[m_iFirstFree].ct &gt; 0</code>, then the second free pool position is <code>m_pPool[q2]</code>; if <code>q3=m_pPool[q2].ct &gt; 0</code>, then the third free pool position is <code>m_pPool[q3]</code>, and so on.</p>
<p>The following function adds new cuts to the pool.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTspPool::addCut(<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> *ipComb)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> hd;</div><div class="line">        <a class="code" href="thread_8h.html#a4e605baf1cd403d87e1247a8eb537fa8">_RWLOCK_WRLOCK</a>(&amp;m_rwLock)</div><div class="line">        <span class="keywordflow">if</span> (m_iFirstFreeInPool &lt; 0) {</div><div class="line">                <span class="keywordflow">if</span> (m_iPoolSize &gt;= m_iMaxPoolSize) {</div><div class="line">                        freeNotUsedCuts();</div><div class="line">                        <span class="keywordflow">if</span> (m_iFirstFreeInPool &lt; 0)</div><div class="line">                                reallocMem();</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (m_iFirstFreeInPool &lt; 0)</div><div class="line">                hd=m_iPoolSize++;               </div><div class="line">        <span class="keywordflow">else</span>  {</div><div class="line">                hd=m_iFirstFreeInPool;</div><div class="line">                m_iFirstFreeInPool=m_pEntry[hd].ct;</div><div class="line">        }</div><div class="line">        m_pEntry[hd].state=0;</div><div class="line">        m_pEntry[hd].ct=1;</div><div class="line">        m_pEntry[hd].b=b;</div><div class="line">        memcpy(m_ipBuf+(hd*m_iPointNum),ipComb,m_iPointNum*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line">        <a class="code" href="thread_8h.html#ab5832f1e1c85f91a410a45e7fc408967">_RWLOCK_UNLOCK_WRLOCK</a>(&amp;m_rwLock)</div><div class="line">        <span class="keywordflow">return</span> hd;</div><div class="line">} <span class="comment">// end of CTspPool::addCut</span></div></div><!-- fragment --><p><code>addCut()</code> has two parameters:</p><ul>
<li><code>beta</code>: right hand side of comb inequality;</li>
<li><code>ipComb</code>: array of size <code>m_iPointNum</code> that describes comb.</li>
</ul>
<p>If the pool is full, <code>m_iPoolSize=m_iMaxPoolSize</code>, the function <code>freeNotUsedCuts()</code> is called to delete from the pool all inequalities that are not in use (those with the counter <code>ct</code> set to <code>0</code>).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTspPool::freeNotUsedCuts()</div><div class="line">{</div><div class="line">        tagPoolEntry *pEntry=m_pEntry;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; m_iMaxPoolSize; ++i, ++pEntry) {</div><div class="line">                <span class="keywordflow">if</span> (!pEntry-&gt;state &amp;&amp; !pEntry-&gt;ct) {</div><div class="line">                        pEntry-&gt;state=-1;</div><div class="line">                        pEntry-&gt;ct=m_iFirstFreeInPool;</div><div class="line">                        m_iFirstFreeInPool=i;</div><div class="line">                }</div><div class="line">        }</div><div class="line">} <span class="comment">// end of CTspPool::freeNotUsedCuts</span></div></div><!-- fragment --><p>If there is no unused inequality (we know this from the value of <code>m_iFirstFree</code>), <code>addCut()</code> calls `reallocMemForPool() (here its implementation is not discussed) to increase the size of the pool by one third of its current size.</p>
<p>Next, a free pool position <code>hd</code> is chosen to store the cut in <code>m_pPool[hd]</code>:</p><ol type="1">
<li>For newly stored cuts, the value of flag <code>state</code> is set to <code>0</code>. The purpose of this flag is twofold. First, when deleting the cut from the pool, we set <code>state to</code>-1<code>. The flag is also used in the separation routine</code>separateFromPool()` which is discussed later in Section <a class="el" href="tsp.html#sec_tspSepProc">Separation and cut generation</a>.</li>
<li>The value of the counter <code>ct</code> is set to <code>1</code>. The value of this counter is assumed to be the number of nodes of the search tree that use this inequality. If <code>ct=0</code>, then the inequality is not used by any node. For inequalities that where deleted from the pool (for which <code>state=-1</code>), the value of <code>ct</code> points to the next deleted inequality.</li>
<li>The comb inequality is stored : the right hand side <code>beta</code> is stored in the field <code>b</code>, and the array <code>ipComb</code> is moved into the pool buffer starting from the position <code>hd*m_iPointNum</code>.</li>
</ol>
<p>Now we proceed to describing functions that extract inequalities from the pool.</p>
<p>The procedure <code>buildRow()</code> extracts from the pool the inequality with a given handle <code>hd</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTspPool::buildRow(<span class="keywordtype">int</span> hd, <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> *ipColHd,</div><div class="line">                                   <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipCol, <span class="keywordtype">double</span> &amp;rhs)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> l,colHd, sz, *data;</div><div class="line">        <a class="code" href="thread_8h.html#a1cbdc3891ffe6ad48c956a5a93335d06">_RWLOCK_RDLOCK</a>(&amp;m_rwLock)</div><div class="line">        data=m_ipBuf+(hd*m_iPointNum);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=sz=0; i &lt; n; ++i) {</div><div class="line">                colHd=ipColHd[i];</div><div class="line">                <span class="keywordflow">if</span>  (l=getCoefficient(data[colHd &gt;&gt; 16],data[colHd &amp; 0x0000FFFF])) {</div><div class="line">                        dpVal[sz]=l;</div><div class="line">                        ipCol[sz++]=i;</div><div class="line">                }</div><div class="line">        }</div><div class="line">        rhs=m_pEntry[hd].b;</div><div class="line">        <a class="code" href="thread_8h.html#ab4dd3e1ee87df31a4e2ee05aa391a2a8">_RWLOCK_UNLOCK_RDLOCK</a>(&amp;m_rwLock)</div><div class="line">        <span class="keywordflow">return</span> sz;</div><div class="line">} <span class="comment">// end of CTspPool::buildRow</span></div></div><!-- fragment --><p>Its return value is the number of nonzero coefficients in the extracted inequality, and these coefficients are written into the arrays <code>dpVal</code> and <code>ipCol</code>: <code>dpVal[i]</code> is the coefficient in the column with index <code>ipCol[i]</code> and handle <code>ipColHd[ipCol[i]]</code>. Let us remember that the handle for variable <img class="formulaInl" alt="$x_{vw}$" src="form_270.png"/> is composed of two numbers, <em>v</em> and <em>w</em>, which are, respectively, written in the low and high half-words.</p>
<p>Although columns are not stored in the pool, we cannot restore the column that corresponds to a variable <img class="formulaInl" alt="$x_{vw}$" src="form_270.png"/> without using information stored in the pool.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTspPool::buildColumn(<span class="keywordtype">int</span> v, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">int</span>* ipRowHd,</div><div class="line">                                        <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipRow)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> l,*data,sz=2;</div><div class="line">        dpVal[0]=dpVal[1]=1.0;</div><div class="line">        ipRow[0]=v; ipRow[1]=w;</div><div class="line">        <a class="code" href="thread_8h.html#a1cbdc3891ffe6ad48c956a5a93335d06">_RWLOCK_RDLOCK</a>(&amp;m_rwLock)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=m_iPointNum; i &lt; m; ++i) {</div><div class="line">                <span class="keywordflow">if</span> ((l=ipRowHd[i]) &gt;= 0) {</div><div class="line">                        data=m_ipBuf+(l*m_iPointNum);</div><div class="line">                        <span class="keywordflow">if</span> (l=getCoefficient(data[v],data[w])) {</div><div class="line">                                dpVal[sz]=l;</div><div class="line">                                ipRow[sz++]=i;</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }       <span class="comment">// for (register int i=0;</span></div><div class="line">        <a class="code" href="thread_8h.html#ab4dd3e1ee87df31a4e2ee05aa391a2a8">_RWLOCK_UNLOCK_RDLOCK</a>(&amp;m_rwLock)</div><div class="line">        <span class="keywordflow">return</span> sz;</div><div class="line">} <span class="comment">// end of CTsp::buildColumn</span></div></div><!-- fragment --><p>The function <code>buildColumn()</code>, taking as the input two city indexes, <em>v</em> and <em>w</em>, and an array <code>ipRowHd</code> (of size <code>m</code>) of row handles, returns the number of nonzero entries in the column that corresponds to the variable <img class="formulaInl" alt="$x_{vw}$" src="form_270.png"/>; these nonzero entries are stored in the arrays <code>dpVal</code> and <code>ipRow</code>: <code>dpVal[i]</code> is the coefficient in the row indexed with <code>ipRow[i]</code> and having the handle <code>ipRowHd[ipRow[i]]</code>. We know that the column (for <img class="formulaInl" alt="$x_{vw}$" src="form_270.png"/>) contains two nonzero coefficients, both equal to <code>1</code>, in the rows indexed with <em>v</em> and <em>w</em>. Nonzero coefficients in other rows, with positive handles and indexed from <em>n</em> to <em>m</em>, are computed by the function <code>getCoefficient()</code> discussed earlier in this section. Let us remember that only inequalities from the pool have negative handles.</p>
<p>Now it is left to consider the last nontrivial function from <code>CTspPool</code>.</p>
<p><a class="anchor" id="getNextCut"></a> </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> CTspPool::getNextCut(<span class="keywordtype">int</span> thread, <span class="keywordtype">int</span> &amp;hd,</div><div class="line">                <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> <span class="keywordtype">int</span>* ipColHd,</div><div class="line">                <span class="keywordtype">int</span> *ipCol, <span class="keywordtype">double</span> *dpVal, <span class="keywordtype">double</span> &amp;rhs)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> w;</div><div class="line">        <span class="keywordtype">int</span> sz, colHd, a, *data;</div><div class="line">        tagPoolEntry *pEntry;</div><div class="line">        sz=0;</div><div class="line">        <a class="code" href="thread_8h.html#a1cbdc3891ffe6ad48c956a5a93335d06">_RWLOCK_RDLOCK</a>(&amp;m_rwLock)</div><div class="line">        data=m_ipBuf+(hd*m_iPointNum);</div><div class="line">        pEntry=m_pEntry+hd;</div><div class="line">        <span class="keywordflow">for</span> (; hd &lt; m_iPoolSize; ++hd, ++pEntry) {</div><div class="line">                <span class="keywordflow">if</span> (pEntry-&gt;state &gt;= 0 &amp;&amp; !(pEntry-&gt;state &amp; (1 &lt;&lt; thread))) {</div><div class="line">                        w=pEntry-&gt;b;</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e &lt; n; ++e) {</div><div class="line">                                colHd=ipColHd[e];</div><div class="line">                                a=getCoefficient(data[colHd &gt;&gt; 16],data[colHd &amp; 0x0000FFFF]);</div><div class="line">                                <span class="keywordflow">if</span> (a &gt; 0) {</div><div class="line">                                        w-=dpX[e]*(dpVal[sz]=a);</div><div class="line">                                        ipCol[sz++]=e;</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">if</span> (w &lt; -0.001) {</div><div class="line">                                rhs=pEntry-&gt;b;</div><div class="line">                                <span class="keywordflow">break</span>;</div><div class="line">                        }</div><div class="line">                        sz=0;</div><div class="line">                }</div><div class="line">                data+=m_iPointNum;</div><div class="line">        }</div><div class="line">        <a class="code" href="thread_8h.html#ab4dd3e1ee87df31a4e2ee05aa391a2a8">_RWLOCK_UNLOCK_RDLOCK</a>(&amp;m_rwLock)</div><div class="line">        <span class="keywordflow">return</span> sz;</div><div class="line">} <span class="comment">// end of CTspPool::getNextCut</span></div></div><!-- fragment --><p><code>getNextCut()</code> is used as an iterator in the function <code>separateFromPool()</code> (see Section <a class="el" href="tsp.html#sec_tspSepProc">Separation and cut generation</a>) from <code>CTsp</code>. The function traces the pool starting from the comb indexed with <code>start</code>. Processing a comb, <code>getNextCut()</code> writes into two arrays, <code>dpVal</code> and <code>ipCol</code>, the nonzero coefficients of the corresponding comb inequality. Simultaneously, the function computes the value by which this inequality is violated at the point written into the input array <code>dpX</code>. If the point violates the inequality by more than <code>0.001</code>, the function returns the number of coefficient in the violated inequality. The function returns <code>0</code> if it fails to find a violated inequality.</p>
<h2><a class="anchor" id="sec_tspMIPCLandPool"></a>
Interaction MIPCL with pool</h2>
<p>Processing a new node of the search tree starts with building the LP for this node. To get a constraint or column with a positive handle, <b>MIPCL</b> calls <code>getRow()</code> or <code>getColumn()</code>. For description of their parameters see descriptions of <code><a class="el" href="classCLP.html" title="This class has been designed for solving Linear Programs (LPs)">CLP</a>:getRow()</code> and <code><a class="el" href="classCLP.html#a75754fed56e5caa1755a72a8adab225e">CLP::getColumn()</a></code>.</p>
<p>In normal situations, both functions must return the <code>true</code> value, whereas the return value of <code>false</code> means that there is no row or column with given handle <code>hd</code>. As a rule, the latter means a failure of the program logic.</p>
<p>Implementation of <code>getRow()</code> and <code>getColumn()</code> is as follows.</p>
 </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> CTsp::getRow(tagHANDLE hd, <span class="keywordtype">int</span> n, <span class="keyword">const</span> tagHANDLE* ipColHd,</div><div class="line">                        <span class="keywordtype">int</span>&amp; type, <span class="keywordtype">double</span>&amp; b1, <span class="keywordtype">double</span>&amp; b2,</div><div class="line">                        <span class="keywordtype">int</span>&amp; sz, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipCol, <span class="keywordtype">bool</span> &amp;bScaled)</div><div class="line">{</div><div class="line">        type=CTR_INT;</div><div class="line">        b1=-INF;</div><div class="line">        sz=m_pTspPool-&gt;buildRow(hd,n,ipColHd,dpVal,ipCol,b2);</div><div class="line">        m_pTspPool-&gt;lockCtr(hd);</div><div class="line">        bScaled=<span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="comment">// end of CTsp::getRow()</span></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> CTsp::getColumn(tagHANDLE hd, <span class="keywordtype">int</span> m, <span class="keyword">const</span> tagHANDLE* ipRowHd,</div><div class="line">                <span class="keywordtype">int</span>&amp; type, <span class="keywordtype">double</span>&amp; cost, <span class="keywordtype">double</span>&amp; d1, <span class="keywordtype">double</span>&amp; d2,</div><div class="line">                <span class="keywordtype">int</span>&amp; sz, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipRow)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> v,w;</div><div class="line">        v=hd &amp; (0x0000FFFF);</div><div class="line">        w=hd &gt;&gt; 16;</div><div class="line">        d1=0.0; d2=1.0;</div><div class="line">        type=VAR_BIN;</div><div class="line">        cost=m_dMaxDist-dist(v,w);</div><div class="line"></div><div class="line">        dpVal[0]=dpVal[1]=1.0;</div><div class="line">        ipRow[0]=v; ipRow[1]=w;</div><div class="line">        sz=2;</div><div class="line"><span class="comment">//      sz=m_pTspPool-&gt;buildColumn(v,w,m,ipRowHd,dpVal,ipRow);</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="comment">// end of CTsp::getColumn()</span></div></div><!-- fragment --><p>In fact, <code>getRow()</code> solves its task calling the function <code>CTspPool::buildRow()</code>, and <code>getColumn()</code> does its job calling <code>CTspPool::buildColumn()</code>.</p>
<p>To mark that the constraint to be returned is active (used) for one more node, <code>getRow()</code> calls the function</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::lockCtr(tagHANDLE hd)</div><div class="line">        {m_pTspPool-&gt;lockCtr(hd);}</div></div><!-- fragment --><p>which overloads <code><a class="el" href="classCMIP.html#a85bd4129b916c2f5f6d3a8741ae3734d">CMIP::lockCtr()</a></code>. Our implementation of <code>lockCtr()</code> calls <code>CTspPool::lockCtr(hd)</code> to incrment the counter <code>ct</code> of the pool record indexed by <code>hd</code> (see <a class="el" href="tsp.html#tagPoolEntry">(definition of tagPoolEntry)</a>).</p>
<p>To support correct values of the fields <code>state</code> and <code>ct</code> in pool records, we have to overload the function <code><a class="el" href="classCMIP.html#a1f16e46d8cc9b738b0acd18bee6bcc7e">CMIP::unlockCtr()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::unlockCtr(tagHANDLE hd)</div><div class="line">        {m_pTspPool-&gt;unlockCtr(hd);}</div></div><!-- fragment --><p>Our implementation of <code>unlockCtr()</code> calls <code>CTspPool::unlockCtr(hd)</code> to decrement the counter <code>ct</code> of the pool record indexed by <code>hd</code>.</p>
<p>The functions, <code>lockCtr()</code> and <code>unlockCtr()</code>, are called just before processing of a search tree node is over. As we do not store columns in the pool, we do not need to overload other to functions <code><a class="el" href="classCMIP.html#ab13082b9c5de8ce176ce626b9d8853b7">CMIP::lockColumn()</a></code> and <code><a class="el" href="classCMIP.html#a2f03143ca1246848919bb567b0bd1ec4">CMIP::unlockColumn()</a></code>.</p>
<h2><a class="anchor" id="sec_tspSepProc"></a>
Separation and cut generation</h2>
<p>Let us remember that separation routines for those families of inequalities that are part of the problem formulation as well as cut generation routines for strong cut families are to be called within <code>separate()</code>, which overloads <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">CLP::separate()</a></code>.</p>
<p>Our implementation of <code>separate()</code> is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CTsp::separate(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd, <span class="keywordtype">bool</span> bGenFlag)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> poolCuts=0, cutCuts=0;</div><div class="line">        <span class="keywordflow">if</span> (!(poolCuts=separateFromPool(n,dpX,ipColHd,bGenFlag))) {</div><div class="line">                buildSupportGraph(n,dpX,ipColHd);</div><div class="line">                cutCuts=cutSeparate(n,dpX,ipColHd,bGenFlag);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> (poolCuts+cutCuts &gt; 0)? <span class="keyword">true</span>: <span class="keyword">false</span>;</div><div class="line">} <span class="comment">// end of CTsp::separate()</span></div></div><!-- fragment --><p>First, <code>separate()</code> calls <code>separateFromPool()</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTsp::separateFromPool(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> <span class="keywordtype">int</span>* ipColHd,</div><div class="line">                                                        <span class="keywordtype">bool</span> bGenFlag)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> rhs;</div><div class="line">        <span class="keywordtype">int</span> sz, m, cutNum, thread;</div><div class="line">        cutNum=0;</div><div class="line">        thread=m_iThread;</div><div class="line">        m=m_iM;</div><div class="line">        m_pTspPool-&gt;wrLockPool();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=m_iM0; i &lt; m; ++i) {</div><div class="line">                <span class="keywordflow">if</span> (m_ipRowHd[i] &gt;= 0)</div><div class="line">                        m_pTspPool-&gt;markCtr(m_ipRowHd[i],thread);</div><div class="line">        }</div><div class="line">        m_pTspPool-&gt;wrUnlockPool();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> hd=0; sz= m_pTspPool-&gt;getNextCut(thread,hd,n,dpX,ipColHd,m_ipArray,m_dpArray,rhs); ++hd) {</div><div class="line">                ++cutNum;</div><div class="line">                <span class="keywordflow">if</span> (!bGenFlag)</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                safeAddCut(hd,CTR_INT,-INF,rhs,sz,m_dpArray,m_ipArray);</div><div class="line">                m_pTspPool-&gt;lockCtr(hd);</div><div class="line">        }</div><div class="line">        m_pTspPool-&gt;wrLockPool();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=m_iM0; i &lt; m; ++i) {</div><div class="line">                <span class="keywordflow">if</span> (m_ipRowHd[i] &gt;= 0)</div><div class="line">                        m_pTspPool-&gt;unmarkCtr(m_ipRowHd[i],thread);</div><div class="line">        }</div><div class="line">        m_pTspPool-&gt;wrUnlockPool();</div><div class="line">        <span class="keywordflow">return</span> cutNum;</div><div class="line">} <span class="comment">// end of CTsp::separateFromPool</span></div></div><!-- fragment --><p><code>separateFromPool()</code> is looking for violated cuts in the TSP pool. The function does its job by calling the iterator <a class="el" href="tsp.html#getNextCut">(CTspPool::getNextCut())</a> until the iterator fails to find any violated inequality.</p>
<p>If <code>separateFromPool()</code> has found at least one violated inequality, then we cease searching the cuts. This is the simplest strategy that allows us to avoid storing identical inequalities in the pool. Alternatively, before adding a cut to the pool, we would have to check whether this particular cut is in the pool which is a time consuming task if there are many cuts in the pool.</p>
<p>If there is no violated cut in the pool, <code>separate()</code> first calls <code>cutSeparate()</code> to separate with cut inequalities. <code>cutSeparate()</code> works with a support graph for a point <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/> written into the array <code>dpX</code>. The <em>support graph</em> is a subgraph of the <em>active graph</em> that is composed of the edges (<em>i,j</em>)$ for nonzero values <img class="formulaInl" alt="$\tilde{x}_{ij}$" src="form_271.png"/> (these edges are determined by the column handles of the active LP). The support graph is build with the procedure <code>buildSupportGraph()</code> which implementation is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::buildSupportGraph(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> tol=getIntTol();</div><div class="line">        <span class="keywordtype">int</span> hd;</div><div class="line">        m_pNet-&gt;reset(m_iPointNum);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e &lt; n; ++e)</div><div class="line">                <span class="keywordflow">if</span> (dpX[e] &gt; tol) {</div><div class="line">                        hd=(int)ipColHd[e];</div><div class="line">                        m_pNet-&gt;addEdge(hd &gt;&gt; 16,hd &amp; 0x0000FFFF,dpX[e]);</div><div class="line">                }</div><div class="line">        m_pNet-&gt;buildEdgeList();</div><div class="line">} <span class="comment">// end of CTsp::buildSupportGraph()</span></div></div><!-- fragment --><h3><a class="anchor" id="sec_tspCutIneqSep"></a>
Separation procedure for cut inequalities</h3>
<p>Our separation routine for cut inequalities is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTsp::cutSeparate(<span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd, <span class="keywordtype">bool</span> genFlag)</div><div class="line">{</div><div class="line">        m_pNet-&gt;MC_MinCut(VERY_BAD_CUT);</div><div class="line">        <span class="keywordtype">int</span>* ipCut=m_pNet-&gt;MC_getCut();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (m_pNet-&gt;MC_getCutValue() &gt; BAD_CUT)</div><div class="line">                <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (genFlag) {</div><div class="line">                <span class="keywordtype">double</span> w1,w2;</div><div class="line">                <span class="keywordtype">int</span> hd,k,n,b;</div><div class="line">                n=m_iPointNum;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=k=0; v &lt; n; ++v) {</div><div class="line">                        <span class="keywordflow">if</span> (ipCut[v])</div><div class="line">                                ++k;</div><div class="line">                }</div><div class="line">                w1=w2=-0.001;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=0; e &lt; varNum; ++e) {</div><div class="line">                        hd=static_cast&lt;int&gt;(ipColHd[e]);</div><div class="line">                        <span class="keywordflow">if</span> (ipCut[hd &gt;&gt; 16] == ipCut[hd &amp; 0x0000FFFF]) {</div><div class="line">                                <span class="keywordflow">if</span> (ipCut[hd &amp; 0x0000FFFF] == 1)</div><div class="line">                                        w1+=dpX[e];</div><div class="line">                                <span class="keywordflow">else</span></div><div class="line">                                        w2+=dpX[e];</div><div class="line">                        }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">if</span> (k &lt;= n-k) {</div><div class="line">                        <span class="keywordflow">if</span> (w1 &gt; (b=k-1))</div><div class="line">                                k=1;</div><div class="line">                        <span class="keywordflow">else</span> k=(w2 &gt; (b=n-k-1))? 0: -1;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> k=(w2 &gt; (b=n-k-1))? 0: -1;</div><div class="line">                <span class="keywordflow">if</span> (k &gt;= 0) {</div><div class="line">                        <span class="keywordflow">if</span> (!k) {</div><div class="line">                                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> v=0; v &lt; n; ++v)</div><div class="line">                                        ipCut[v]=1-ipCut[v];</div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e=k=0; e &lt; varNum; ++e) {</div><div class="line">                                hd=ipColHd[e];</div><div class="line">                                <span class="keywordflow">if</span>  (n=CTspPool::getCoefficient(ipCut[hd &gt;&gt; 16],ipCut[hd &amp; 0x0000FFFF])) {</div><div class="line">                                        m_dpArray[k]=n;</div><div class="line">                                        m_ipArray[k++]=e;</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                        hd=m_pTspPool-&gt;addCut(b,ipCut);</div><div class="line">                        safeAddCut(hd,CTR_INT,-INF,b,k,m_dpArray,m_ipArray);</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">} <span class="comment">// end of CTsp::cutSeparate()</span></div></div><!-- fragment --><p>The parameters of <code>cutSeparate()</code> are of the same meaning as the parameters of <code><a class="el" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">CLP::separate()</a></code>.</p>
<p>First, <code>cutSeparate()</code> calls <code>CFlowNet::MC_MinCut()</code> to find a minimum cut in the support graph. The only parameter passed to <code>MC_MinCut()</code> is to accelerate its running time: the procedure must terminate as soon as it finds a cut of value less than <code>VERY_BAD_CUT=1.5</code>. Next, <code>cutSeparate()</code> calls <code>CFlowNet::MC_getCut()</code> to get a pointer, <code>ipCut</code>, to an array of integers that describes the cut <img class="formulaInl" alt="$(S,V\setminus S)$" src="form_232.png"/> &mdash; <img class="formulaInl" alt="$i\in S$" src="form_272.png"/> if <code>ipCut[i] = 1</code> &mdash; computed by <code>MC_MinCut()</code>. The function <code>CFlowNet::MC_getCutValue()</code> returns the value of this cut. If this value is greater than <code>BAD_CUT=1.999</code>, then there is not any cut inequality that is violated more than by <code>0.001</code>.</p>
<p>Otherwise, we substitute <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/> into the inequalities </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{e\in E(S,S)} x_e &amp;\le |S|-1,\\ \sum_{e\in E(V\setminus S,V\setminus S)} x_e &amp;\le |V\setminus S|-1. \end{align*}" src="form_273.png"/>
</p>
<p> If only one of them is violated by <img class="formulaInl" alt="$\tilde{x}$" src="form_52.png"/>, then it is returned as a cut. If the tested point violates both inequalities, then we choose that one of them with the minimum number of nonzero entries. If this is the second inequality, the array <code>ipCut</code> is modified by the rule <code>ipCut[i]=1-ipCut[i]</code> which means substituting <em>S</em> for <img class="formulaInl" alt="$V\setminus S$" src="form_239.png"/>. When adding a cut inequality to the pool, we consider it as a blossom inequality without teeth.</p>
<h3><a class="anchor" id="sec_BlossomSeparate"></a>
Separation procedure for blossom inequalities</h3>
<p>If no violated cut inequality has been detected by <code>separate()</code>, <b>MIPCL</b> calls another function, <code><a class="el" href="classCMIP.html#a9827da8d0317a1f1b546ac3421790130">CMIP::genCut1()</a></code>, which is supposed to generate strong (usually facet defining) inequalities that are not part of a complete problem formulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CTsp::genCut1(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> blossomCuts=BLOSSOM_separate(n,dpX,ipColHd);</div><div class="line">        <span class="keywordflow">return</span> (blossomCuts &gt; 0)? <span class="keyword">true</span>: <span class="keyword">false</span>;</div><div class="line">} <span class="comment">// end of CTsp::separate()</span></div></div><!-- fragment --><p>Our implementation of <code>genCut1()</code> simply calls the function <code>BLOSSOM_separate()</code> to separate with blossom inequalities. If someone wants to write procedures that generate other strong cuts, <code>genCut1()</code> is the right place to call those procedures.</p>
<p>Separating for blossom inequalities is a time consuming task. But the separation problem for maximally violated blossom inequalities is solved much easier. Any blossom inequality may not be violated more than by <code>1/2</code>. A blossom inequality is said to be <em>maximally violated</em> at a given point if it is violated by exactly <code>1/2</code>. In <code>CFlowNet</code>, two blossom separation algorithms are implemented:</p><ul>
<li>an algorithm for finding maximally violated blossom inequalities ( L.Fleishner, E.Tardos. Separating maximally violated comb inequalities in planar graphs. <em>Math. Oper. Res.</em> <b>24</b> (1999) 130&ndash;148) is implemented in the procedure <code>maxBlossom()</code>,</li>
<li>and an algorithm for separating general blossom inequalities is implemented in the procedure <code>blossom()</code>.</li>
</ul>
<p>Both procedures may find many violated inequalities in one call; in this case, all combs are stored in a special data structure to significantly reduce memory consumption.</p>
<p><code>maxBlossom()</code> returns the number of combs found. We can get these combs calling the following function: </p><pre class="fragment">   void getMaxBlossom(int k, int &amp;hdSize, int &amp;thNum, int* &amp;ipComb);
</pre><p>Its parameters are:</p><ul>
<li><code>k</code>: comb index;</li>
<li><code>hdSize</code>: number of vertices in handle;</li>
<li><code>thNum</code>: number of teeth;</li>
<li><code>ipComb</code>: pointer to array of size <code>m_iVertNum=m_iPointNum</code>, describes returned comb.</li>
</ul>
<p><code>blossom()</code> does not return the number of blossom cuts found. Instead, to enumerate blossom inequalities, we implemented the iterator int getNextBlossom(int &amp;s, double tol, int &amp;hdSize, int* &amp;ipComb); Its first argument, <code>s</code>, is a comb index to start search with. Its second argument, <code>tol</code>, sets the value of violation tolerance: we are interested in those inequalities that are violated more then by <code>tol</code>. The function returns the number of teeth in the comb found. Two other parameters, <code>hdSize</code> and <code>ipComb</code>, have the same meaning as of the same name parameters of <code>getMaxBlossom()</code> have.</p>
<p>The function <code>BLOSSOM_separate()</code> presented below uses <code>CNetFlow::maxBlossom()</code> and <code>CNetFlow::blossom()</code> to generate blossom cuts.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> CTsp::BLOSSOM_separate(<span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> *ipComb;</div><div class="line">        <span class="keywordtype">int</span> k;</div><div class="line">        <span class="keywordflow">if</span> (k=m_pNet-&gt;maxBlossom()) {</div><div class="line">                <span class="keywordtype">int</span> hdSize, thNum;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; k; ++i) {</div><div class="line">                        m_pNet-&gt;getMaxBlossom(i,hdSize,thNum,ipComb);</div><div class="line">                        addCombCut(hdSize + thNum/2,ipComb, n,dpX,ipColHd);</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> { <span class="comment">// k=0</span></div><div class="line">                <span class="keywordtype">int</span> hdSize, thNum;</div><div class="line">                m_pNet-&gt;blossom();</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> s=1; thNum=m_pNet-&gt;getNextBlossom(s,0.001,hdSize,ipComb);) {</div><div class="line">                        addCombCut(hdSize + thNum/2,ipComb, n,dpX,ipColHd);</div><div class="line">                        ++k;</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> k;</div><div class="line">} <span class="comment">// end of CTsp::BLOSSOM_separate()</span></div></div><!-- fragment --><p>To minimize its running time, we implemented a simple strategy: while <code>maxBlossom()</code> &mdash; which is fast &mdash; succeeds in finding violated inequalities, <code>blossom() --- which is substantially slower --- is not called. </code>BLOSSOM_separate()` uses the next auxiliary procedure:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::addCombCut(<span class="keywordtype">int</span> b, <span class="keywordtype">int</span>* ipComb,</div><div class="line">                        <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> b0;</div><div class="line">        <span class="keywordtype">int</span> hd=m_pTspPool-&gt;addCut(b,ipComb);</div><div class="line">        <span class="keywordtype">int</span> sz=m_pTspPool-&gt;buildRow(hd,n,ipColHd,m_dpArray,m_ipArray,b0);</div><div class="line">        safeAddCut(hd,0,-INF,b0,sz,m_dpArray,m_ipArray);</div><div class="line">} <span class="comment">// end of CTsp::addCombCut()</span></div></div><!-- fragment --><p><code>addCombCut()</code> first adds to the pool the comb and the right hand side of the cut being added, and then calls <code>CTspPool::buildRow()</code> to build the <b>MIPCL</b> representation of this inequality and add it to the matrix.</p>
<h2><a class="anchor" id="sec_tspColGen"></a>
Generating columns</h2>
<p>Since there are only $n(n-1)/2$ columns, the pricing problem can be solved simply by enumeration of all columns. The procedure <code>generateColumns()</code> is implemented as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CTsp::generateColumns(<span class="keywordtype">int</span> m, <span class="keyword">const</span> tagHANDLE* ipRowHd, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpY)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> redCost,cost, bestRedCost,cq;</div><div class="line">        <span class="keywordtype">int</span> q,sz,num=0;</div><div class="line">        buildSupportGraph();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i &lt; m_iPointNum; ++i) {</div><div class="line">                bestRedCost=0.01; <span class="comment">// GetRedCostTol();</span></div><div class="line">                q=-1;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; i; ++j) {</div><div class="line">                        <span class="keywordflow">if</span> (m_pNet-&gt;getEdgeNo(i,j) &lt; 0) {</div><div class="line">                                sz=m_pTspPool-&gt;buildColumn(i,j,m,ipRowHd,m_dpArray,m_ipArray);</div><div class="line">                                redCost=(cost = m_dMaxDist-dist(i,j));</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k &lt; sz; ++k) </div><div class="line">                                        redCost-=m_dpArray[k]*dpY[m_ipArray[k]];</div><div class="line">                                <span class="keywordflow">if</span> (redCost &gt; bestRedCost) {</div><div class="line">                                        q=j;</div><div class="line">                                        bestRedCost=redCost;</div><div class="line">                                        cq=cost;</div><div class="line">                                }       <span class="comment">// if (RedCost &gt; BestRedCost)</span></div><div class="line">                        }       <span class="comment">// if (m_pNet-&gt;GetEdgeNo(i,j) == NIL)</span></div><div class="line">                }  <span class="comment">// for (int j=i+1; ...</span></div><div class="line">                <span class="keywordflow">if</span> (q &gt;= 0) {</div><div class="line">                        sz=m_pTspPool-&gt;buildColumn(i,q,m,ipRowHd,m_dpArray,m_ipArray);</div><div class="line">                        addNewColumn((i&lt;&lt;16) | q,VAR_BIN,cq,0.0,1.0,</div><div class="line">                    sz,m_dpArray,m_ipArray,<span class="keyword">false</span>,<span class="keyword">false</span>,0,<span class="keyword">true</span>);</div><div class="line">                        ++num;</div><div class="line">                }       <span class="comment">// if (BestRedCost &gt; TolDual)</span></div><div class="line">        }  <span class="comment">// for (int i=0;</span></div><div class="line">        <span class="keywordflow">return</span> (num)? <span class="keyword">true</span>: <span class="keyword">false</span>;</div><div class="line">}  <span class="comment">// end of CTsp::generateColumns()</span></div></div><!-- fragment --><p>First, <code>generateColumns()</code> calls the procedure</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::buildSupportGraph()</div><div class="line">{</div><div class="line">        m_pNet-&gt;reset(m_iPointNum);</div><div class="line">        <span class="keywordtype">int</span> hd,n=getVarNum();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i) {</div><div class="line">                hd=getVarHandle(i);</div><div class="line">                m_pNet-&gt;addEdge(hd &gt;&gt; 16,hd &amp; 0x0000FFFF);</div><div class="line">        }</div><div class="line">        m_pNet-&gt;buildEdgeList();</div><div class="line">}       <span class="comment">// end of CTsp::buildSupportGraph()</span></div></div><!-- fragment --><p>to build the support (or active) graph which is composed of the edges that are present in the truncated problem being solved. We need this graph to compute the reduced costs of those columns that are not in the matrix. Next, for any vertex, among the edges incident to the vertex and not present in the truncated problem being solved, we are looking for an edge that corresponds to a variable which reduced cost is minimum. If this reduced cost exceeds the reduced cost accuracy level (this value is returned by the function <code><a class="el" href="classCLP.html#a14a0519468aae3f041641948cf59aea2">CLP::getRedCostTol()</a></code>), then the column that corresponds to the selected edge is added to the matrix.</p>
<h2><a class="anchor" id="sec_TSPchangeRecord"></a>
Changing record</h2>
<p>Each time a new best solution is found, <b>MIPCL</b> calls the function <code>changeRecord()</code>, which overloads <code><a class="el" href="classCMIP.html#a911ab2e8695ccca2a10d6492df428d7c">CMIP::changeRecord()</a></code>, to store this best solution. We have overloaded this function in <code>CTsp</code> because it takes less memory to store a salesman's tour as a list of <code>m_iPointNum</code> cities while <b>MIPCL</b> would store the values of all the variables <img class="formulaInl" alt="$x_e$" src="form_19.png"/> most of which are zeroes. Our implementation of <code>changeRecord()</code> is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::changeRecord(<span class="keywordtype">double</span> dObjVal,</div><div class="line">                <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipHd)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> v,w;</div><div class="line">        <span class="keywordtype">int</span>* ipFirst=m_ipArray;</div><div class="line">        <span class="keywordtype">int</span>* ipSecond=reinterpret_cast&lt;int*&gt;(m_dpArray);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; m_iPointNum; ++i)</div><div class="line">                ipFirst[i]=ipSecond[i]=-1;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i) {</div><div class="line">                <span class="keywordflow">if</span> (dpX[i] &gt; 0.5) {</div><div class="line">                        v=ipHd[i] &gt;&gt; 16;</div><div class="line">                        w=ipHd[i] &amp; (0x0000FFFF);</div><div class="line">                        <span class="keywordflow">if</span> (ipFirst[v] &gt;= 0)</div><div class="line">                                ipSecond[v]=w;</div><div class="line">                        <span class="keywordflow">else</span> ipFirst[v]=w;</div><div class="line">                        <span class="keywordflow">if</span> (ipFirst[w] &gt;= 0)</div><div class="line">                                ipSecond[w]=v;</div><div class="line">                        <span class="keywordflow">else</span> ipFirst[w]=v;</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">for</span> (m_ipNextOnTour[w=0]=v=ipFirst[0]; v; v=m_ipNextOnTour[w=v])</div><div class="line">                m_ipNextOnTour[v]=(ipFirst[v] == w)? ipSecond[v]: ipFirst[v];</div><div class="line">} <span class="comment">// end of CTsp::changeRecord()</span></div></div><!-- fragment --><p>Let us remember that <b>MIPCL</b> represents solutions with two arrays, <code>dpX</code> and <code>ipHd</code>, both of size <em>n</em>, where <em>n</em> stands for the number of variables (in our case, number of edges). In our implementation of <code>changeRecord()</code>, we first list all the edges that compose the salesman tour represented in <code>dpX</code> and <code>ipHd</code>: if <code>dpX[i] &gt; 0.5</code> (since the solution is integer, then all nonzero values <code>dpX[i]</code> are closed to <code>1.0</code>), then the edge (<em>v,w</em>) encoded in the handle <code>ipHd[i]</code> is on the salesman tour. Next we fix one of two possible orientation of the tour found. Of course, we can arbitrarily assign a direction to any one tour edge. The direction of any other tour edge (<em>v,w</em>) is determined uniquely (it is left to the reader to explain how it is done). If the edge is passed in the direction from <em>v</em> to <em>w</em>, we set <code>m_ipNextOnTour[v]=w</code>, and, if the edge is passed in the direction from <em>w</em> to <em>v</em>, we set <code>m_ipNextOnTour[w]=v</code>.</p>
<h2><a class="anchor" id="sec_TSPsolve"></a>
Finding solution and printing result</h2>
<p>The function <code>solve()</code> uses <code>CTsp</code> to solve a TSP instance and then write the result to a text file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::solve()</div><div class="line">{</div><div class="line">        setAutoCutPattern(-1,-1);</div><div class="line">        changeObjBound(m_iPointNum*m_dMaxDist-m_dTourLength);</div><div class="line">        optimize();</div><div class="line">        m_dTourLength=m_dMaxDist*m_iPointNum-getObjVal();</div><div class="line">} <span class="comment">// end of CTsp::solve()</span></div></div><!-- fragment --><p>First, calling <code><a class="el" href="classCMIP.html#a8b241b19aabf10c7ceacb29e14c8dfec">CMIP::setAutoCutPattern()</a></code> with both arguments set to <code>-1</code>, we switch off generation of any cuts by <b>MIPCL</b> itself. Next, we call <code><a class="el" href="classCMIP.html#ab756898acb767ab51422d24daf075b96">CMIP::changeObjBound()</a></code> to set the lower bound (on the optimal objective value for the TSP IP) to <code>m_iPointNum*m_dMaxDist-m_dTourLength</code>. Then <code><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">CMIP::optimize()</a></code> is called to solve the IP. And, at the end, we compute the optimal tour length.</p>
<p>The function <code>printSolution()</code> print the tour stored in <code>m_ipNextOnTour</code> to the file which name is given as the only parameter of <code>printSolution()</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CTsp::printSolution(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> ct;</div><div class="line">        <span class="keywordtype">char</span> name[128];</div><div class="line">        <span class="keywordflow">if</span> (!fileName)</div><div class="line">                getProblemName(name);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                strcpy(name,fileName);</div><div class="line">        strcat(name,<span class="stringliteral">&quot;.sol&quot;</span>);</div><div class="line">        std::ofstream fout(name);</div><div class="line">        <span class="keywordflow">if</span> (!fout.is_open())</div><div class="line">                <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="code" href="classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;CTsp::printSolution&quot;</span>,name);</div><div class="line"></div><div class="line">        m_dTourLength=m_dMaxDist*m_iPointNum-getObjVal();</div><div class="line"></div><div class="line">        fout &lt;&lt; <span class="stringliteral">&quot;Length &quot;</span> &lt;&lt;  m_dTourLength &lt;&lt; std::endl;</div><div class="line">        fout &lt;&lt; <span class="stringliteral">&quot;Tour:\n&quot;</span>;</div><div class="line">        fout &lt;&lt; <span class="stringliteral">&quot;1, &quot;</span>;</div><div class="line">        ct=1;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=m_ipNextOnTour[0]; v != 0; v=m_ipNextOnTour[v]) {</div><div class="line">                fout &lt;&lt; v+1 &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">                <span class="keywordflow">if</span> (!(++ct % 10))</div><div class="line">                        fout &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        fout &lt;&lt; <span class="stringliteral">&quot;1\n&quot;</span>;</div><div class="line">        fout.close();</div><div class="line">} <span class="comment">// end of CTsp::printSolution()</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_TSPprogr"></a>
Program for solving TSPs</h2>
<p>The program that uses <code>CTsp</code> to solve TSP test instances from the test library <a href="http://netlib.lucent.com/netlib/lp/data/index.html">tsplib</a> is given below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="except_8h.html">except.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;tsp.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Enter file name!\n&quot;</span>;</div><div class="line">                <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">                CTsp gr(argv[1]);</div><div class="line">                gr.solve();</div><div class="line">                gr.printSolution(argv[1]);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span>(<a class="code" href="classCException.html">CException</a>* pe) {</div><div class="line">                std::cerr &lt;&lt; pe-&gt;<a class="code" href="classCException.html#af66e5406dda297fa8b253e89b6e00973">what</a>() &lt;&lt; std::endl;</div><div class="line">                <span class="keyword">delete</span> pe;</div><div class="line">                <span class="keywordflow">return</span> 2;</div><div class="line">        }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>To compile this program, enter the following commands: </p><pre class="fragment"> cd `$MIPCLDIR/examples/mipcl/tsp/multithreaded
 make
 make install
</pre><p>Some tests from <b>tsplib</b> are in the following directory: </p><pre class="fragment"> $MIPCLDIR/examples/tsp/tests
</pre><p>To solve an TSP instance from this directory, say <code>a280.tsp</code>, enter the following commands: </p><pre class="fragment"> cd $MIPCLDIR/examples/tsp/tests
 $MIPCLDIR/examples/bin/tsp a280.tsp
</pre><p>The result will be written to the file <code>a280.tsp.sol</code>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:34 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
