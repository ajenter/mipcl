<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPCL: Scheduling one machine (User Branching)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIPCLlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPCL
   &#160;<span id="projectnumber">2.6</span>
   </div>
   <div id="projectbrief">Mixed Integer Programming Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Scheduling one machine (User Branching) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_mipclMSched"></a>
Scheduling one machine</h1>
<p>There are <em>n</em> jobs (or tasks), numbered 1,...,n, to be processed on one machine. For each job <em>j</em> we know its <em>processing time</em>, <img class="formulaInl" alt="$p_j$" src="form_118.png"/> (it takes the machine <img class="formulaInl" alt="$p_j$" src="form_118.png"/> units of time to process job <em>j</em>), <em>release date</em> <img class="formulaInl" alt="$r_j$" src="form_119.png"/> (job is only available for processing at time <img class="formulaInl" alt="$r_j$" src="form_119.png"/> or later), <em>due date</em> <img class="formulaInl" alt="$d_j$" src="form_120.png"/> by which the job must be completed, <em>weight</em> <img class="formulaInl" alt="$w_j$" src="form_121.png"/>. The problem is to find a schedule that maximizes the <em>weighted sum of processed jobs</em> (it is allowed that some jobs may not be processed). For a given schedule, let <img class="formulaInl" alt="$U_j=0$" src="form_122.png"/> if job <em>j</em> is processed until its due date, and <img class="formulaInl" alt="$U_j=1$" src="form_123.png"/> otherwise. The objective is to minimize <img class="formulaInl" alt="$\sum_{j=1}^n w_j U_j$" src="form_124.png"/>, or, equivalently, to maximize <img class="formulaInl" alt="$\sum_{j=1}^n w_j(1-U_j)$" src="form_125.png"/>. In the traditional scheduling notation, this problem is denoted as <img class="formulaInl" alt="$1|r_j,d_j|\sum w_jU_j$" src="form_126.png"/>.</p>
<h2><a class="anchor" id="sec_machineSchedMIP"></a>
MIP formulation</h2>
<p>A standard formulation for <img class="formulaInl" alt="$1|r_j,d_j|\sum w_jU_j$" src="form_126.png"/> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{j=1}^n w_j x_j \to \max,\tag{1.a}\\ r_j \le s_j \le d_j -p_j\,, &amp;\quad j=1,\dots,n,\tag{1.b}\\ s_j - s_i - My_{ij} \ge -M+p_i,&amp;\quad i,j=1,\dots,n,\; i\neq j,\tag{1.c}\\ y_{ij} + y_{ji} - x_j \le 0,&amp;\quad i,j=1,\dots,n,\; i\neq j,\tag{1.d}\\ x_i + x_j -y_{ij} - y_{ji}\le 1,&amp;\quad i=1,\dots,j-1,\; j=2,\dots,n,\tag{1.f}\\ x_j \in \{0,1\},&amp;\quad j=1,\dots,n,\tag{1.g}\\ y_{ij} \in \{0,1\},&amp;\quad i,j=1,\dots,n,\; i\neq j,\tag{1.h} \end{align*}" src="form_127.png"/>
</p>
<p> is written in the following variables:</p><ul>
<li><img class="formulaInl" alt="$s_j$" src="form_128.png"/>: start time of job <em>j</em>;</li>
<li><img class="formulaInl" alt="$x_j=1$" src="form_129.png"/> if job <em>j</em> is processed, and <img class="formulaInl" alt="$x_j=0$" src="form_130.png"/> otherwise;</li>
<li><img class="formulaInl" alt="$y_{ij}=1$" src="form_131.png"/> if job <em>i</em> is processed before job <em>j</em>, and <img class="formulaInl" alt="$y_{ij}=0$" src="form_132.png"/> otherwise.</li>
</ul>
<p>As it commonly accepted in linear programming, we denote by <em>M</em> a sufficiently big number, say, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[M=\max_{1\le j\le n} d_j - \min_{1\le j\le n} r_j\,.\]" src="form_133.png"/>
</p>
<p>The inequalities (1.b) force all the jobs be processed in the prescribed terms. The inequality (1.c) is a real constraint only if <img class="formulaInl" alt="$y_{ij}=1$" src="form_131.png"/>; then it turns into the inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[s_j \ge s_i + p_i,\]" src="form_134.png"/>
</p>
<p> which means that processing of job <em>j</em> starts when processing job <em>i</em> is over. It follows from the inequality (1.d) that, if at least one of the jobs <em>i</em> or <em>j</em> is not processed ( <img class="formulaInl" alt="$x_i=0\text{ or }x_j=0$" src="form_135.png"/>), then both variables <img class="formulaInl" alt="$y_{ij}$" src="form_136.png"/> and <img class="formulaInl" alt="$y_{ji}$" src="form_137.png"/> take zero values. Finally, together the inequalities (1.d) and (1.f) express the fact that, if both jobs <em>i</em> and <em>j</em> are processed ( <img class="formulaInl" alt="$x_i=x_j=1$" src="form_138.png"/>), then one of these jobs must precede the other one ( <img class="formulaInl" alt="$y_{ij}+y_{ji}=1$" src="form_139.png"/>).</p>
<h3><a class="anchor" id="sec_oneMachineSchedIncompl"></a>
Incomplete formulation</h3>
<p>As a rule, formulations with big $M$ are week. Formulation (1) is not an exception to the rule. For sufficiently big <em>M</em>, the relaxation LP for problem (1) has a solution <img class="formulaInl" alt="$(s^*,x^*,y^*)$" src="form_140.png"/> such that <img class="formulaInl" alt="$x^*_j=1,\; s^*_j=r_j\text{ for } j=1,\dots,n$" src="form_141.png"/>, and all <img class="formulaInl" alt="$y^*_{ij}=1/2$" src="form_142.png"/>. It turns out that we have introduced a huge number &mdash; even for problems of middle size &mdash; of variables <img class="formulaInl" alt="$y_{ij}$" src="form_136.png"/> just to branch on them. When branching by <img class="formulaInl" alt="$y_{ij}$" src="form_136.png"/>, for branch <img class="formulaInl" alt="$y_{ij}=1$" src="form_131.png"/>, we transform the week inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[s_j - s_i - My_{ij} \ge -M+p_i\]" src="form_143.png"/>
</p>
<p> into strong inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[s_j \ge s_i + p_i\,.\]" src="form_144.png"/>
</p>
<p> Similarly, for branch <img class="formulaInl" alt="$y_{ij}=0$" src="form_132.png"/>, the week inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[s_i - s_j - My_{ji} \ge -M+p_j\]" src="form_145.png"/>
</p>
<p> is transformed into strong inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[s_i \ge s_j + p_j\,.\]" src="form_146.png"/>
</p>
<p>We will proceed differently and eliminate all the variables <img class="formulaInl" alt="$y_{ij}$" src="form_136.png"/> from formulation (1) going over to the following formulation:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{j=1}^n w_j\, x_j &amp;\to \max,\tag{2.a}\\ r_j \:\le\: s_j &amp;\le d_j-p_j,\quad j=1,\dots,n,\tag{2.b}\\ \sum_{j=1}^n p_j\, x_j &amp;\le \max_{1\le j\le n} d_j - \min_{1\le j\le n} r_j,\tag{2.c}\\ x_j &amp;\in \{0,1\},\quad j=1,\dots,n,\tag{2.d} \end{align*}" src="form_147.png"/>
</p>
<p> which is <em>incomplete</em> what means that not each its feasible solutions corresponds to a schedule. Let us also note that using incomplete formulations is not typical for MIP; but for a concurrent technology, named constraint programming (CP), this is a norm. In CP infeasible solutions are eliminated during branching (labeling).</p>
<p>Formulation (2) (as well as (1)) can be substantially strengthened by appending the following inequalities </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{k\in S_{ij}} p^{ij}_k x_k \le d_j - r_i\,,\quad i,j\in \{1,\dots,n\:\: r_i &lt; d_j\},\tag{2.e} \]" src="form_148.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[p^{ij}_k = \min\{d_j-r_i,p_k-\max\{\max\{0,r_i-r_k\},\max\{0,d_k-d_j\}\}\}\]" src="form_149.png"/>
</p>
<p> and <img class="formulaInl" alt="$S_{ij}=\{k:\; p^{ij}_k &gt; 0,\; 1\le k\le n\}$" src="form_150.png"/>. Here <img class="formulaInl" alt="$p^{ij}_k$" src="form_151.png"/> is the minimally possible duration of processing job <em>k</em> within the interval <img class="formulaInl" alt="$[r_i,d_j]$" src="form_152.png"/>. Each of the inequalities (2.e) expresses the fact that working time of the machine during any time interval cannot exceed the length of this interval. There may exist a lot of inequalities in system (2.e). Therefore, in our implementation these inequalities will be presented via a separation routine.</p>
<p>Note that, even after appending to (2) all the inequalities (2.e), the extended formulation remains incomplete.</p>
<h2><a class="anchor" id="sec_machineScheduleImpl"></a>
MIPCL-implementation</h2>
<p>Let us first notice that our main goal is to demonstrate a technique of implementing a sophisticated branching rule rather than to develop an efficient program for solving our scheduling problem.</p>
<p>As we are going to overload a number of virtual functions from the base class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>, we need to elaborate a new class derived from <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. This class, named <code>COneMachine</code>, is defined as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cmip_8h.html">cmip.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>COneMachine: <span class="keyword">public</span> <a class="code" href="classCMIP.html">CMIP</a></div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> m_iJobNum; </div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> *m_ipP, *m_ipR, *m_ipD;</div><div class="line">    <span class="keywordtype">double</span> *m_dpCost; </div><div class="line">    <span class="keywordtype">int</span> m_iDmax; </div><div class="line">    <span class="keywordtype">int</span> m_iJob1, m_iJob2; </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    COneMachine(<span class="keyword">const</span> <span class="keywordtype">char</span>* name,<span class="keywordtype">int</span> n, <span class="keywordtype">double</span>* c, <span class="keywordtype">int</span> *p, <span class="keywordtype">int</span> *r, <span class="keywordtype">int</span>* d);</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">        COneMachine(<span class="keyword">const</span> COneMachine &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">        <a class="code" href="classCMIP.html">CMIP</a>* <a class="code" href="classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a>(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        ~COneMachine() {}</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCMIP.html#a931123a832a3bcf0432ecf6fdeff6479">isFeasible</a>(<span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd);</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">startBranching</a>(<span class="keywordtype">int</span> nodeHeight);</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">updateBranch</a>(<span class="keywordtype">int</span> k);</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a16ed51f6357c2a1a7a9e3cd434296a41">getRow</a>(tagHANDLE hd, <span class="keywordtype">int</span> varNum, <span class="keyword">const</span> tagHANDLE* ipColHd,</div><div class="line">                <span class="keywordtype">int</span>&amp; type, <span class="keywordtype">double</span>&amp; b1, <span class="keywordtype">double</span>&amp; b2,</div><div class="line">                <span class="keywordtype">int</span>&amp; sz, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipCol, <span class="keywordtype">bool</span> &amp;scaled);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCLP.html#a06d0849fc963749a56b07560abaa6ad8">separate</a>(<span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ColHd, <span class="keywordtype">bool</span> GenFlag);</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> printSchedule(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName);</div><div class="line">};</div></div><!-- fragment --><p><code>COneMachine</code> has the following members:</p><ul>
<li><code>m_iJobNum</code>: number of jobs;</li>
<li><code>m_ipP</code>, <code>m_ipR</code>, <code>m_ipD</code>: integer arrays of size <code>m_iJobNum</code>, where<ul>
<li><code>m_ipP[j]</code>: processing time of job <code>j</code>;</li>
<li><code>m_ipR[j]</code>: release date of job <code>j</code>;</li>
<li><code>m_ipD[j]</code>: dead line of job <code>j</code>;</li>
</ul>
</li>
<li><code>m_dpCost</code>: real array of size <code>m_iJobNum</code>, where<ul>
<li><code>m_ipCost[j]</code>: processing cost of job <code>j</code>;</li>
</ul>
</li>
<li><code>m_iJob1</code>, <code>m_iJob2</code>: parameters that are set in <code>startBranching()</code> to be later used in <code>updateBranch()</code>.</li>
<li>Next, we discuss implementations of the constructors and the destructor of <code>Cmultlotsize</code>.</li>
</ul>
<p></p>
<div class="fragment"><div class="line">COneMachine::COneMachine(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> *c, <span class="keywordtype">int</span> *p, <span class="keywordtype">int</span> *r, <span class="keywordtype">int</span>* d): <a class="code" href="classCMIP.html">CMIP</a>(name)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> i, sz,dmax=-1, rmin=std::numeric_limits&lt;int&gt;::max();</div><div class="line">        m_iJobNum=n;</div><div class="line">        m_ipP=p; m_ipR=r; m_ipD=d; m_dpCost=c;</div><div class="line">        openMatrix(6*n,2*n,n+(n*n)/4);</div><div class="line">    <span class="keywordflow">for</span> (i=sz=0; i &lt; n; i++) {</div><div class="line">        addVar(i,VAR_BIN,c[i],0.0,1.0);</div><div class="line">        <span class="keywordflow">if</span> (p[i] &gt; 0) {</div><div class="line">            m_dpArray[sz]=p[i];</div><div class="line">            m_ipArray[sz++]=i;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (r[i] &lt; rmin)</div><div class="line">            rmin=r[i];</div><div class="line">        <span class="keywordflow">if</span> (d[i] &gt; dmax)</div><div class="line">            dmax=d[i];</div><div class="line">    }</div><div class="line">    m_iDmax=dmax;</div><div class="line">    <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {</div><div class="line">        setVarPriority(addVar(i+n,VAR_INT,0.0,r[i],d[i]-p[i]),VAR_PRI_MIN);</div><div class="line">    }</div><div class="line">    addRow(0,CTR_KNAPSACK | CTR_INT,-INF,dmax-rmin,sz,m_dpArray,m_ipArray);</div><div class="line"></div><div class="line">    preprocOff();</div><div class="line">    setScaling(SCL_NO);</div><div class="line">    closeMatrix();</div><div class="line">} <span class="comment">// end of COneMachine::COneMachine()</span></div></div><!-- fragment --><p>The constructor presented above has the following input parameters:</p><ul>
<li><code>name</code>: problem name which is passes to constructor of base class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>;</li>
<li><code>n</code>: number of jobs;</li>
<li><code>c</code>,<code>p</code>,<code>r</code>,<code>d</code>: arrays of size <code>n</code>, where<ul>
<li><code>c[j]</code>: processing cost of job <code>j</code>;</li>
<li><code>p[j]</code>: processing time of job <code>j</code>;</li>
<li><code>r[j]</code> and <code>d[j]</code>: release and due dates of job <code>j</code>.</li>
</ul>
</li>
</ul>
<p>The constructor builds a <code>MIPCL</code>-representation for incomplete formulation (2). First, it opens a matrix with <code>6*n</code> rows (<code>6*n</code> is bigger than the actual number of rows but we assume that many inequalities can be generated by the separation and cut generation procedures) and <code>2*n</code> columns (what equals the number of variables). The first <code>for</code> loop adds to the matrix <code>n</code> columns that correspond to binary variables <img class="formulaInl" alt="$x_j$" src="form_77.png"/>. Simultaneously, the priorities are set for these variables. This cycle also builds the constraint (2.c). As in many other applications, we use two auxiliary arrays, <code>m_dpArray</code> and <code>m_ipArray</code>, while preparing the constraints.</p>
<p>The second <code>for</code>-loop adds to the matrix <code>n</code> columns that correspond to variables <img class="formulaInl" alt="$s_j$" src="form_128.png"/>. These continuous variables are declared to be integer (this is not a restriction since, with integer parameters <img class="formulaInl" alt="$r_j,d_j,p_j$" src="form_153.png"/> and variables <img class="formulaInl" alt="$x_j$" src="form_77.png"/>, every variable <img class="formulaInl" alt="$s_j$" src="form_128.png"/> will take only integer values) in hope that this can help in generating stronger cuts. We set the lowest priorities to all variables <img class="formulaInl" alt="$s_j$" src="form_128.png"/> to avoid branching on them. It is also worth mentioning that all <code>2*n</code> columns could be added in the first <code>for</code>-loop. We do this in the second loop to make variable indices and handles be identical what will ease us to implement separating and branching procedures.</p>
<p>In the last rows of the code we add to the matrix the constraint (2.c), which was prepared in the second loop, then we switch off preprocessing and matrix scaling (the last is not necessary), and we finish by closing the matrix. Preprocessing must be off any time when initial formulation is incomplete (without future cuts).</p>
<p>The <em>clone constructor</em> is a variant of the copy constructor that copies only those structures that are not shared by different threads. Structures, shared by all threads, are represented by pointers.</p>
<p>In <code>COneMachine</code>, the clone constructor first copies only the number of jobs and the pointers to the arrays describing the jobs. </p><div class="fragment"><div class="line">COneMachine::COneMachine(<span class="keyword">const</span> COneMachine &amp;other, <span class="keywordtype">int</span> thread): <a class="code" href="classCMIP.html">CMIP</a>(other,thread)</div><div class="line">{</div><div class="line">        m_iJobNum=other.m_iJobNum;</div><div class="line">        m_ipP=other.m_ipP;</div><div class="line">        m_ipR=other.m_ipR;</div><div class="line">        m_ipD=other.m_ipD;</div><div class="line">        m_dpCost=other.m_dpCost;</div><div class="line">        m_iDmax=other.m_iDmax;</div><div class="line">}</div></div><!-- fragment --><p>When __MIPCL_ creates a new thread, it calls the function <code>clone()</code>. </p><div class="fragment"><div class="line"><a class="code" href="classCMIP.html">CMIP</a>* COneMachine::clone(<span class="keyword">const</span> <a class="code" href="classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread)</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;CMIP*&gt;(<span class="keyword">new</span> COneMachine(*static_cast&lt;COneMachine*&gt;(const_cast&lt;CMIP*&gt;(pMip)),thread));</div><div class="line">}</div></div><!-- fragment --><p> Implementation of <code>clone()</code> is standard, and its only purpose is to appropriately adjust types when calling the clone constructor.</p>
<h3><a class="anchor" id="sec_MSincompleInMIPCL"></a>
Working with incomplete formulations in MIPCL</h3>
<p>In <b>MIPCL</b>, working with an incomplete formulation (when constraints represented by separation routines are a part of the formulation) assumes that three virtual function </p><pre class="fragment">   `CMIP::isFeasible()`, `CMIP::startBranching()`, `CMIP::updateBranch()`,
</pre><p>and optionally other two functions </p><pre class="fragment">   `CLP::separate(), and `CLP::getRow()`
</pre><p> be overloaded.</p>
<p><code>isFeasible()</code> is called any time the solver detects a solution that satisfies all the constraints known for the solver.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">bool</span> COneMachine::isFeasible(<span class="keywordtype">int</span> varNum, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* ipColHd)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> i,n,j1,j2, *ipStart, *ipTsk;</div><div class="line">    n=m_iJobNum;</div><div class="line">    ipTsk=(ipStart=m_ipArray)+n;</div><div class="line">    <span class="keywordflow">for</span> (i=j1=0; i &lt; n; i++) {</div><div class="line">        <span class="keywordflow">if</span> (dpX[i] &gt; 0.5)</div><div class="line">            ipStart[ipTsk[j1++]=i]=(int)floor(dpX[n+i]+0.5);</div><div class="line">    }</div><div class="line">    <a class="code" href="namespaceSORT.html#a26380a518e5a901573dfddd8528055a6">SORT::incSortInt</a>(n=j1,ipTsk,ipStart);</div><div class="line">    j1=ipTsk[0];</div><div class="line">    <span class="keywordflow">for</span> (i=1; i &lt; n; i++) {</div><div class="line">        j2=ipTsk[i];</div><div class="line">        <span class="keywordflow">if</span> (ipStart[j1]+m_ipP[j1] &gt; ipStart[j2])</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        j1=j2;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="comment">// end of COneMachine::isFeasible()</span></div></div><!-- fragment --><p>This function returns <code>true</code>, if the solution, written into the arrays <code>dpX</code> and <code>ipColHd</code>, is feasible for the problem being solved; otherwise, the function returns <code>false</code>.</p>
<p>First, we extract from the array <code>dpX</code> the indices and values of those variables <img class="formulaInl" alt="$s_j$" src="form_128.png"/> that are processed <code>dpX[j]</code> &gt; 0.5; then we write these indices and values into the arrays <code>ipTsk</code> and <code>ipStart</code>. Next we call the function <code><a class="el" href="namespaceSORT.html#a26380a518e5a901573dfddd8528055a6" title="lists indices ipInd[i] in non-decreasing order of values ipVal[ipInd[i]].">SORT::incSortInt()</a></code> (auxiliary functions from the namespace <code><a class="el" href="namespaceSORT.html" title="Namespace SORT contains function for sorting arrays of different types.">SORT</a></code>) to list the jobs in <code>ipTsk</code> in nondecreasing order of their start times: <code>ipStart[ipTsk[i]] &lt;= ipStart[ipTsk[i+1]]</code>.</p>
<p>In the next loop, we check whether the machine is able to process all the jobs from <code>ipTsp</code> in the prescribed order: we look through the list <code>ipTsp</code> and start processing any job at the earliest time assuming that all preceding jobs have already been processed. The function returns <code>true</code> if the machine is able to process all the jobs stored in <code>ipTsp</code>, othervise, the function returns <code>false</code>.</p>
<p>Before proceeding to branching, __MIPCL_ calls <code>startBranching()</code> to make all necessary preparations for branching. Our implementation of this function is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> COneMachine::startBranching(<span class="keywordtype">int</span> nodeHeight)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> k;</div><div class="line">    m_iJob1=-1;</div><div class="line">    <span class="keywordflow">if</span> (!(k=<a class="code" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">CMIP::startBranching</a>(nodeHeight))) {</div><div class="line">        <span class="keywordtype">double</span> *dpX;</div><div class="line">        <span class="keywordtype">int</span> *ipHd, *ipStart, *ipTsk;</div><div class="line">        <span class="keywordtype">int</span> n,j1,j2;</div><div class="line">        n=m_iJobNum;</div><div class="line">        ipTsk=(ipStart=m_ipArray)+n;</div><div class="line">        <a class="code" href="classCLP.html#a1636d6070c91135f68892056e59b33b4">CLP::getSolution</a>(dpX,ipHd);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=k=0; i &lt; n; ++i) {</div><div class="line">            <span class="keywordflow">if</span> (dpX[i] &gt; 0.5)</div><div class="line">                ipStart[ipTsk[k++]=i]=(int)floor(dpX[n+i]+0.5);</div><div class="line">        }</div><div class="line">        <a class="code" href="namespaceSORT.html#a26380a518e5a901573dfddd8528055a6">SORT::incSortInt</a>(k,ipTsk,ipStart);</div><div class="line">        j1=ipTsk[0];</div><div class="line">        n=k; k=0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i &lt; n; ++i) {</div><div class="line">            j2=ipTsk[i];</div><div class="line">            <span class="keywordflow">if</span> (ipStart[j1]+m_ipP[j1] &gt; ipStart[j2]) {</div><div class="line">                k=3;</div><div class="line">                m_iJob1=j1;</div><div class="line">                m_iJob2=j2;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">            j1=j2;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> k;</div><div class="line">} <span class="comment">// end of COneMachine::startBranching()</span></div></div><!-- fragment --><p>First, we call the function <code><a class="el" href="classCMIP.html#a591895e6bb2d334e6fb8f0a76711c099">CMIP::startBranching()</a></code> of the base class <code><a class="el" href="classCMIP.html" title="Class CMIP has been designed for solving Mixed Integer Programs (MIPs)">CMIP</a></code>. If this function detects an integer variable with fractional value, then it performs all necessary preparations for branching on this variable, and returns <code>k=2</code> as the number of branches. In such a case, our overloaded function terminates with the return value of <code>2</code>, previously having set the value of <code>m_bBflag</code> to <code>-1</code>, what means that branching will be carried out by the standard <b>MIPCL</b> routines. Otherwise, if the base function returns <code>0</code> (no integer variable with fractional value have been found), we look for two jobs <code>j1</code> and <code>j2</code> that are to be processed and their processing intervals are intersecting, i.e.,</p><ul>
<li><code>dpX[j1] &gt; 0.5</code>,</li>
<li><code>dpX[j2]</code> &gt; 0.5,</li>
<li><code>ipStart[j1] &lt;= ipStart[j2]</code>,</li>
<li><code>ipStart[j1]+ m_ipP[j1] &gt;= ipStart[j2]</code>.</li>
</ul>
<p>If a pair of jobs with the above properties has been detected, then indices of these jobs are stored in the class members <code>m_iJob1</code>, <code>m_iJob2</code>, and the function returns <code>3</code>; otherwise, the return value is <code>0</code>.</p>
<p>The function <code>updateBranch()</code> is called just before processing a particular branch. its implementation is given below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> COneMachine::updateBranch(<span class="keywordtype">int</span> k)</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> flag;</div><div class="line">    <span class="keywordflow">if</span> (m_iJob1 &lt; 0) {</div><div class="line">        flag=<a class="code" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">CMIP::updateBranch</a>(k);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordtype">double</span> dpVal[2];</div><div class="line">        <span class="keywordtype">int</span> hd, j1, j2, ipCol[2];</div><div class="line">        <span class="keywordflow">if</span> (k) {</div><div class="line">            j1=m_iJob1;</div><div class="line">            j2=m_iJob2;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">            j1=m_iJob2;</div><div class="line">            j2=m_iJob1;</div><div class="line">        }</div><div class="line">        hd=(j1 | (j2 &lt;&lt; (4*<span class="keyword">sizeof</span>(int)))) &lt;&lt; 1;</div><div class="line">        <span class="keywordflow">if</span> (k &lt; 2) {</div><div class="line">            dpVal[0]=1.0; dpVal[1]=-1.0;</div><div class="line">            ipCol[0]=m_iJobNum+j2;</div><div class="line">            ipCol[1]=m_iJobNum+j1;</div><div class="line">            addCut(hd,CTR_INT|CTR_LOCAL|CTR_ATTACHED,m_ipP[j1],INF,2,dpVal,ipCol);</div><div class="line">            setVarLoBound(j1,1.0);</div><div class="line">            setVarLoBound(j2,1.0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">            dpVal[0]=dpVal[1]=1.0;</div><div class="line">            ipCol[0]=j1; ipCol[1]=j2;</div><div class="line">            addCut(hd+1,CTR_INT|CTR_PACKING|CTR_LOCAL|CTR_ATTACHED,-INF,1.0,2,dpVal,ipCol);</div><div class="line">        }</div><div class="line">        flag=<span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> flag;</div><div class="line">} <span class="comment">// end of COneMachine::updateBranch()</span></div></div><!-- fragment --><p>Any negative value of <code>m_iJob1</code> indicates that the base class function <code><a class="el" href="classCMIP.html#a46358134da85552da3e76a53ca9eaf43">CMIP::updateBranch()</a></code> is to be called, and our overloaded function terminates with the return value of the base function. Otherwise (<code>m_iJob1 &gt;= 0</code>), branching is done on the pair of jobs <code>j1=m_iJob1</code> and <code>j2=m_iJob2</code> that were previously stored by <code>startBranching()</code>. There will be three branches. For Branch <code>0</code> (<code>k=0</code>), the parent problem is modified as follows.</p>
<ol type="1">
<li>Calling twice <code>setVarLoBound()</code>, we fix the values of two variables <code>dpX[j1]=dpX[j2]=1</code>, what requires that both jobs, <code>j1</code> and <code>j2</code>, be processed.</li>
<li>To force <code>j1</code> be followed by job <code>j2</code>, we add the local (of type <code>CTR_LOCAL</code>) cut<ul>
<li><code>x[n+j2] - x[n+j1] &gt;= m_ipP[j1]</code> (here <em>n</em> stands for the number of jobs),</li>
<li>which in the mathematical variables is rewritten as the inequality <img class="formulaInl" alt="$s_{j1} + p_{j1} \le s_{j2}$" src="form_154.png"/>.</li>
</ul>
</li>
</ol>
<p>For Branch <code>1</code> (<code>k=1</code>), the parent problem is modified quite similarly, if the jobs <code>j1</code> are <code>j2</code> have been previously exchanged.</p>
<p>And, at last, for Branch <code>2</code> (<code>k=2</code>), the parent problem is appended by the inequality</p><ul>
<li><code>x[j1] + x[j2] &lt;= 1</code> ( <img class="formulaInl" alt="$x_{j1}+x_{j2}\le 1$" src="form_155.png"/>), which do not allow simultaneously processing both jobs <code>j1</code> and <code>j2</code>.</li>
</ul>
<p>All cuts, that are added by <code>updateBranch()</code>, must be of type <code>CTR_ATTACHED</code> what forbids the solver to delete such cuts from the current node and all its descendants.</p>
<h3><a class="anchor" id="sec_MSgetRow"></a>
Cuts with nonnegative handles</h3>
<p>Cuts with nonnegative handles are not stored in the cut pool. Therefore, the user has to reload the function <code>getRow()</code> that, given a handle, must return the inequality that corresponds to this handle.</p>
<p>As a rule, nonnegative handles point to data structures that describe corresponding constraints. Instead, in our implementation of <code>updateBranch()</code>, we encode cuts <img class="formulaInl" alt="$x_{j1}+x_{j2}\le 1$" src="form_155.png"/> added by <code>updateBranch()</code> into their handles: <code>j1</code> and <code>j2</code> are written into, respectively, low and high halfwords of the handle <code>hd</code>, the result is shifted one bit left, and, for branch <code>2</code>, <code>hd</code> is increased by <code>1</code>.</p>
<p>Our implementation <code>getRow()</code> is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> COneMachine::getRow(tagHANDLE hd,</div><div class="line">        <span class="keywordtype">int</span> varNum, <span class="keyword">const</span> tagHANDLE* ipColHd,</div><div class="line">        <span class="keywordtype">int</span>&amp; type, <span class="keywordtype">double</span>&amp; b1, <span class="keywordtype">double</span>&amp; b2,</div><div class="line">        <span class="keywordtype">int</span>&amp; sz, <span class="keywordtype">double</span>* dpVal, <span class="keywordtype">int</span>* ipCol, <span class="keywordtype">bool</span> &amp;scaled)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> k,j1, j2;</div><div class="line">    k=hd &amp; 0x1;</div><div class="line">    hd&gt;&gt;=1;</div><div class="line">    j2=hd &gt;&gt; (4*<span class="keyword">sizeof</span>(int));</div><div class="line">    j1=hd ^ (j2 &lt;&lt; (4*<span class="keyword">sizeof</span>(int)));</div><div class="line"></div><div class="line">    type=CTR_INT | CTR_LOCAL | CTR_ATTACHED;</div><div class="line">    sz=2;</div><div class="line">    <span class="keywordflow">if</span> (k == 1) {</div><div class="line">        type|=CTR_PACKING;</div><div class="line">        b1=-INF;</div><div class="line">        b2=1.0;</div><div class="line">        dpVal[0]=dpVal[1]=1.0;</div><div class="line">        ipCol[0]=j1;</div><div class="line">        ipCol[1]=j2;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        b2=INF;</div><div class="line">        b1=m_ipP[j1];</div><div class="line">        dpVal[0]=1.0;</div><div class="line">        dpVal[1]=-1.0;</div><div class="line">        ipCol[0]=m_iJobNum+j2;</div><div class="line">        ipCol[1]=m_iJobNum+j1;</div><div class="line">    }</div><div class="line">    scaled=<span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">} <span class="comment">// end of COneMachine::getRow()</span></div></div><!-- fragment --><p>Its first parameter, <code>hd</code>, is the handle of a constraint to be restored. As we canceled preprocessing, the handles of variables are their indices. Therefore, the second (number of variables) and third (handles of variables) arguments are not used in our implementation. All other arguments are output parameters. The constraint type, passed via the parameter <code>type</code>, must be set to the same value that was assigned to the constraint when it was first generated in function <code>updateBranch()</code>. The other output parameters represent the constraint </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ b1\le \sum_{i=0}^{sz-1} dpVal[i]\cdot x[ipCol[i]] \le b2. \]" src="form_156.png"/>
</p>
<p>To understand, which constraint must be returned, we extract two job indices, <code>j1</code> and <code>j2</code>, from the handle <code>hd</code>. If <code>hd</code> is an even number, then it represents the inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x[n+j2] - x[n+j1] \ge m_ipP[j1]\quad (s_{j1} + p_{j1} \le s_{j2}), \]" src="form_157.png"/>
</p>
<p> and if the handle is odd, then it represents the inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x[n+j1] + x[n+j2] \le 1\quad (x_{j1} + x_{j2} \le 1), \]" src="form_158.png"/>
</p>
<p> where <em>n</em> denotes the number of jobs.</p>
<h3><a class="anchor" id="sec_MScuts"></a>
Seperation Procedure</h3>
<p>Our separation procedure for the inequalities (2.e) is as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> COneMachine::separate(<span class="keywordtype">int</span> varNum,</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>* dpX, <span class="keyword">const</span> tagHANDLE* colHd, <span class="keywordtype">bool</span> genFlag)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> w;</div><div class="line">        <span class="keywordtype">int</span> *ipR, *ipD, *ipT1, *ipT2;</div><div class="line">        <span class="keywordtype">int</span> k1,k2,d,delta,s1,s2,sz,type,t1,t2,cutNum=0,n=m_iJobNum;</div><div class="line"></div><div class="line">        ipT1=reinterpret_cast&lt;int*&gt;(m_dpFd); ipT2=ipT1+n;</div><div class="line">        ipR=reinterpret_cast&lt;int*&gt;(m_dpFb); ipD=ipR+n;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=sz=0; i &lt; n; ++i) {</div><div class="line">                ipR[i]=static_cast&lt;int&gt;(floor(getVarLoBound(i+n)+0.5));</div><div class="line">                ipD[i]=static_cast&lt;int&gt;(floor(getVarUpBound(i+n)+0.5))+m_ipP[i];</div><div class="line">                <span class="keywordflow">if</span> (dpX[i] &gt; 0.1) {</div><div class="line">                        ipT1[sz]=ipR[i];</div><div class="line">                        ipT2[sz++]=-ipD[i];</div><div class="line">                }</div><div class="line">        }</div><div class="line">        std::sort(ipT1,ipT1+sz);</div><div class="line">        std::sort(ipT2,ipT2+sz);</div><div class="line">        t1=ipT1[0]; t2=(ipT2[0]=-ipT2[0]);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=k1=k2=1; i &lt; sz; ++i) {</div><div class="line">                <span class="keywordflow">if</span> (t1 &lt; ipT1[i])</div><div class="line">                        t1=ipT1[k1++]=ipT1[i];</div><div class="line">                ipT2[i]=-ipT2[i];</div><div class="line">                <span class="keywordflow">if</span> (t2 &gt; ipT2[i])</div><div class="line">                        t2=ipT2[k2++]=ipT2[i];</div><div class="line">        }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; k1; ++i) {</div><div class="line">                t1=ipT1[i];</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; k2; ++j) {</div><div class="line">                        t2=ipT2[j];</div><div class="line">                        <span class="keywordflow">if</span> ((delta=t2-t1) &lt;= 0)</div><div class="line">                                <span class="keywordflow">break</span>;</div><div class="line">                        w=0.0;</div><div class="line">                        type=CTR_INT | CTR_KNAPSACK;</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=sz=0; k &lt; n; ++k) {</div><div class="line">                                s1=s2=m_ipP[k];</div><div class="line">                                <span class="keywordflow">if</span> (ipR[k] &lt; t1)</div><div class="line">                                        s1-=(t1-ipR[k]);</div><div class="line">                                <span class="keywordflow">if</span> (ipD[k] &gt; t2)</div><div class="line">                                        s2-=(ipD[k]-t2);</div><div class="line">                                d=(s1 &lt; s2)? s1: s2;</div><div class="line">                                <span class="keywordflow">if</span> (d &gt; delta)</div><div class="line">                                        d=delta;</div><div class="line">                                <span class="keywordflow">if</span> (d &gt; 0) {</div><div class="line">                                        w+=(m_dpArray[sz]=d)*dpX[k];</div><div class="line">                                        m_ipArray[sz++]=k;</div><div class="line">                                        <span class="keywordflow">if</span> (ipR[k] &gt; m_ipR[k] || ipD[k] &lt; m_ipD[k])</div><div class="line">                                                type|=CTR_LOCAL;</div><div class="line">                                }</div><div class="line">                        } <span class="comment">// for (int k=sz=0;</span></div><div class="line">                        <span class="keywordflow">if</span> (w &gt; 1.01*delta) {</div><div class="line">                                <span class="keywordflow">if</span> (genFlag) {</div><div class="line">                                        safeAddCut(-2,type,-INF,delta,sz,m_dpArray,m_ipArray);</div><div class="line"><span class="comment">//                                      printRow(m_iM-1);</span></div><div class="line">                                        ++cutNum;</div><div class="line">                                        ipR=reinterpret_cast&lt;int*&gt;(m_dpFb); ipD=ipR+n;</div><div class="line">                                }</div><div class="line">                                <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">                        }</div><div class="line">                } <span class="comment">// for (int j=0;</span></div><div class="line">        } <span class="comment">// for (int i=0;</span></div><div class="line">        <span class="keywordflow">return</span> (cutNum)? <span class="keyword">true</span>: <span class="keyword">false</span>;</div><div class="line">} <span class="comment">// end of COneMachine::separate()</span></div></div><!-- fragment --><p>This procedure gets on input a point <img class="formulaInl" alt="$x\in [0,1]^n$" src="form_159.png"/> that is stored in the first <code>n</code> positions of the input array <code>dpX</code>, where <code>n</code> denote the number of jobs. In fact, the algorithm implemented in <code>separate()</code> is very simple, and you can easily understand it. Nevertheless, a few explanations are necessary. As we have mentioned earlier, system (2.e) has a lot of constraints and verifying all of them would be time consuming. That is why we verify only inequalities written for intervals <img class="formulaInl" alt="$[r_i,d_j]$" src="form_152.png"/> with <code>dpX[i] &gt; 0.1</code> and <code>dpX[j] &gt; 0.1</code>. Before entering the main loop, the array <code>ipT1</code> (resp., <code>ipT2</code>) contains distinct values <img class="formulaInl" alt="$r_i$" src="form_160.png"/> (resp., <img class="formulaInl" alt="$d_j$" src="form_120.png"/>) listed in increasing order. In the main loop, for all pairs <code>t1=ipT1[i]</code> and <code>t2=ipT2[j]</code> such that <code>t1 &lt; t2</code>, we check the inequality written for the interval <code>[t1,t2]</code>, and, if it is violated by +x_, a new cut is added. You may be confused by the next two assignments: </p><pre class="fragment">   ipR=reinterpret_cast&lt;int*&gt;(m_dpFb); ipD=ipR+n;
</pre><p>They appear here because <b>MIPCL</b> can reallocate memory during the call to <code>addCut()</code>. After reallocation, the pointers <code>ipT1</code> and <code>ipT2</code> will be not correct anymore.</p>
<h2><a class="anchor" id="sec_MSdemo"></a>
Demonstration of using class COneMachine</h2>
<p>To demonstrate the usage of our class <code>COneMachine</code>, we wrote the following program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="except_8h.html">except.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;oneMachine.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> read(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName,</div><div class="line">         <span class="keywordtype">int</span> &amp;n, <span class="keywordtype">int</span>* &amp;r, <span class="keywordtype">int</span>* &amp;d, <span class="keywordtype">int</span>* &amp;p, <span class="keywordtype">double</span>* &amp;c)</div><div class="line">{</div><div class="line">    std::ifstream fin(fileName);</div><div class="line">    <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <a class="code" href="classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;read&quot;</span>,fileName);</div><div class="line">    }</div><div class="line">    fin.ignore(256,<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">    fin &gt;&gt; n;</div><div class="line">    r = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];</div><div class="line">    d = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];</div><div class="line">    p = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];</div><div class="line">    c = <span class="keyword">new</span> <span class="keywordtype">double</span>[n]; </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; i++) {</div><div class="line">        fin &gt;&gt; r[i] &gt;&gt; d[i] &gt;&gt; p[i] &gt;&gt; c[i];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> n, *r,*d,*p;</div><div class="line">    <span class="keywordtype">double</span> *c;</div><div class="line">    <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Enter file name as the argument!\n&quot;</span>; </div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        read(argv[1],n,r,d,p,c);</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;n=&quot;</span> &lt;&lt; n &lt;&lt; std::endl;</div><div class="line">        COneMachine prob(<span class="stringliteral">&quot;OneMachine&quot;</span>,n,c,p,r,d);</div><div class="line">        prob.optimize();</div><div class="line">        <span class="keywordtype">char</span> str[256];</div><div class="line">        strcpy(str,argv[1]);</div><div class="line">        strcat(str,<span class="stringliteral">&quot;.sol&quot;</span>);</div><div class="line">        prob.printSchedule(str);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>(<a class="code" href="classCException.html">CException</a>* pe) {</div><div class="line">        std::cerr &lt;&lt; pe-&gt;<a class="code" href="classCException.html#af66e5406dda297fa8b253e89b6e00973">what</a>() &lt;&lt; std::endl;</div><div class="line">        <span class="keyword">delete</span> pe;</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (c) <span class="keyword">delete</span>[] c;</div><div class="line">    <span class="keywordflow">if</span> (p) <span class="keyword">delete</span>[] p;</div><div class="line">    <span class="keywordflow">if</span> (d) <span class="keyword">delete</span>[] d;</div><div class="line">    <span class="keywordflow">if</span> (r) <span class="keyword">delete</span>[] r;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>In <code>main(), we first call</code>readInstance()` function to read an instance of <img class="formulaInl" alt="$1|r_j,d_j|\sum w_jU_j$" src="form_126.png"/> the file which name is passed to the program as the first argument. The first line of this input file contains a single integer number <code>n</code>, which is the number of jobs, and each of <code>n</code> next lines describes a job by four integer numbers (release and due dates, processing time, and weight) separated by spaces. After reading input data, we create an instance, named <code>prob</code>, of our class <code>COneMachine</code>, then we call <code><a class="el" href="classCMIP.html#af68f591f9fb72ea0dfe2e7964c8265da">CMIP::optimize()</a></code> to solve the problem, and <code>COneMashine::printSchedule()</code> to write the result into the text file which name is the input file name appended by ".sol". </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 28 2019 21:54:33 for MIPCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
